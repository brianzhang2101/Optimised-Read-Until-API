// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: minknow_api/manager.proto
#ifndef GRPC_minknow_5fapi_2fmanager_2eproto__INCLUDED
#define GRPC_minknow_5fapi_2fmanager_2eproto__INCLUDED

#include "minknow_api/manager.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace minknow_api {
namespace manager {

class ManagerService final {
 public:
  static constexpr char const* service_full_name() {
    return "minknow_api.manager.ManagerService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Get information about the machine running MinKNOW.
    //
    // This RPC can be called without providing any authentication tokens.
    //
    // Since 3.6
    virtual ::grpc::Status describe_host(::grpc::ClientContext* context, const ::minknow_api::manager::DescribeHostRequest& request, ::minknow_api::manager::DescribeHostResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::DescribeHostResponse>> Asyncdescribe_host(::grpc::ClientContext* context, const ::minknow_api::manager::DescribeHostRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::DescribeHostResponse>>(Asyncdescribe_hostRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::DescribeHostResponse>> PrepareAsyncdescribe_host(::grpc::ClientContext* context, const ::minknow_api::manager::DescribeHostRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::DescribeHostResponse>>(PrepareAsyncdescribe_hostRaw(context, request, cq));
    }
    // List all known positions where flow cells can be inserted.
    //
    // Provides a snapshot of places where users can insert flow cells. It has a streamed response
    // in case there are too many positions to fit into a single response, but normally there should
    // only be a single response.
    //
    // This RPC can be called without providing any authentication tokens.
    //
    // Since 3.6
    std::unique_ptr< ::grpc::ClientReaderInterface< ::minknow_api::manager::FlowCellPositionsResponse>> flow_cell_positions(::grpc::ClientContext* context, const ::minknow_api::manager::FlowCellPositionsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::minknow_api::manager::FlowCellPositionsResponse>>(flow_cell_positionsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::manager::FlowCellPositionsResponse>> Asyncflow_cell_positions(::grpc::ClientContext* context, const ::minknow_api::manager::FlowCellPositionsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::manager::FlowCellPositionsResponse>>(Asyncflow_cell_positionsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::manager::FlowCellPositionsResponse>> PrepareAsyncflow_cell_positions(::grpc::ClientContext* context, const ::minknow_api::manager::FlowCellPositionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::manager::FlowCellPositionsResponse>>(PrepareAsyncflow_cell_positionsRaw(context, request, cq));
    }
    // Watch for changes in flow cell position availability and state.
    //
    // This is like flow_cell_positions, but updates are streamed as positions come and go (eg:
    // MinIONs being plugged or unplugged), or their status otherwise changes.
    //
    // This RPC can be called without providing any authentication tokens.
    //
    // Since 3.6
    std::unique_ptr< ::grpc::ClientReaderInterface< ::minknow_api::manager::WatchFlowCellPositionsResponse>> watch_flow_cell_positions(::grpc::ClientContext* context, const ::minknow_api::manager::WatchFlowCellPositionsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::minknow_api::manager::WatchFlowCellPositionsResponse>>(watch_flow_cell_positionsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::manager::WatchFlowCellPositionsResponse>> Asyncwatch_flow_cell_positions(::grpc::ClientContext* context, const ::minknow_api::manager::WatchFlowCellPositionsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::manager::WatchFlowCellPositionsResponse>>(Asyncwatch_flow_cell_positionsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::manager::WatchFlowCellPositionsResponse>> PrepareAsyncwatch_flow_cell_positions(::grpc::ClientContext* context, const ::minknow_api::manager::WatchFlowCellPositionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::manager::WatchFlowCellPositionsResponse>>(PrepareAsyncwatch_flow_cell_positionsRaw(context, request, cq));
    }
    // Reset a flow cell position.
    //
    // If the hardware is in an error state or has been removed and the software is running, it will
    // stop the software (causing the position to be forgotten if the hardware was removed).
    //
    // If the hardware is not in an error state
    virtual ::grpc::Status reset_position(::grpc::ClientContext* context, const ::minknow_api::manager::ResetPositionRequest& request, ::minknow_api::manager::ResetPositionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::ResetPositionResponse>> Asyncreset_position(::grpc::ClientContext* context, const ::minknow_api::manager::ResetPositionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::ResetPositionResponse>>(Asyncreset_positionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::ResetPositionResponse>> PrepareAsyncreset_position(::grpc::ClientContext* context, const ::minknow_api::manager::ResetPositionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::ResetPositionResponse>>(PrepareAsyncreset_positionRaw(context, request, cq));
    }
    // Get the connection information for the basecaller API.
    //
    // This is the service that implements the minknow_api.basecaller interface for basecalling
    // reads files.
    //
    // This RPC can be called without providing any authentication tokens.
    //
    // Since 3.5
    virtual ::grpc::Status basecaller_api(::grpc::ClientContext* context, const ::minknow_api::manager::BasecallerApiRequest& request, ::minknow_api::manager::BasecallerApiResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::BasecallerApiResponse>> Asyncbasecaller_api(::grpc::ClientContext* context, const ::minknow_api::manager::BasecallerApiRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::BasecallerApiResponse>>(Asyncbasecaller_apiRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::BasecallerApiResponse>> PrepareAsyncbasecaller_api(::grpc::ClientContext* context, const ::minknow_api::manager::BasecallerApiRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::BasecallerApiResponse>>(PrepareAsyncbasecaller_apiRaw(context, request, cq));
    }
    // Get information about Guppy, including the port to connect to it on.
    //
    // Since 4.1
    virtual ::grpc::Status get_guppy_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetGuppyInfoRequest& request, ::minknow_api::manager::GetGuppyInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetGuppyInfoResponse>> Asyncget_guppy_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetGuppyInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetGuppyInfoResponse>>(Asyncget_guppy_infoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetGuppyInfoResponse>> PrepareAsyncget_guppy_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetGuppyInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetGuppyInfoResponse>>(PrepareAsyncget_guppy_infoRaw(context, request, cq));
    }
    // Current version information includes:
    // - Minknow version
    // - Protocols version (i.e. Bream-4 version)
    // - Configuration version (i.e. Wanda version)
    // - Distribution version
    // - Guppy version
    //
    // This RPC can be called without providing any authentication tokens.
    //
    // See also: instance.get_version_info which provides some similar information on a per instance basis.
    // Since 3.3
    virtual ::grpc::Status get_version_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetVersionInfoRequest& request, ::minknow_api::manager::GetVersionInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetVersionInfoResponse>> Asyncget_version_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetVersionInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetVersionInfoResponse>>(Asyncget_version_infoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetVersionInfoResponse>> PrepareAsyncget_version_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetVersionInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetVersionInfoResponse>>(PrepareAsyncget_version_infoRaw(context, request, cq));
    }
    // Returns all the files that are within the protocol output dir specified in the user_conf - or a descendant of that directory
    // if `path` is supplied in the request.
    //
    // INVALID_ARGUMENT will be returned if the `path` argument in the request is not a descendant of the protocol output directory
    //
    // NOT_FOUND will be returned if the path does not exist. 'The path' being either the protocol output directory if the `path` argument is not specified
    // or a valid `path` argument is specified but does not exist.
    //
    // Since 3.5
    std::unique_ptr< ::grpc::ClientReaderInterface< ::minknow_api::manager::ListProtocolOutputDirFilesResponse>> list_protocol_output_dir_files(::grpc::ClientContext* context, const ::minknow_api::manager::ListProtocolOutputDirFilesRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::minknow_api::manager::ListProtocolOutputDirFilesResponse>>(list_protocol_output_dir_filesRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::manager::ListProtocolOutputDirFilesResponse>> Asynclist_protocol_output_dir_files(::grpc::ClientContext* context, const ::minknow_api::manager::ListProtocolOutputDirFilesRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::manager::ListProtocolOutputDirFilesResponse>>(Asynclist_protocol_output_dir_filesRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::manager::ListProtocolOutputDirFilesResponse>> PrepareAsynclist_protocol_output_dir_files(::grpc::ClientContext* context, const ::minknow_api::manager::ListProtocolOutputDirFilesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::manager::ListProtocolOutputDirFilesResponse>>(PrepareAsynclist_protocol_output_dir_filesRaw(context, request, cq));
    }
    // Create a directory within the protocol output directory tree.
    //
    // Errors:
    //     INVALID_ARGUMENT will be returned if the parent path (where the directory is requested to
    //         be created) is not within the protocol output directory, or if invalid characters are
    //         in the requested directory name.
    //
    //     FAILED_PRECONDITION will be returned if the parent path is not a directory.
    //
    //     NOT_FOUND will be returned if the parent path does not exist.
    //
    //     ALREADY_EXISTS will be returned if the directory exists and is not a directory (if the
    //         directory already exists, this is treated as success).
    //
    // The possible valid parent paths can be determined using list_protocol_output_dir_files().
    //
    // Since 3.6
    virtual ::grpc::Status create_directory(::grpc::ClientContext* context, const ::minknow_api::manager::CreateDirectoryRequest& request, ::minknow_api::manager::CreateDirectoryResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::CreateDirectoryResponse>> Asynccreate_directory(::grpc::ClientContext* context, const ::minknow_api::manager::CreateDirectoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::CreateDirectoryResponse>>(Asynccreate_directoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::CreateDirectoryResponse>> PrepareAsynccreate_directory(::grpc::ClientContext* context, const ::minknow_api::manager::CreateDirectoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::CreateDirectoryResponse>>(PrepareAsynccreate_directoryRaw(context, request, cq));
    }
    // Returns information about the amount of disk space available, how much
    // space is needed to stop an experiment cleanly and if MinKNOW thinks
    // that the free disk-space is approaching or past this limit
    //
    // Since 3.7
    virtual ::grpc::Status get_disk_space_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetDiskSpaceInfoRequest& request, ::minknow_api::manager::GetDiskSpaceInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetDiskSpaceInfoResponse>> Asyncget_disk_space_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetDiskSpaceInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetDiskSpaceInfoResponse>>(Asyncget_disk_space_infoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetDiskSpaceInfoResponse>> PrepareAsyncget_disk_space_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetDiskSpaceInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetDiskSpaceInfoResponse>>(PrepareAsyncget_disk_space_infoRaw(context, request, cq));
    }
    // As with `instance.get_default_output_directories`, this will return the
    // paths that are defined in the config used when an instance of minknow
    // is started.
    //
    // Since 4.3
    virtual ::grpc::Status get_default_output_directories(::grpc::ClientContext* context, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest& request, ::minknow_api::instance::OutputDirectories* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::OutputDirectories>> Asyncget_default_output_directories(::grpc::ClientContext* context, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::OutputDirectories>>(Asyncget_default_output_directoriesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::OutputDirectories>> PrepareAsyncget_default_output_directories(::grpc::ClientContext* context, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::OutputDirectories>>(PrepareAsyncget_default_output_directoriesRaw(context, request, cq));
    }
    // Stream information about the amount of disk space available, how quickly
    // it is being used, how much space is needed to stop an experiment cleanly
    // and if MinKNOW thinks that the free disk-space is approaching or past
    // this limit
    //
    // Since 4.0
    std::unique_ptr< ::grpc::ClientReaderInterface< ::minknow_api::manager::GetDiskSpaceInfoResponse>> stream_disk_space_info(::grpc::ClientContext* context, const ::minknow_api::manager::StreamDiskSpaceInfoRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::minknow_api::manager::GetDiskSpaceInfoResponse>>(stream_disk_space_infoRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::manager::GetDiskSpaceInfoResponse>> Asyncstream_disk_space_info(::grpc::ClientContext* context, const ::minknow_api::manager::StreamDiskSpaceInfoRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::manager::GetDiskSpaceInfoResponse>>(Asyncstream_disk_space_infoRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::manager::GetDiskSpaceInfoResponse>> PrepareAsyncstream_disk_space_info(::grpc::ClientContext* context, const ::minknow_api::manager::StreamDiskSpaceInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::manager::GetDiskSpaceInfoResponse>>(PrepareAsyncstream_disk_space_infoRaw(context, request, cq));
    }
    // Get info about all available barcoding kits
    //
    // Since 4.1
    virtual ::grpc::Status get_barcode_kit_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetBarcodeKitInfoRequest& request, ::minknow_api::manager::GetBarcodeKitInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetBarcodeKitInfoResponse>> Asyncget_barcode_kit_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetBarcodeKitInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetBarcodeKitInfoResponse>>(Asyncget_barcode_kit_infoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetBarcodeKitInfoResponse>> PrepareAsyncget_barcode_kit_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetBarcodeKitInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetBarcodeKitInfoResponse>>(PrepareAsyncget_barcode_kit_infoRaw(context, request, cq));
    }
    // Get info about all available lamp kits
    //
    // Since 4.1
    virtual ::grpc::Status get_lamp_kit_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetLampKitInfoRequest& request, ::minknow_api::manager::GetLampKitInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetLampKitInfoResponse>> Asyncget_lamp_kit_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetLampKitInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetLampKitInfoResponse>>(Asyncget_lamp_kit_infoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetLampKitInfoResponse>> PrepareAsyncget_lamp_kit_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetLampKitInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetLampKitInfoResponse>>(PrepareAsyncget_lamp_kit_infoRaw(context, request, cq));
    }
    // List all barcode keys associated with the specified barcoding kits
    //
    // Since 4.1
    virtual ::grpc::Status get_barcode_keys(::grpc::ClientContext* context, const ::minknow_api::manager::GetBarcodeKeysRequest& request, ::minknow_api::manager::GetBarcodeKeysResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetBarcodeKeysResponse>> Asyncget_barcode_keys(::grpc::ClientContext* context, const ::minknow_api::manager::GetBarcodeKeysRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetBarcodeKeysResponse>>(Asyncget_barcode_keysRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetBarcodeKeysResponse>> PrepareAsyncget_barcode_keys(::grpc::ClientContext* context, const ::minknow_api::manager::GetBarcodeKeysRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetBarcodeKeysResponse>>(PrepareAsyncget_barcode_keysRaw(context, request, cq));
    }
    // List all known types of flow cell.
    //
    // The primary purpose of this RPC is to provide a list of flow cell types for a user to select
    // from (although most flow cells are capable of telling MinKNOW their product code, making user
    // selection unnecessary).
    //
    // A secondary benefit of this call is it allows extra information about flow cell types to be
    // given.
    //
    // Since 4.1
    virtual ::grpc::Status get_flow_cell_types(::grpc::ClientContext* context, const ::minknow_api::manager::GetFlowCellTypesRequest& request, ::minknow_api::manager::GetFlowCellTypesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetFlowCellTypesResponse>> Asyncget_flow_cell_types(::grpc::ClientContext* context, const ::minknow_api::manager::GetFlowCellTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetFlowCellTypesResponse>>(Asyncget_flow_cell_typesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetFlowCellTypesResponse>> PrepareAsyncget_flow_cell_types(::grpc::ClientContext* context, const ::minknow_api::manager::GetFlowCellTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetFlowCellTypesResponse>>(PrepareAsyncget_flow_cell_typesRaw(context, request, cq));
    }
    // List all known sequencing kits.
    //
    // The intention is to provide a list of sequencing kits for a user to select from, plus extra
    // information that can be used to filter that list.
    //
    // Since 4.1
    virtual ::grpc::Status get_sequencing_kits(::grpc::ClientContext* context, const ::minknow_api::manager::GetSequencingKitsRequest& request, ::minknow_api::manager::GetSequencingKitsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetSequencingKitsResponse>> Asyncget_sequencing_kits(::grpc::ClientContext* context, const ::minknow_api::manager::GetSequencingKitsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetSequencingKitsResponse>>(Asyncget_sequencing_kitsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetSequencingKitsResponse>> PrepareAsyncget_sequencing_kits(::grpc::ClientContext* context, const ::minknow_api::manager::GetSequencingKitsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetSequencingKitsResponse>>(PrepareAsyncget_sequencing_kitsRaw(context, request, cq));
    }
    // Creates a simulated device of the type your system is configured for
    //
    // Since 4.3
    virtual ::grpc::Status add_simulated_device(::grpc::ClientContext* context, const ::minknow_api::manager::AddSimulatedDeviceRequest& request, ::minknow_api::manager::AddSimulatedDeviceResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::AddSimulatedDeviceResponse>> Asyncadd_simulated_device(::grpc::ClientContext* context, const ::minknow_api::manager::AddSimulatedDeviceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::AddSimulatedDeviceResponse>>(Asyncadd_simulated_deviceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::AddSimulatedDeviceResponse>> PrepareAsyncadd_simulated_device(::grpc::ClientContext* context, const ::minknow_api::manager::AddSimulatedDeviceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::AddSimulatedDeviceResponse>>(PrepareAsyncadd_simulated_deviceRaw(context, request, cq));
    }
    // Removes a simulated device
    //
    // Since 4.3
    virtual ::grpc::Status remove_simulated_device(::grpc::ClientContext* context, const ::minknow_api::manager::RemoveSimulatedDeviceRequest& request, ::minknow_api::manager::RemoveSimulatedDeviceResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::RemoveSimulatedDeviceResponse>> Asyncremove_simulated_device(::grpc::ClientContext* context, const ::minknow_api::manager::RemoveSimulatedDeviceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::RemoveSimulatedDeviceResponse>>(Asyncremove_simulated_deviceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::RemoveSimulatedDeviceResponse>> PrepareAsyncremove_simulated_device(::grpc::ClientContext* context, const ::minknow_api::manager::RemoveSimulatedDeviceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::RemoveSimulatedDeviceResponse>>(PrepareAsyncremove_simulated_deviceRaw(context, request, cq));
    }
    // Get the path for the local authentication token.
    //
    // This RPC is only useful when connecting to MinKNOW from the same computer that MinKNOW is
    // running on (ie: connecting to "localhost"). If this file exists (which it should if MinKNOW's
    // guest mode is not completely disabled), it contains a description of a token that can be used
    // to connect to MinKNOW. This is most useful when MinKNOW's guest mode is set to "local_only",
    // as it certifies that the client is connecting from the local machine. If the guest mode is
    // set to "enabled", no token is required to connect.
    //
    // The contents of the file is a json object with two fields, "token" and "expires". "token" is
    // the string that can be passed in a "local-auth" gRPC authentication metadata field, while
    // "expires" gives the time the token will expire (in RFC3339 format). Note that a new token
    // will be written out shortly before this time (and, in fact, the token will be accepted a
    // short time after).
    //
    //
    // An example token file is::
    //
    //  {
    //    "token": "30fe5214-a7c5-4cb3-b521-b1ec8a49592a",
    //    "expires": "2020-12-18T14:26:12.021934+00:00"
    //  }
    //
    // To connect before 14:26:12.021934 on 2020-12-18, a client would set the metadata field
    // "local-auth" to "30fe5214-a7c5-4cb3-b521-b1ec8a49592a". At around 14:26:12, the client should
    // re-read the file and update the metadata field with the newly-read value.
    //
    // This RPC can be called without providing any authentication tokens.
    //
    // Since 4.2
    virtual ::grpc::Status local_authentication_token_path(::grpc::ClientContext* context, const ::minknow_api::manager::LocalAuthenticationTokenPathRequest& request, ::minknow_api::manager::LocalAuthenticationTokenPathResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::LocalAuthenticationTokenPathResponse>> Asynclocal_authentication_token_path(::grpc::ClientContext* context, const ::minknow_api::manager::LocalAuthenticationTokenPathRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::LocalAuthenticationTokenPathResponse>>(Asynclocal_authentication_token_pathRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::LocalAuthenticationTokenPathResponse>> PrepareAsynclocal_authentication_token_path(::grpc::ClientContext* context, const ::minknow_api::manager::LocalAuthenticationTokenPathRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::LocalAuthenticationTokenPathResponse>>(PrepareAsynclocal_authentication_token_pathRaw(context, request, cq));
    }
    // Query information about a reference file.
    //
    // Reference file types are picked up by extension:
    // for fasta: .fasta, .fna, .ffn, .faa, .frn
    // for mmi: .mmi
    //
    // Since 4.4
    virtual ::grpc::Status get_alignment_reference_information(::grpc::ClientContext* context, const ::minknow_api::manager::GetAlignmentReferenceInformationRequest& request, ::minknow_api::manager::GetAlignmentReferenceInformationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetAlignmentReferenceInformationResponse>> Asyncget_alignment_reference_information(::grpc::ClientContext* context, const ::minknow_api::manager::GetAlignmentReferenceInformationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetAlignmentReferenceInformationResponse>>(Asyncget_alignment_reference_informationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetAlignmentReferenceInformationResponse>> PrepareAsyncget_alignment_reference_information(::grpc::ClientContext* context, const ::minknow_api::manager::GetAlignmentReferenceInformationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetAlignmentReferenceInformationResponse>>(PrepareAsyncget_alignment_reference_informationRaw(context, request, cq));
    }
    // Get the device code/key for association.
    //
    // This can be used to either get the code that the user must enter into the customer support
    // portal to associate the device with their account, or the key used for online association.
    //
    // Errors:
    //     INVALID_ARGUMENT: The requested flow cell position does not exist.
    //
    // Since 4.4
    virtual ::grpc::Status association_device_code(::grpc::ClientContext* context, const ::minknow_api::manager::AssociationDeviceCodeRequest& request, ::minknow_api::manager::AssociationDeviceCodeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::AssociationDeviceCodeResponse>> Asyncassociation_device_code(::grpc::ClientContext* context, const ::minknow_api::manager::AssociationDeviceCodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::AssociationDeviceCodeResponse>>(Asyncassociation_device_codeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::AssociationDeviceCodeResponse>> PrepareAsyncassociation_device_code(::grpc::ClientContext* context, const ::minknow_api::manager::AssociationDeviceCodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::AssociationDeviceCodeResponse>>(PrepareAsyncassociation_device_codeRaw(context, request, cq));
    }
    // Apply the unlock code for offline association.
    //
    // This is the code that the user receives from the customer support portal after entering the
    // device code for this device (see `offline_association_device_code`).
    //
    // This is only required if either `describe_host` indicates that the device as a whole needs
    // association, or `flow_cell_positions` indicates that a particular positions needs it.
    //
    // Errors:
    //     INVALID_ARGUMENT: The requested flow cell position does not exist, or no unlock code
    //         was provided.
    //
    // Note that you will need to check the result to see if the association was successful. Calling
    // this on an already-associated device with a valid unlock code will succeed, but have no
    // effect.
    //
    // Since 4.4
    virtual ::grpc::Status apply_offline_association_unlock_code(::grpc::ClientContext* context, const ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeRequest& request, ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeResponse>> Asyncapply_offline_association_unlock_code(::grpc::ClientContext* context, const ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeResponse>>(Asyncapply_offline_association_unlock_codeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeResponse>> PrepareAsyncapply_offline_association_unlock_code(::grpc::ClientContext* context, const ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeResponse>>(PrepareAsyncapply_offline_association_unlock_codeRaw(context, request, cq));
    }
    // List all developer API tokens.
    //
    // List all developer tokens, and their expiry times. Note this does not return the actual token value - this is only available at creation time.
    //
    // Since 4.4
    virtual ::grpc::Status list_developer_api_tokens(::grpc::ClientContext* context, const ::minknow_api::manager::ListDeveloperApiTokensRequest& request, ::minknow_api::manager::ListDeveloperApiTokensResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::ListDeveloperApiTokensResponse>> Asynclist_developer_api_tokens(::grpc::ClientContext* context, const ::minknow_api::manager::ListDeveloperApiTokensRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::ListDeveloperApiTokensResponse>>(Asynclist_developer_api_tokensRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::ListDeveloperApiTokensResponse>> PrepareAsynclist_developer_api_tokens(::grpc::ClientContext* context, const ::minknow_api::manager::ListDeveloperApiTokensRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::ListDeveloperApiTokensResponse>>(PrepareAsynclist_developer_api_tokensRaw(context, request, cq));
    }
    // Create a new developer API token, with a user facing name, and optional expiry time.
    //
    // The response contains the requested token, which will be valid until provided expiry time.
    //
    // The token cannot be obtained a second time, once the CreateDeveloperApiTokenResponse is destroyed.
    //
    // Since 4.4
    virtual ::grpc::Status create_developer_api_token(::grpc::ClientContext* context, const ::minknow_api::manager::CreateDeveloperApiTokenRequest& request, ::minknow_api::manager::CreateDeveloperApiTokenResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::CreateDeveloperApiTokenResponse>> Asynccreate_developer_api_token(::grpc::ClientContext* context, const ::minknow_api::manager::CreateDeveloperApiTokenRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::CreateDeveloperApiTokenResponse>>(Asynccreate_developer_api_tokenRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::CreateDeveloperApiTokenResponse>> PrepareAsynccreate_developer_api_token(::grpc::ClientContext* context, const ::minknow_api::manager::CreateDeveloperApiTokenRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::CreateDeveloperApiTokenResponse>>(PrepareAsynccreate_developer_api_tokenRaw(context, request, cq));
    }
    // Remove a developer api token.
    //
    // Since 4.4
    virtual ::grpc::Status revoke_developer_api_token(::grpc::ClientContext* context, const ::minknow_api::manager::RevokeDeveloperApiTokenRequest& request, ::minknow_api::manager::RevokeDeveloperApiTokensResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::RevokeDeveloperApiTokensResponse>> Asyncrevoke_developer_api_token(::grpc::ClientContext* context, const ::minknow_api::manager::RevokeDeveloperApiTokenRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::RevokeDeveloperApiTokensResponse>>(Asyncrevoke_developer_api_tokenRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::RevokeDeveloperApiTokensResponse>> PrepareAsyncrevoke_developer_api_token(::grpc::ClientContext* context, const ::minknow_api::manager::RevokeDeveloperApiTokenRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::RevokeDeveloperApiTokensResponse>>(PrepareAsyncrevoke_developer_api_tokenRaw(context, request, cq));
    }
    // Find protocols which can be run based on the current device + flowcell.
    //
    // Throws an error if there is no flow cell connected.
    //
    // Since 4.5
    virtual ::grpc::Status find_protocols(::grpc::ClientContext* context, const ::minknow_api::manager::FindProtocolsRequest& request, ::minknow_api::manager::FindProtocolsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::FindProtocolsResponse>> Asyncfind_protocols(::grpc::ClientContext* context, const ::minknow_api::manager::FindProtocolsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::FindProtocolsResponse>>(Asyncfind_protocolsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::FindProtocolsResponse>> PrepareAsyncfind_protocols(::grpc::ClientContext* context, const ::minknow_api::manager::FindProtocolsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::FindProtocolsResponse>>(PrepareAsyncfind_protocolsRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // Get information about the machine running MinKNOW.
      //
      // This RPC can be called without providing any authentication tokens.
      //
      // Since 3.6
      virtual void describe_host(::grpc::ClientContext* context, const ::minknow_api::manager::DescribeHostRequest* request, ::minknow_api::manager::DescribeHostResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void describe_host(::grpc::ClientContext* context, const ::minknow_api::manager::DescribeHostRequest* request, ::minknow_api::manager::DescribeHostResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // List all known positions where flow cells can be inserted.
      //
      // Provides a snapshot of places where users can insert flow cells. It has a streamed response
      // in case there are too many positions to fit into a single response, but normally there should
      // only be a single response.
      //
      // This RPC can be called without providing any authentication tokens.
      //
      // Since 3.6
      virtual void flow_cell_positions(::grpc::ClientContext* context, const ::minknow_api::manager::FlowCellPositionsRequest* request, ::grpc::ClientReadReactor< ::minknow_api::manager::FlowCellPositionsResponse>* reactor) = 0;
      // Watch for changes in flow cell position availability and state.
      //
      // This is like flow_cell_positions, but updates are streamed as positions come and go (eg:
      // MinIONs being plugged or unplugged), or their status otherwise changes.
      //
      // This RPC can be called without providing any authentication tokens.
      //
      // Since 3.6
      virtual void watch_flow_cell_positions(::grpc::ClientContext* context, const ::minknow_api::manager::WatchFlowCellPositionsRequest* request, ::grpc::ClientReadReactor< ::minknow_api::manager::WatchFlowCellPositionsResponse>* reactor) = 0;
      // Reset a flow cell position.
      //
      // If the hardware is in an error state or has been removed and the software is running, it will
      // stop the software (causing the position to be forgotten if the hardware was removed).
      //
      // If the hardware is not in an error state
      virtual void reset_position(::grpc::ClientContext* context, const ::minknow_api::manager::ResetPositionRequest* request, ::minknow_api::manager::ResetPositionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void reset_position(::grpc::ClientContext* context, const ::minknow_api::manager::ResetPositionRequest* request, ::minknow_api::manager::ResetPositionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Get the connection information for the basecaller API.
      //
      // This is the service that implements the minknow_api.basecaller interface for basecalling
      // reads files.
      //
      // This RPC can be called without providing any authentication tokens.
      //
      // Since 3.5
      virtual void basecaller_api(::grpc::ClientContext* context, const ::minknow_api::manager::BasecallerApiRequest* request, ::minknow_api::manager::BasecallerApiResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void basecaller_api(::grpc::ClientContext* context, const ::minknow_api::manager::BasecallerApiRequest* request, ::minknow_api::manager::BasecallerApiResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Get information about Guppy, including the port to connect to it on.
      //
      // Since 4.1
      virtual void get_guppy_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetGuppyInfoRequest* request, ::minknow_api::manager::GetGuppyInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_guppy_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetGuppyInfoRequest* request, ::minknow_api::manager::GetGuppyInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Current version information includes:
      // - Minknow version
      // - Protocols version (i.e. Bream-4 version)
      // - Configuration version (i.e. Wanda version)
      // - Distribution version
      // - Guppy version
      //
      // This RPC can be called without providing any authentication tokens.
      //
      // See also: instance.get_version_info which provides some similar information on a per instance basis.
      // Since 3.3
      virtual void get_version_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetVersionInfoRequest* request, ::minknow_api::manager::GetVersionInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_version_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetVersionInfoRequest* request, ::minknow_api::manager::GetVersionInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Returns all the files that are within the protocol output dir specified in the user_conf - or a descendant of that directory
      // if `path` is supplied in the request.
      //
      // INVALID_ARGUMENT will be returned if the `path` argument in the request is not a descendant of the protocol output directory
      //
      // NOT_FOUND will be returned if the path does not exist. 'The path' being either the protocol output directory if the `path` argument is not specified
      // or a valid `path` argument is specified but does not exist.
      //
      // Since 3.5
      virtual void list_protocol_output_dir_files(::grpc::ClientContext* context, const ::minknow_api::manager::ListProtocolOutputDirFilesRequest* request, ::grpc::ClientReadReactor< ::minknow_api::manager::ListProtocolOutputDirFilesResponse>* reactor) = 0;
      // Create a directory within the protocol output directory tree.
      //
      // Errors:
      //     INVALID_ARGUMENT will be returned if the parent path (where the directory is requested to
      //         be created) is not within the protocol output directory, or if invalid characters are
      //         in the requested directory name.
      //
      //     FAILED_PRECONDITION will be returned if the parent path is not a directory.
      //
      //     NOT_FOUND will be returned if the parent path does not exist.
      //
      //     ALREADY_EXISTS will be returned if the directory exists and is not a directory (if the
      //         directory already exists, this is treated as success).
      //
      // The possible valid parent paths can be determined using list_protocol_output_dir_files().
      //
      // Since 3.6
      virtual void create_directory(::grpc::ClientContext* context, const ::minknow_api::manager::CreateDirectoryRequest* request, ::minknow_api::manager::CreateDirectoryResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void create_directory(::grpc::ClientContext* context, const ::minknow_api::manager::CreateDirectoryRequest* request, ::minknow_api::manager::CreateDirectoryResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Returns information about the amount of disk space available, how much
      // space is needed to stop an experiment cleanly and if MinKNOW thinks
      // that the free disk-space is approaching or past this limit
      //
      // Since 3.7
      virtual void get_disk_space_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetDiskSpaceInfoRequest* request, ::minknow_api::manager::GetDiskSpaceInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_disk_space_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetDiskSpaceInfoRequest* request, ::minknow_api::manager::GetDiskSpaceInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // As with `instance.get_default_output_directories`, this will return the
      // paths that are defined in the config used when an instance of minknow
      // is started.
      //
      // Since 4.3
      virtual void get_default_output_directories(::grpc::ClientContext* context, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest* request, ::minknow_api::instance::OutputDirectories* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_default_output_directories(::grpc::ClientContext* context, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest* request, ::minknow_api::instance::OutputDirectories* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Stream information about the amount of disk space available, how quickly
      // it is being used, how much space is needed to stop an experiment cleanly
      // and if MinKNOW thinks that the free disk-space is approaching or past
      // this limit
      //
      // Since 4.0
      virtual void stream_disk_space_info(::grpc::ClientContext* context, const ::minknow_api::manager::StreamDiskSpaceInfoRequest* request, ::grpc::ClientReadReactor< ::minknow_api::manager::GetDiskSpaceInfoResponse>* reactor) = 0;
      // Get info about all available barcoding kits
      //
      // Since 4.1
      virtual void get_barcode_kit_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetBarcodeKitInfoRequest* request, ::minknow_api::manager::GetBarcodeKitInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_barcode_kit_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetBarcodeKitInfoRequest* request, ::minknow_api::manager::GetBarcodeKitInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Get info about all available lamp kits
      //
      // Since 4.1
      virtual void get_lamp_kit_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetLampKitInfoRequest* request, ::minknow_api::manager::GetLampKitInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_lamp_kit_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetLampKitInfoRequest* request, ::minknow_api::manager::GetLampKitInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // List all barcode keys associated with the specified barcoding kits
      //
      // Since 4.1
      virtual void get_barcode_keys(::grpc::ClientContext* context, const ::minknow_api::manager::GetBarcodeKeysRequest* request, ::minknow_api::manager::GetBarcodeKeysResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_barcode_keys(::grpc::ClientContext* context, const ::minknow_api::manager::GetBarcodeKeysRequest* request, ::minknow_api::manager::GetBarcodeKeysResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // List all known types of flow cell.
      //
      // The primary purpose of this RPC is to provide a list of flow cell types for a user to select
      // from (although most flow cells are capable of telling MinKNOW their product code, making user
      // selection unnecessary).
      //
      // A secondary benefit of this call is it allows extra information about flow cell types to be
      // given.
      //
      // Since 4.1
      virtual void get_flow_cell_types(::grpc::ClientContext* context, const ::minknow_api::manager::GetFlowCellTypesRequest* request, ::minknow_api::manager::GetFlowCellTypesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_flow_cell_types(::grpc::ClientContext* context, const ::minknow_api::manager::GetFlowCellTypesRequest* request, ::minknow_api::manager::GetFlowCellTypesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // List all known sequencing kits.
      //
      // The intention is to provide a list of sequencing kits for a user to select from, plus extra
      // information that can be used to filter that list.
      //
      // Since 4.1
      virtual void get_sequencing_kits(::grpc::ClientContext* context, const ::minknow_api::manager::GetSequencingKitsRequest* request, ::minknow_api::manager::GetSequencingKitsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_sequencing_kits(::grpc::ClientContext* context, const ::minknow_api::manager::GetSequencingKitsRequest* request, ::minknow_api::manager::GetSequencingKitsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Creates a simulated device of the type your system is configured for
      //
      // Since 4.3
      virtual void add_simulated_device(::grpc::ClientContext* context, const ::minknow_api::manager::AddSimulatedDeviceRequest* request, ::minknow_api::manager::AddSimulatedDeviceResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void add_simulated_device(::grpc::ClientContext* context, const ::minknow_api::manager::AddSimulatedDeviceRequest* request, ::minknow_api::manager::AddSimulatedDeviceResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Removes a simulated device
      //
      // Since 4.3
      virtual void remove_simulated_device(::grpc::ClientContext* context, const ::minknow_api::manager::RemoveSimulatedDeviceRequest* request, ::minknow_api::manager::RemoveSimulatedDeviceResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void remove_simulated_device(::grpc::ClientContext* context, const ::minknow_api::manager::RemoveSimulatedDeviceRequest* request, ::minknow_api::manager::RemoveSimulatedDeviceResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Get the path for the local authentication token.
      //
      // This RPC is only useful when connecting to MinKNOW from the same computer that MinKNOW is
      // running on (ie: connecting to "localhost"). If this file exists (which it should if MinKNOW's
      // guest mode is not completely disabled), it contains a description of a token that can be used
      // to connect to MinKNOW. This is most useful when MinKNOW's guest mode is set to "local_only",
      // as it certifies that the client is connecting from the local machine. If the guest mode is
      // set to "enabled", no token is required to connect.
      //
      // The contents of the file is a json object with two fields, "token" and "expires". "token" is
      // the string that can be passed in a "local-auth" gRPC authentication metadata field, while
      // "expires" gives the time the token will expire (in RFC3339 format). Note that a new token
      // will be written out shortly before this time (and, in fact, the token will be accepted a
      // short time after).
      //
      //
      // An example token file is::
      //
      //  {
      //    "token": "30fe5214-a7c5-4cb3-b521-b1ec8a49592a",
      //    "expires": "2020-12-18T14:26:12.021934+00:00"
      //  }
      //
      // To connect before 14:26:12.021934 on 2020-12-18, a client would set the metadata field
      // "local-auth" to "30fe5214-a7c5-4cb3-b521-b1ec8a49592a". At around 14:26:12, the client should
      // re-read the file and update the metadata field with the newly-read value.
      //
      // This RPC can be called without providing any authentication tokens.
      //
      // Since 4.2
      virtual void local_authentication_token_path(::grpc::ClientContext* context, const ::minknow_api::manager::LocalAuthenticationTokenPathRequest* request, ::minknow_api::manager::LocalAuthenticationTokenPathResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void local_authentication_token_path(::grpc::ClientContext* context, const ::minknow_api::manager::LocalAuthenticationTokenPathRequest* request, ::minknow_api::manager::LocalAuthenticationTokenPathResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Query information about a reference file.
      //
      // Reference file types are picked up by extension:
      // for fasta: .fasta, .fna, .ffn, .faa, .frn
      // for mmi: .mmi
      //
      // Since 4.4
      virtual void get_alignment_reference_information(::grpc::ClientContext* context, const ::minknow_api::manager::GetAlignmentReferenceInformationRequest* request, ::minknow_api::manager::GetAlignmentReferenceInformationResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_alignment_reference_information(::grpc::ClientContext* context, const ::minknow_api::manager::GetAlignmentReferenceInformationRequest* request, ::minknow_api::manager::GetAlignmentReferenceInformationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Get the device code/key for association.
      //
      // This can be used to either get the code that the user must enter into the customer support
      // portal to associate the device with their account, or the key used for online association.
      //
      // Errors:
      //     INVALID_ARGUMENT: The requested flow cell position does not exist.
      //
      // Since 4.4
      virtual void association_device_code(::grpc::ClientContext* context, const ::minknow_api::manager::AssociationDeviceCodeRequest* request, ::minknow_api::manager::AssociationDeviceCodeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void association_device_code(::grpc::ClientContext* context, const ::minknow_api::manager::AssociationDeviceCodeRequest* request, ::minknow_api::manager::AssociationDeviceCodeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Apply the unlock code for offline association.
      //
      // This is the code that the user receives from the customer support portal after entering the
      // device code for this device (see `offline_association_device_code`).
      //
      // This is only required if either `describe_host` indicates that the device as a whole needs
      // association, or `flow_cell_positions` indicates that a particular positions needs it.
      //
      // Errors:
      //     INVALID_ARGUMENT: The requested flow cell position does not exist, or no unlock code
      //         was provided.
      //
      // Note that you will need to check the result to see if the association was successful. Calling
      // this on an already-associated device with a valid unlock code will succeed, but have no
      // effect.
      //
      // Since 4.4
      virtual void apply_offline_association_unlock_code(::grpc::ClientContext* context, const ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeRequest* request, ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void apply_offline_association_unlock_code(::grpc::ClientContext* context, const ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeRequest* request, ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // List all developer API tokens.
      //
      // List all developer tokens, and their expiry times. Note this does not return the actual token value - this is only available at creation time.
      //
      // Since 4.4
      virtual void list_developer_api_tokens(::grpc::ClientContext* context, const ::minknow_api::manager::ListDeveloperApiTokensRequest* request, ::minknow_api::manager::ListDeveloperApiTokensResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void list_developer_api_tokens(::grpc::ClientContext* context, const ::minknow_api::manager::ListDeveloperApiTokensRequest* request, ::minknow_api::manager::ListDeveloperApiTokensResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Create a new developer API token, with a user facing name, and optional expiry time.
      //
      // The response contains the requested token, which will be valid until provided expiry time.
      //
      // The token cannot be obtained a second time, once the CreateDeveloperApiTokenResponse is destroyed.
      //
      // Since 4.4
      virtual void create_developer_api_token(::grpc::ClientContext* context, const ::minknow_api::manager::CreateDeveloperApiTokenRequest* request, ::minknow_api::manager::CreateDeveloperApiTokenResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void create_developer_api_token(::grpc::ClientContext* context, const ::minknow_api::manager::CreateDeveloperApiTokenRequest* request, ::minknow_api::manager::CreateDeveloperApiTokenResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Remove a developer api token.
      //
      // Since 4.4
      virtual void revoke_developer_api_token(::grpc::ClientContext* context, const ::minknow_api::manager::RevokeDeveloperApiTokenRequest* request, ::minknow_api::manager::RevokeDeveloperApiTokensResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void revoke_developer_api_token(::grpc::ClientContext* context, const ::minknow_api::manager::RevokeDeveloperApiTokenRequest* request, ::minknow_api::manager::RevokeDeveloperApiTokensResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Find protocols which can be run based on the current device + flowcell.
      //
      // Throws an error if there is no flow cell connected.
      //
      // Since 4.5
      virtual void find_protocols(::grpc::ClientContext* context, const ::minknow_api::manager::FindProtocolsRequest* request, ::minknow_api::manager::FindProtocolsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void find_protocols(::grpc::ClientContext* context, const ::minknow_api::manager::FindProtocolsRequest* request, ::minknow_api::manager::FindProtocolsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::DescribeHostResponse>* Asyncdescribe_hostRaw(::grpc::ClientContext* context, const ::minknow_api::manager::DescribeHostRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::DescribeHostResponse>* PrepareAsyncdescribe_hostRaw(::grpc::ClientContext* context, const ::minknow_api::manager::DescribeHostRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::minknow_api::manager::FlowCellPositionsResponse>* flow_cell_positionsRaw(::grpc::ClientContext* context, const ::minknow_api::manager::FlowCellPositionsRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::minknow_api::manager::FlowCellPositionsResponse>* Asyncflow_cell_positionsRaw(::grpc::ClientContext* context, const ::minknow_api::manager::FlowCellPositionsRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::minknow_api::manager::FlowCellPositionsResponse>* PrepareAsyncflow_cell_positionsRaw(::grpc::ClientContext* context, const ::minknow_api::manager::FlowCellPositionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::minknow_api::manager::WatchFlowCellPositionsResponse>* watch_flow_cell_positionsRaw(::grpc::ClientContext* context, const ::minknow_api::manager::WatchFlowCellPositionsRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::minknow_api::manager::WatchFlowCellPositionsResponse>* Asyncwatch_flow_cell_positionsRaw(::grpc::ClientContext* context, const ::minknow_api::manager::WatchFlowCellPositionsRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::minknow_api::manager::WatchFlowCellPositionsResponse>* PrepareAsyncwatch_flow_cell_positionsRaw(::grpc::ClientContext* context, const ::minknow_api::manager::WatchFlowCellPositionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::ResetPositionResponse>* Asyncreset_positionRaw(::grpc::ClientContext* context, const ::minknow_api::manager::ResetPositionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::ResetPositionResponse>* PrepareAsyncreset_positionRaw(::grpc::ClientContext* context, const ::minknow_api::manager::ResetPositionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::BasecallerApiResponse>* Asyncbasecaller_apiRaw(::grpc::ClientContext* context, const ::minknow_api::manager::BasecallerApiRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::BasecallerApiResponse>* PrepareAsyncbasecaller_apiRaw(::grpc::ClientContext* context, const ::minknow_api::manager::BasecallerApiRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetGuppyInfoResponse>* Asyncget_guppy_infoRaw(::grpc::ClientContext* context, const ::minknow_api::manager::GetGuppyInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetGuppyInfoResponse>* PrepareAsyncget_guppy_infoRaw(::grpc::ClientContext* context, const ::minknow_api::manager::GetGuppyInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetVersionInfoResponse>* Asyncget_version_infoRaw(::grpc::ClientContext* context, const ::minknow_api::manager::GetVersionInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetVersionInfoResponse>* PrepareAsyncget_version_infoRaw(::grpc::ClientContext* context, const ::minknow_api::manager::GetVersionInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::minknow_api::manager::ListProtocolOutputDirFilesResponse>* list_protocol_output_dir_filesRaw(::grpc::ClientContext* context, const ::minknow_api::manager::ListProtocolOutputDirFilesRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::minknow_api::manager::ListProtocolOutputDirFilesResponse>* Asynclist_protocol_output_dir_filesRaw(::grpc::ClientContext* context, const ::minknow_api::manager::ListProtocolOutputDirFilesRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::minknow_api::manager::ListProtocolOutputDirFilesResponse>* PrepareAsynclist_protocol_output_dir_filesRaw(::grpc::ClientContext* context, const ::minknow_api::manager::ListProtocolOutputDirFilesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::CreateDirectoryResponse>* Asynccreate_directoryRaw(::grpc::ClientContext* context, const ::minknow_api::manager::CreateDirectoryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::CreateDirectoryResponse>* PrepareAsynccreate_directoryRaw(::grpc::ClientContext* context, const ::minknow_api::manager::CreateDirectoryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetDiskSpaceInfoResponse>* Asyncget_disk_space_infoRaw(::grpc::ClientContext* context, const ::minknow_api::manager::GetDiskSpaceInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetDiskSpaceInfoResponse>* PrepareAsyncget_disk_space_infoRaw(::grpc::ClientContext* context, const ::minknow_api::manager::GetDiskSpaceInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::OutputDirectories>* Asyncget_default_output_directoriesRaw(::grpc::ClientContext* context, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::OutputDirectories>* PrepareAsyncget_default_output_directoriesRaw(::grpc::ClientContext* context, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::minknow_api::manager::GetDiskSpaceInfoResponse>* stream_disk_space_infoRaw(::grpc::ClientContext* context, const ::minknow_api::manager::StreamDiskSpaceInfoRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::minknow_api::manager::GetDiskSpaceInfoResponse>* Asyncstream_disk_space_infoRaw(::grpc::ClientContext* context, const ::minknow_api::manager::StreamDiskSpaceInfoRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::minknow_api::manager::GetDiskSpaceInfoResponse>* PrepareAsyncstream_disk_space_infoRaw(::grpc::ClientContext* context, const ::minknow_api::manager::StreamDiskSpaceInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetBarcodeKitInfoResponse>* Asyncget_barcode_kit_infoRaw(::grpc::ClientContext* context, const ::minknow_api::manager::GetBarcodeKitInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetBarcodeKitInfoResponse>* PrepareAsyncget_barcode_kit_infoRaw(::grpc::ClientContext* context, const ::minknow_api::manager::GetBarcodeKitInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetLampKitInfoResponse>* Asyncget_lamp_kit_infoRaw(::grpc::ClientContext* context, const ::minknow_api::manager::GetLampKitInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetLampKitInfoResponse>* PrepareAsyncget_lamp_kit_infoRaw(::grpc::ClientContext* context, const ::minknow_api::manager::GetLampKitInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetBarcodeKeysResponse>* Asyncget_barcode_keysRaw(::grpc::ClientContext* context, const ::minknow_api::manager::GetBarcodeKeysRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetBarcodeKeysResponse>* PrepareAsyncget_barcode_keysRaw(::grpc::ClientContext* context, const ::minknow_api::manager::GetBarcodeKeysRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetFlowCellTypesResponse>* Asyncget_flow_cell_typesRaw(::grpc::ClientContext* context, const ::minknow_api::manager::GetFlowCellTypesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetFlowCellTypesResponse>* PrepareAsyncget_flow_cell_typesRaw(::grpc::ClientContext* context, const ::minknow_api::manager::GetFlowCellTypesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetSequencingKitsResponse>* Asyncget_sequencing_kitsRaw(::grpc::ClientContext* context, const ::minknow_api::manager::GetSequencingKitsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetSequencingKitsResponse>* PrepareAsyncget_sequencing_kitsRaw(::grpc::ClientContext* context, const ::minknow_api::manager::GetSequencingKitsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::AddSimulatedDeviceResponse>* Asyncadd_simulated_deviceRaw(::grpc::ClientContext* context, const ::minknow_api::manager::AddSimulatedDeviceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::AddSimulatedDeviceResponse>* PrepareAsyncadd_simulated_deviceRaw(::grpc::ClientContext* context, const ::minknow_api::manager::AddSimulatedDeviceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::RemoveSimulatedDeviceResponse>* Asyncremove_simulated_deviceRaw(::grpc::ClientContext* context, const ::minknow_api::manager::RemoveSimulatedDeviceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::RemoveSimulatedDeviceResponse>* PrepareAsyncremove_simulated_deviceRaw(::grpc::ClientContext* context, const ::minknow_api::manager::RemoveSimulatedDeviceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::LocalAuthenticationTokenPathResponse>* Asynclocal_authentication_token_pathRaw(::grpc::ClientContext* context, const ::minknow_api::manager::LocalAuthenticationTokenPathRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::LocalAuthenticationTokenPathResponse>* PrepareAsynclocal_authentication_token_pathRaw(::grpc::ClientContext* context, const ::minknow_api::manager::LocalAuthenticationTokenPathRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetAlignmentReferenceInformationResponse>* Asyncget_alignment_reference_informationRaw(::grpc::ClientContext* context, const ::minknow_api::manager::GetAlignmentReferenceInformationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::GetAlignmentReferenceInformationResponse>* PrepareAsyncget_alignment_reference_informationRaw(::grpc::ClientContext* context, const ::minknow_api::manager::GetAlignmentReferenceInformationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::AssociationDeviceCodeResponse>* Asyncassociation_device_codeRaw(::grpc::ClientContext* context, const ::minknow_api::manager::AssociationDeviceCodeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::AssociationDeviceCodeResponse>* PrepareAsyncassociation_device_codeRaw(::grpc::ClientContext* context, const ::minknow_api::manager::AssociationDeviceCodeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeResponse>* Asyncapply_offline_association_unlock_codeRaw(::grpc::ClientContext* context, const ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeResponse>* PrepareAsyncapply_offline_association_unlock_codeRaw(::grpc::ClientContext* context, const ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::ListDeveloperApiTokensResponse>* Asynclist_developer_api_tokensRaw(::grpc::ClientContext* context, const ::minknow_api::manager::ListDeveloperApiTokensRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::ListDeveloperApiTokensResponse>* PrepareAsynclist_developer_api_tokensRaw(::grpc::ClientContext* context, const ::minknow_api::manager::ListDeveloperApiTokensRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::CreateDeveloperApiTokenResponse>* Asynccreate_developer_api_tokenRaw(::grpc::ClientContext* context, const ::minknow_api::manager::CreateDeveloperApiTokenRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::CreateDeveloperApiTokenResponse>* PrepareAsynccreate_developer_api_tokenRaw(::grpc::ClientContext* context, const ::minknow_api::manager::CreateDeveloperApiTokenRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::RevokeDeveloperApiTokensResponse>* Asyncrevoke_developer_api_tokenRaw(::grpc::ClientContext* context, const ::minknow_api::manager::RevokeDeveloperApiTokenRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::RevokeDeveloperApiTokensResponse>* PrepareAsyncrevoke_developer_api_tokenRaw(::grpc::ClientContext* context, const ::minknow_api::manager::RevokeDeveloperApiTokenRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::FindProtocolsResponse>* Asyncfind_protocolsRaw(::grpc::ClientContext* context, const ::minknow_api::manager::FindProtocolsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::manager::FindProtocolsResponse>* PrepareAsyncfind_protocolsRaw(::grpc::ClientContext* context, const ::minknow_api::manager::FindProtocolsRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status describe_host(::grpc::ClientContext* context, const ::minknow_api::manager::DescribeHostRequest& request, ::minknow_api::manager::DescribeHostResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::DescribeHostResponse>> Asyncdescribe_host(::grpc::ClientContext* context, const ::minknow_api::manager::DescribeHostRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::DescribeHostResponse>>(Asyncdescribe_hostRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::DescribeHostResponse>> PrepareAsyncdescribe_host(::grpc::ClientContext* context, const ::minknow_api::manager::DescribeHostRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::DescribeHostResponse>>(PrepareAsyncdescribe_hostRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::minknow_api::manager::FlowCellPositionsResponse>> flow_cell_positions(::grpc::ClientContext* context, const ::minknow_api::manager::FlowCellPositionsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::minknow_api::manager::FlowCellPositionsResponse>>(flow_cell_positionsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::manager::FlowCellPositionsResponse>> Asyncflow_cell_positions(::grpc::ClientContext* context, const ::minknow_api::manager::FlowCellPositionsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::manager::FlowCellPositionsResponse>>(Asyncflow_cell_positionsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::manager::FlowCellPositionsResponse>> PrepareAsyncflow_cell_positions(::grpc::ClientContext* context, const ::minknow_api::manager::FlowCellPositionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::manager::FlowCellPositionsResponse>>(PrepareAsyncflow_cell_positionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::minknow_api::manager::WatchFlowCellPositionsResponse>> watch_flow_cell_positions(::grpc::ClientContext* context, const ::minknow_api::manager::WatchFlowCellPositionsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::minknow_api::manager::WatchFlowCellPositionsResponse>>(watch_flow_cell_positionsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::manager::WatchFlowCellPositionsResponse>> Asyncwatch_flow_cell_positions(::grpc::ClientContext* context, const ::minknow_api::manager::WatchFlowCellPositionsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::manager::WatchFlowCellPositionsResponse>>(Asyncwatch_flow_cell_positionsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::manager::WatchFlowCellPositionsResponse>> PrepareAsyncwatch_flow_cell_positions(::grpc::ClientContext* context, const ::minknow_api::manager::WatchFlowCellPositionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::manager::WatchFlowCellPositionsResponse>>(PrepareAsyncwatch_flow_cell_positionsRaw(context, request, cq));
    }
    ::grpc::Status reset_position(::grpc::ClientContext* context, const ::minknow_api::manager::ResetPositionRequest& request, ::minknow_api::manager::ResetPositionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::ResetPositionResponse>> Asyncreset_position(::grpc::ClientContext* context, const ::minknow_api::manager::ResetPositionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::ResetPositionResponse>>(Asyncreset_positionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::ResetPositionResponse>> PrepareAsyncreset_position(::grpc::ClientContext* context, const ::minknow_api::manager::ResetPositionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::ResetPositionResponse>>(PrepareAsyncreset_positionRaw(context, request, cq));
    }
    ::grpc::Status basecaller_api(::grpc::ClientContext* context, const ::minknow_api::manager::BasecallerApiRequest& request, ::minknow_api::manager::BasecallerApiResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::BasecallerApiResponse>> Asyncbasecaller_api(::grpc::ClientContext* context, const ::minknow_api::manager::BasecallerApiRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::BasecallerApiResponse>>(Asyncbasecaller_apiRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::BasecallerApiResponse>> PrepareAsyncbasecaller_api(::grpc::ClientContext* context, const ::minknow_api::manager::BasecallerApiRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::BasecallerApiResponse>>(PrepareAsyncbasecaller_apiRaw(context, request, cq));
    }
    ::grpc::Status get_guppy_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetGuppyInfoRequest& request, ::minknow_api::manager::GetGuppyInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetGuppyInfoResponse>> Asyncget_guppy_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetGuppyInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetGuppyInfoResponse>>(Asyncget_guppy_infoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetGuppyInfoResponse>> PrepareAsyncget_guppy_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetGuppyInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetGuppyInfoResponse>>(PrepareAsyncget_guppy_infoRaw(context, request, cq));
    }
    ::grpc::Status get_version_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetVersionInfoRequest& request, ::minknow_api::manager::GetVersionInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetVersionInfoResponse>> Asyncget_version_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetVersionInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetVersionInfoResponse>>(Asyncget_version_infoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetVersionInfoResponse>> PrepareAsyncget_version_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetVersionInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetVersionInfoResponse>>(PrepareAsyncget_version_infoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::minknow_api::manager::ListProtocolOutputDirFilesResponse>> list_protocol_output_dir_files(::grpc::ClientContext* context, const ::minknow_api::manager::ListProtocolOutputDirFilesRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::minknow_api::manager::ListProtocolOutputDirFilesResponse>>(list_protocol_output_dir_filesRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::manager::ListProtocolOutputDirFilesResponse>> Asynclist_protocol_output_dir_files(::grpc::ClientContext* context, const ::minknow_api::manager::ListProtocolOutputDirFilesRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::manager::ListProtocolOutputDirFilesResponse>>(Asynclist_protocol_output_dir_filesRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::manager::ListProtocolOutputDirFilesResponse>> PrepareAsynclist_protocol_output_dir_files(::grpc::ClientContext* context, const ::minknow_api::manager::ListProtocolOutputDirFilesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::manager::ListProtocolOutputDirFilesResponse>>(PrepareAsynclist_protocol_output_dir_filesRaw(context, request, cq));
    }
    ::grpc::Status create_directory(::grpc::ClientContext* context, const ::minknow_api::manager::CreateDirectoryRequest& request, ::minknow_api::manager::CreateDirectoryResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::CreateDirectoryResponse>> Asynccreate_directory(::grpc::ClientContext* context, const ::minknow_api::manager::CreateDirectoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::CreateDirectoryResponse>>(Asynccreate_directoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::CreateDirectoryResponse>> PrepareAsynccreate_directory(::grpc::ClientContext* context, const ::minknow_api::manager::CreateDirectoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::CreateDirectoryResponse>>(PrepareAsynccreate_directoryRaw(context, request, cq));
    }
    ::grpc::Status get_disk_space_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetDiskSpaceInfoRequest& request, ::minknow_api::manager::GetDiskSpaceInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetDiskSpaceInfoResponse>> Asyncget_disk_space_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetDiskSpaceInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetDiskSpaceInfoResponse>>(Asyncget_disk_space_infoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetDiskSpaceInfoResponse>> PrepareAsyncget_disk_space_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetDiskSpaceInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetDiskSpaceInfoResponse>>(PrepareAsyncget_disk_space_infoRaw(context, request, cq));
    }
    ::grpc::Status get_default_output_directories(::grpc::ClientContext* context, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest& request, ::minknow_api::instance::OutputDirectories* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::OutputDirectories>> Asyncget_default_output_directories(::grpc::ClientContext* context, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::OutputDirectories>>(Asyncget_default_output_directoriesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::OutputDirectories>> PrepareAsyncget_default_output_directories(::grpc::ClientContext* context, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::OutputDirectories>>(PrepareAsyncget_default_output_directoriesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::minknow_api::manager::GetDiskSpaceInfoResponse>> stream_disk_space_info(::grpc::ClientContext* context, const ::minknow_api::manager::StreamDiskSpaceInfoRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::minknow_api::manager::GetDiskSpaceInfoResponse>>(stream_disk_space_infoRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::manager::GetDiskSpaceInfoResponse>> Asyncstream_disk_space_info(::grpc::ClientContext* context, const ::minknow_api::manager::StreamDiskSpaceInfoRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::manager::GetDiskSpaceInfoResponse>>(Asyncstream_disk_space_infoRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::manager::GetDiskSpaceInfoResponse>> PrepareAsyncstream_disk_space_info(::grpc::ClientContext* context, const ::minknow_api::manager::StreamDiskSpaceInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::manager::GetDiskSpaceInfoResponse>>(PrepareAsyncstream_disk_space_infoRaw(context, request, cq));
    }
    ::grpc::Status get_barcode_kit_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetBarcodeKitInfoRequest& request, ::minknow_api::manager::GetBarcodeKitInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetBarcodeKitInfoResponse>> Asyncget_barcode_kit_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetBarcodeKitInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetBarcodeKitInfoResponse>>(Asyncget_barcode_kit_infoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetBarcodeKitInfoResponse>> PrepareAsyncget_barcode_kit_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetBarcodeKitInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetBarcodeKitInfoResponse>>(PrepareAsyncget_barcode_kit_infoRaw(context, request, cq));
    }
    ::grpc::Status get_lamp_kit_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetLampKitInfoRequest& request, ::minknow_api::manager::GetLampKitInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetLampKitInfoResponse>> Asyncget_lamp_kit_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetLampKitInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetLampKitInfoResponse>>(Asyncget_lamp_kit_infoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetLampKitInfoResponse>> PrepareAsyncget_lamp_kit_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetLampKitInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetLampKitInfoResponse>>(PrepareAsyncget_lamp_kit_infoRaw(context, request, cq));
    }
    ::grpc::Status get_barcode_keys(::grpc::ClientContext* context, const ::minknow_api::manager::GetBarcodeKeysRequest& request, ::minknow_api::manager::GetBarcodeKeysResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetBarcodeKeysResponse>> Asyncget_barcode_keys(::grpc::ClientContext* context, const ::minknow_api::manager::GetBarcodeKeysRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetBarcodeKeysResponse>>(Asyncget_barcode_keysRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetBarcodeKeysResponse>> PrepareAsyncget_barcode_keys(::grpc::ClientContext* context, const ::minknow_api::manager::GetBarcodeKeysRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetBarcodeKeysResponse>>(PrepareAsyncget_barcode_keysRaw(context, request, cq));
    }
    ::grpc::Status get_flow_cell_types(::grpc::ClientContext* context, const ::minknow_api::manager::GetFlowCellTypesRequest& request, ::minknow_api::manager::GetFlowCellTypesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetFlowCellTypesResponse>> Asyncget_flow_cell_types(::grpc::ClientContext* context, const ::minknow_api::manager::GetFlowCellTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetFlowCellTypesResponse>>(Asyncget_flow_cell_typesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetFlowCellTypesResponse>> PrepareAsyncget_flow_cell_types(::grpc::ClientContext* context, const ::minknow_api::manager::GetFlowCellTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetFlowCellTypesResponse>>(PrepareAsyncget_flow_cell_typesRaw(context, request, cq));
    }
    ::grpc::Status get_sequencing_kits(::grpc::ClientContext* context, const ::minknow_api::manager::GetSequencingKitsRequest& request, ::minknow_api::manager::GetSequencingKitsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetSequencingKitsResponse>> Asyncget_sequencing_kits(::grpc::ClientContext* context, const ::minknow_api::manager::GetSequencingKitsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetSequencingKitsResponse>>(Asyncget_sequencing_kitsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetSequencingKitsResponse>> PrepareAsyncget_sequencing_kits(::grpc::ClientContext* context, const ::minknow_api::manager::GetSequencingKitsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetSequencingKitsResponse>>(PrepareAsyncget_sequencing_kitsRaw(context, request, cq));
    }
    ::grpc::Status add_simulated_device(::grpc::ClientContext* context, const ::minknow_api::manager::AddSimulatedDeviceRequest& request, ::minknow_api::manager::AddSimulatedDeviceResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::AddSimulatedDeviceResponse>> Asyncadd_simulated_device(::grpc::ClientContext* context, const ::minknow_api::manager::AddSimulatedDeviceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::AddSimulatedDeviceResponse>>(Asyncadd_simulated_deviceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::AddSimulatedDeviceResponse>> PrepareAsyncadd_simulated_device(::grpc::ClientContext* context, const ::minknow_api::manager::AddSimulatedDeviceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::AddSimulatedDeviceResponse>>(PrepareAsyncadd_simulated_deviceRaw(context, request, cq));
    }
    ::grpc::Status remove_simulated_device(::grpc::ClientContext* context, const ::minknow_api::manager::RemoveSimulatedDeviceRequest& request, ::minknow_api::manager::RemoveSimulatedDeviceResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::RemoveSimulatedDeviceResponse>> Asyncremove_simulated_device(::grpc::ClientContext* context, const ::minknow_api::manager::RemoveSimulatedDeviceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::RemoveSimulatedDeviceResponse>>(Asyncremove_simulated_deviceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::RemoveSimulatedDeviceResponse>> PrepareAsyncremove_simulated_device(::grpc::ClientContext* context, const ::minknow_api::manager::RemoveSimulatedDeviceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::RemoveSimulatedDeviceResponse>>(PrepareAsyncremove_simulated_deviceRaw(context, request, cq));
    }
    ::grpc::Status local_authentication_token_path(::grpc::ClientContext* context, const ::minknow_api::manager::LocalAuthenticationTokenPathRequest& request, ::minknow_api::manager::LocalAuthenticationTokenPathResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::LocalAuthenticationTokenPathResponse>> Asynclocal_authentication_token_path(::grpc::ClientContext* context, const ::minknow_api::manager::LocalAuthenticationTokenPathRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::LocalAuthenticationTokenPathResponse>>(Asynclocal_authentication_token_pathRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::LocalAuthenticationTokenPathResponse>> PrepareAsynclocal_authentication_token_path(::grpc::ClientContext* context, const ::minknow_api::manager::LocalAuthenticationTokenPathRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::LocalAuthenticationTokenPathResponse>>(PrepareAsynclocal_authentication_token_pathRaw(context, request, cq));
    }
    ::grpc::Status get_alignment_reference_information(::grpc::ClientContext* context, const ::minknow_api::manager::GetAlignmentReferenceInformationRequest& request, ::minknow_api::manager::GetAlignmentReferenceInformationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetAlignmentReferenceInformationResponse>> Asyncget_alignment_reference_information(::grpc::ClientContext* context, const ::minknow_api::manager::GetAlignmentReferenceInformationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetAlignmentReferenceInformationResponse>>(Asyncget_alignment_reference_informationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetAlignmentReferenceInformationResponse>> PrepareAsyncget_alignment_reference_information(::grpc::ClientContext* context, const ::minknow_api::manager::GetAlignmentReferenceInformationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetAlignmentReferenceInformationResponse>>(PrepareAsyncget_alignment_reference_informationRaw(context, request, cq));
    }
    ::grpc::Status association_device_code(::grpc::ClientContext* context, const ::minknow_api::manager::AssociationDeviceCodeRequest& request, ::minknow_api::manager::AssociationDeviceCodeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::AssociationDeviceCodeResponse>> Asyncassociation_device_code(::grpc::ClientContext* context, const ::minknow_api::manager::AssociationDeviceCodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::AssociationDeviceCodeResponse>>(Asyncassociation_device_codeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::AssociationDeviceCodeResponse>> PrepareAsyncassociation_device_code(::grpc::ClientContext* context, const ::minknow_api::manager::AssociationDeviceCodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::AssociationDeviceCodeResponse>>(PrepareAsyncassociation_device_codeRaw(context, request, cq));
    }
    ::grpc::Status apply_offline_association_unlock_code(::grpc::ClientContext* context, const ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeRequest& request, ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeResponse>> Asyncapply_offline_association_unlock_code(::grpc::ClientContext* context, const ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeResponse>>(Asyncapply_offline_association_unlock_codeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeResponse>> PrepareAsyncapply_offline_association_unlock_code(::grpc::ClientContext* context, const ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeResponse>>(PrepareAsyncapply_offline_association_unlock_codeRaw(context, request, cq));
    }
    ::grpc::Status list_developer_api_tokens(::grpc::ClientContext* context, const ::minknow_api::manager::ListDeveloperApiTokensRequest& request, ::minknow_api::manager::ListDeveloperApiTokensResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::ListDeveloperApiTokensResponse>> Asynclist_developer_api_tokens(::grpc::ClientContext* context, const ::minknow_api::manager::ListDeveloperApiTokensRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::ListDeveloperApiTokensResponse>>(Asynclist_developer_api_tokensRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::ListDeveloperApiTokensResponse>> PrepareAsynclist_developer_api_tokens(::grpc::ClientContext* context, const ::minknow_api::manager::ListDeveloperApiTokensRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::ListDeveloperApiTokensResponse>>(PrepareAsynclist_developer_api_tokensRaw(context, request, cq));
    }
    ::grpc::Status create_developer_api_token(::grpc::ClientContext* context, const ::minknow_api::manager::CreateDeveloperApiTokenRequest& request, ::minknow_api::manager::CreateDeveloperApiTokenResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::CreateDeveloperApiTokenResponse>> Asynccreate_developer_api_token(::grpc::ClientContext* context, const ::minknow_api::manager::CreateDeveloperApiTokenRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::CreateDeveloperApiTokenResponse>>(Asynccreate_developer_api_tokenRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::CreateDeveloperApiTokenResponse>> PrepareAsynccreate_developer_api_token(::grpc::ClientContext* context, const ::minknow_api::manager::CreateDeveloperApiTokenRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::CreateDeveloperApiTokenResponse>>(PrepareAsynccreate_developer_api_tokenRaw(context, request, cq));
    }
    ::grpc::Status revoke_developer_api_token(::grpc::ClientContext* context, const ::minknow_api::manager::RevokeDeveloperApiTokenRequest& request, ::minknow_api::manager::RevokeDeveloperApiTokensResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::RevokeDeveloperApiTokensResponse>> Asyncrevoke_developer_api_token(::grpc::ClientContext* context, const ::minknow_api::manager::RevokeDeveloperApiTokenRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::RevokeDeveloperApiTokensResponse>>(Asyncrevoke_developer_api_tokenRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::RevokeDeveloperApiTokensResponse>> PrepareAsyncrevoke_developer_api_token(::grpc::ClientContext* context, const ::minknow_api::manager::RevokeDeveloperApiTokenRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::RevokeDeveloperApiTokensResponse>>(PrepareAsyncrevoke_developer_api_tokenRaw(context, request, cq));
    }
    ::grpc::Status find_protocols(::grpc::ClientContext* context, const ::minknow_api::manager::FindProtocolsRequest& request, ::minknow_api::manager::FindProtocolsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::FindProtocolsResponse>> Asyncfind_protocols(::grpc::ClientContext* context, const ::minknow_api::manager::FindProtocolsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::FindProtocolsResponse>>(Asyncfind_protocolsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::FindProtocolsResponse>> PrepareAsyncfind_protocols(::grpc::ClientContext* context, const ::minknow_api::manager::FindProtocolsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::FindProtocolsResponse>>(PrepareAsyncfind_protocolsRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void describe_host(::grpc::ClientContext* context, const ::minknow_api::manager::DescribeHostRequest* request, ::minknow_api::manager::DescribeHostResponse* response, std::function<void(::grpc::Status)>) override;
      void describe_host(::grpc::ClientContext* context, const ::minknow_api::manager::DescribeHostRequest* request, ::minknow_api::manager::DescribeHostResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void flow_cell_positions(::grpc::ClientContext* context, const ::minknow_api::manager::FlowCellPositionsRequest* request, ::grpc::ClientReadReactor< ::minknow_api::manager::FlowCellPositionsResponse>* reactor) override;
      void watch_flow_cell_positions(::grpc::ClientContext* context, const ::minknow_api::manager::WatchFlowCellPositionsRequest* request, ::grpc::ClientReadReactor< ::minknow_api::manager::WatchFlowCellPositionsResponse>* reactor) override;
      void reset_position(::grpc::ClientContext* context, const ::minknow_api::manager::ResetPositionRequest* request, ::minknow_api::manager::ResetPositionResponse* response, std::function<void(::grpc::Status)>) override;
      void reset_position(::grpc::ClientContext* context, const ::minknow_api::manager::ResetPositionRequest* request, ::minknow_api::manager::ResetPositionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void basecaller_api(::grpc::ClientContext* context, const ::minknow_api::manager::BasecallerApiRequest* request, ::minknow_api::manager::BasecallerApiResponse* response, std::function<void(::grpc::Status)>) override;
      void basecaller_api(::grpc::ClientContext* context, const ::minknow_api::manager::BasecallerApiRequest* request, ::minknow_api::manager::BasecallerApiResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_guppy_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetGuppyInfoRequest* request, ::minknow_api::manager::GetGuppyInfoResponse* response, std::function<void(::grpc::Status)>) override;
      void get_guppy_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetGuppyInfoRequest* request, ::minknow_api::manager::GetGuppyInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_version_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetVersionInfoRequest* request, ::minknow_api::manager::GetVersionInfoResponse* response, std::function<void(::grpc::Status)>) override;
      void get_version_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetVersionInfoRequest* request, ::minknow_api::manager::GetVersionInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void list_protocol_output_dir_files(::grpc::ClientContext* context, const ::minknow_api::manager::ListProtocolOutputDirFilesRequest* request, ::grpc::ClientReadReactor< ::minknow_api::manager::ListProtocolOutputDirFilesResponse>* reactor) override;
      void create_directory(::grpc::ClientContext* context, const ::minknow_api::manager::CreateDirectoryRequest* request, ::minknow_api::manager::CreateDirectoryResponse* response, std::function<void(::grpc::Status)>) override;
      void create_directory(::grpc::ClientContext* context, const ::minknow_api::manager::CreateDirectoryRequest* request, ::minknow_api::manager::CreateDirectoryResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_disk_space_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetDiskSpaceInfoRequest* request, ::minknow_api::manager::GetDiskSpaceInfoResponse* response, std::function<void(::grpc::Status)>) override;
      void get_disk_space_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetDiskSpaceInfoRequest* request, ::minknow_api::manager::GetDiskSpaceInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_default_output_directories(::grpc::ClientContext* context, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest* request, ::minknow_api::instance::OutputDirectories* response, std::function<void(::grpc::Status)>) override;
      void get_default_output_directories(::grpc::ClientContext* context, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest* request, ::minknow_api::instance::OutputDirectories* response, ::grpc::ClientUnaryReactor* reactor) override;
      void stream_disk_space_info(::grpc::ClientContext* context, const ::minknow_api::manager::StreamDiskSpaceInfoRequest* request, ::grpc::ClientReadReactor< ::minknow_api::manager::GetDiskSpaceInfoResponse>* reactor) override;
      void get_barcode_kit_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetBarcodeKitInfoRequest* request, ::minknow_api::manager::GetBarcodeKitInfoResponse* response, std::function<void(::grpc::Status)>) override;
      void get_barcode_kit_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetBarcodeKitInfoRequest* request, ::minknow_api::manager::GetBarcodeKitInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_lamp_kit_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetLampKitInfoRequest* request, ::minknow_api::manager::GetLampKitInfoResponse* response, std::function<void(::grpc::Status)>) override;
      void get_lamp_kit_info(::grpc::ClientContext* context, const ::minknow_api::manager::GetLampKitInfoRequest* request, ::minknow_api::manager::GetLampKitInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_barcode_keys(::grpc::ClientContext* context, const ::minknow_api::manager::GetBarcodeKeysRequest* request, ::minknow_api::manager::GetBarcodeKeysResponse* response, std::function<void(::grpc::Status)>) override;
      void get_barcode_keys(::grpc::ClientContext* context, const ::minknow_api::manager::GetBarcodeKeysRequest* request, ::minknow_api::manager::GetBarcodeKeysResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_flow_cell_types(::grpc::ClientContext* context, const ::minknow_api::manager::GetFlowCellTypesRequest* request, ::minknow_api::manager::GetFlowCellTypesResponse* response, std::function<void(::grpc::Status)>) override;
      void get_flow_cell_types(::grpc::ClientContext* context, const ::minknow_api::manager::GetFlowCellTypesRequest* request, ::minknow_api::manager::GetFlowCellTypesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_sequencing_kits(::grpc::ClientContext* context, const ::minknow_api::manager::GetSequencingKitsRequest* request, ::minknow_api::manager::GetSequencingKitsResponse* response, std::function<void(::grpc::Status)>) override;
      void get_sequencing_kits(::grpc::ClientContext* context, const ::minknow_api::manager::GetSequencingKitsRequest* request, ::minknow_api::manager::GetSequencingKitsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void add_simulated_device(::grpc::ClientContext* context, const ::minknow_api::manager::AddSimulatedDeviceRequest* request, ::minknow_api::manager::AddSimulatedDeviceResponse* response, std::function<void(::grpc::Status)>) override;
      void add_simulated_device(::grpc::ClientContext* context, const ::minknow_api::manager::AddSimulatedDeviceRequest* request, ::minknow_api::manager::AddSimulatedDeviceResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void remove_simulated_device(::grpc::ClientContext* context, const ::minknow_api::manager::RemoveSimulatedDeviceRequest* request, ::minknow_api::manager::RemoveSimulatedDeviceResponse* response, std::function<void(::grpc::Status)>) override;
      void remove_simulated_device(::grpc::ClientContext* context, const ::minknow_api::manager::RemoveSimulatedDeviceRequest* request, ::minknow_api::manager::RemoveSimulatedDeviceResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void local_authentication_token_path(::grpc::ClientContext* context, const ::minknow_api::manager::LocalAuthenticationTokenPathRequest* request, ::minknow_api::manager::LocalAuthenticationTokenPathResponse* response, std::function<void(::grpc::Status)>) override;
      void local_authentication_token_path(::grpc::ClientContext* context, const ::minknow_api::manager::LocalAuthenticationTokenPathRequest* request, ::minknow_api::manager::LocalAuthenticationTokenPathResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_alignment_reference_information(::grpc::ClientContext* context, const ::minknow_api::manager::GetAlignmentReferenceInformationRequest* request, ::minknow_api::manager::GetAlignmentReferenceInformationResponse* response, std::function<void(::grpc::Status)>) override;
      void get_alignment_reference_information(::grpc::ClientContext* context, const ::minknow_api::manager::GetAlignmentReferenceInformationRequest* request, ::minknow_api::manager::GetAlignmentReferenceInformationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void association_device_code(::grpc::ClientContext* context, const ::minknow_api::manager::AssociationDeviceCodeRequest* request, ::minknow_api::manager::AssociationDeviceCodeResponse* response, std::function<void(::grpc::Status)>) override;
      void association_device_code(::grpc::ClientContext* context, const ::minknow_api::manager::AssociationDeviceCodeRequest* request, ::minknow_api::manager::AssociationDeviceCodeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void apply_offline_association_unlock_code(::grpc::ClientContext* context, const ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeRequest* request, ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeResponse* response, std::function<void(::grpc::Status)>) override;
      void apply_offline_association_unlock_code(::grpc::ClientContext* context, const ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeRequest* request, ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void list_developer_api_tokens(::grpc::ClientContext* context, const ::minknow_api::manager::ListDeveloperApiTokensRequest* request, ::minknow_api::manager::ListDeveloperApiTokensResponse* response, std::function<void(::grpc::Status)>) override;
      void list_developer_api_tokens(::grpc::ClientContext* context, const ::minknow_api::manager::ListDeveloperApiTokensRequest* request, ::minknow_api::manager::ListDeveloperApiTokensResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void create_developer_api_token(::grpc::ClientContext* context, const ::minknow_api::manager::CreateDeveloperApiTokenRequest* request, ::minknow_api::manager::CreateDeveloperApiTokenResponse* response, std::function<void(::grpc::Status)>) override;
      void create_developer_api_token(::grpc::ClientContext* context, const ::minknow_api::manager::CreateDeveloperApiTokenRequest* request, ::minknow_api::manager::CreateDeveloperApiTokenResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void revoke_developer_api_token(::grpc::ClientContext* context, const ::minknow_api::manager::RevokeDeveloperApiTokenRequest* request, ::minknow_api::manager::RevokeDeveloperApiTokensResponse* response, std::function<void(::grpc::Status)>) override;
      void revoke_developer_api_token(::grpc::ClientContext* context, const ::minknow_api::manager::RevokeDeveloperApiTokenRequest* request, ::minknow_api::manager::RevokeDeveloperApiTokensResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void find_protocols(::grpc::ClientContext* context, const ::minknow_api::manager::FindProtocolsRequest* request, ::minknow_api::manager::FindProtocolsResponse* response, std::function<void(::grpc::Status)>) override;
      void find_protocols(::grpc::ClientContext* context, const ::minknow_api::manager::FindProtocolsRequest* request, ::minknow_api::manager::FindProtocolsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::DescribeHostResponse>* Asyncdescribe_hostRaw(::grpc::ClientContext* context, const ::minknow_api::manager::DescribeHostRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::DescribeHostResponse>* PrepareAsyncdescribe_hostRaw(::grpc::ClientContext* context, const ::minknow_api::manager::DescribeHostRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::minknow_api::manager::FlowCellPositionsResponse>* flow_cell_positionsRaw(::grpc::ClientContext* context, const ::minknow_api::manager::FlowCellPositionsRequest& request) override;
    ::grpc::ClientAsyncReader< ::minknow_api::manager::FlowCellPositionsResponse>* Asyncflow_cell_positionsRaw(::grpc::ClientContext* context, const ::minknow_api::manager::FlowCellPositionsRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::minknow_api::manager::FlowCellPositionsResponse>* PrepareAsyncflow_cell_positionsRaw(::grpc::ClientContext* context, const ::minknow_api::manager::FlowCellPositionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::minknow_api::manager::WatchFlowCellPositionsResponse>* watch_flow_cell_positionsRaw(::grpc::ClientContext* context, const ::minknow_api::manager::WatchFlowCellPositionsRequest& request) override;
    ::grpc::ClientAsyncReader< ::minknow_api::manager::WatchFlowCellPositionsResponse>* Asyncwatch_flow_cell_positionsRaw(::grpc::ClientContext* context, const ::minknow_api::manager::WatchFlowCellPositionsRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::minknow_api::manager::WatchFlowCellPositionsResponse>* PrepareAsyncwatch_flow_cell_positionsRaw(::grpc::ClientContext* context, const ::minknow_api::manager::WatchFlowCellPositionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::ResetPositionResponse>* Asyncreset_positionRaw(::grpc::ClientContext* context, const ::minknow_api::manager::ResetPositionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::ResetPositionResponse>* PrepareAsyncreset_positionRaw(::grpc::ClientContext* context, const ::minknow_api::manager::ResetPositionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::BasecallerApiResponse>* Asyncbasecaller_apiRaw(::grpc::ClientContext* context, const ::minknow_api::manager::BasecallerApiRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::BasecallerApiResponse>* PrepareAsyncbasecaller_apiRaw(::grpc::ClientContext* context, const ::minknow_api::manager::BasecallerApiRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetGuppyInfoResponse>* Asyncget_guppy_infoRaw(::grpc::ClientContext* context, const ::minknow_api::manager::GetGuppyInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetGuppyInfoResponse>* PrepareAsyncget_guppy_infoRaw(::grpc::ClientContext* context, const ::minknow_api::manager::GetGuppyInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetVersionInfoResponse>* Asyncget_version_infoRaw(::grpc::ClientContext* context, const ::minknow_api::manager::GetVersionInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetVersionInfoResponse>* PrepareAsyncget_version_infoRaw(::grpc::ClientContext* context, const ::minknow_api::manager::GetVersionInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::minknow_api::manager::ListProtocolOutputDirFilesResponse>* list_protocol_output_dir_filesRaw(::grpc::ClientContext* context, const ::minknow_api::manager::ListProtocolOutputDirFilesRequest& request) override;
    ::grpc::ClientAsyncReader< ::minknow_api::manager::ListProtocolOutputDirFilesResponse>* Asynclist_protocol_output_dir_filesRaw(::grpc::ClientContext* context, const ::minknow_api::manager::ListProtocolOutputDirFilesRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::minknow_api::manager::ListProtocolOutputDirFilesResponse>* PrepareAsynclist_protocol_output_dir_filesRaw(::grpc::ClientContext* context, const ::minknow_api::manager::ListProtocolOutputDirFilesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::CreateDirectoryResponse>* Asynccreate_directoryRaw(::grpc::ClientContext* context, const ::minknow_api::manager::CreateDirectoryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::CreateDirectoryResponse>* PrepareAsynccreate_directoryRaw(::grpc::ClientContext* context, const ::minknow_api::manager::CreateDirectoryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetDiskSpaceInfoResponse>* Asyncget_disk_space_infoRaw(::grpc::ClientContext* context, const ::minknow_api::manager::GetDiskSpaceInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetDiskSpaceInfoResponse>* PrepareAsyncget_disk_space_infoRaw(::grpc::ClientContext* context, const ::minknow_api::manager::GetDiskSpaceInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::OutputDirectories>* Asyncget_default_output_directoriesRaw(::grpc::ClientContext* context, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::OutputDirectories>* PrepareAsyncget_default_output_directoriesRaw(::grpc::ClientContext* context, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::minknow_api::manager::GetDiskSpaceInfoResponse>* stream_disk_space_infoRaw(::grpc::ClientContext* context, const ::minknow_api::manager::StreamDiskSpaceInfoRequest& request) override;
    ::grpc::ClientAsyncReader< ::minknow_api::manager::GetDiskSpaceInfoResponse>* Asyncstream_disk_space_infoRaw(::grpc::ClientContext* context, const ::minknow_api::manager::StreamDiskSpaceInfoRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::minknow_api::manager::GetDiskSpaceInfoResponse>* PrepareAsyncstream_disk_space_infoRaw(::grpc::ClientContext* context, const ::minknow_api::manager::StreamDiskSpaceInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetBarcodeKitInfoResponse>* Asyncget_barcode_kit_infoRaw(::grpc::ClientContext* context, const ::minknow_api::manager::GetBarcodeKitInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetBarcodeKitInfoResponse>* PrepareAsyncget_barcode_kit_infoRaw(::grpc::ClientContext* context, const ::minknow_api::manager::GetBarcodeKitInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetLampKitInfoResponse>* Asyncget_lamp_kit_infoRaw(::grpc::ClientContext* context, const ::minknow_api::manager::GetLampKitInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetLampKitInfoResponse>* PrepareAsyncget_lamp_kit_infoRaw(::grpc::ClientContext* context, const ::minknow_api::manager::GetLampKitInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetBarcodeKeysResponse>* Asyncget_barcode_keysRaw(::grpc::ClientContext* context, const ::minknow_api::manager::GetBarcodeKeysRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetBarcodeKeysResponse>* PrepareAsyncget_barcode_keysRaw(::grpc::ClientContext* context, const ::minknow_api::manager::GetBarcodeKeysRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetFlowCellTypesResponse>* Asyncget_flow_cell_typesRaw(::grpc::ClientContext* context, const ::minknow_api::manager::GetFlowCellTypesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetFlowCellTypesResponse>* PrepareAsyncget_flow_cell_typesRaw(::grpc::ClientContext* context, const ::minknow_api::manager::GetFlowCellTypesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetSequencingKitsResponse>* Asyncget_sequencing_kitsRaw(::grpc::ClientContext* context, const ::minknow_api::manager::GetSequencingKitsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetSequencingKitsResponse>* PrepareAsyncget_sequencing_kitsRaw(::grpc::ClientContext* context, const ::minknow_api::manager::GetSequencingKitsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::AddSimulatedDeviceResponse>* Asyncadd_simulated_deviceRaw(::grpc::ClientContext* context, const ::minknow_api::manager::AddSimulatedDeviceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::AddSimulatedDeviceResponse>* PrepareAsyncadd_simulated_deviceRaw(::grpc::ClientContext* context, const ::minknow_api::manager::AddSimulatedDeviceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::RemoveSimulatedDeviceResponse>* Asyncremove_simulated_deviceRaw(::grpc::ClientContext* context, const ::minknow_api::manager::RemoveSimulatedDeviceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::RemoveSimulatedDeviceResponse>* PrepareAsyncremove_simulated_deviceRaw(::grpc::ClientContext* context, const ::minknow_api::manager::RemoveSimulatedDeviceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::LocalAuthenticationTokenPathResponse>* Asynclocal_authentication_token_pathRaw(::grpc::ClientContext* context, const ::minknow_api::manager::LocalAuthenticationTokenPathRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::LocalAuthenticationTokenPathResponse>* PrepareAsynclocal_authentication_token_pathRaw(::grpc::ClientContext* context, const ::minknow_api::manager::LocalAuthenticationTokenPathRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetAlignmentReferenceInformationResponse>* Asyncget_alignment_reference_informationRaw(::grpc::ClientContext* context, const ::minknow_api::manager::GetAlignmentReferenceInformationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::GetAlignmentReferenceInformationResponse>* PrepareAsyncget_alignment_reference_informationRaw(::grpc::ClientContext* context, const ::minknow_api::manager::GetAlignmentReferenceInformationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::AssociationDeviceCodeResponse>* Asyncassociation_device_codeRaw(::grpc::ClientContext* context, const ::minknow_api::manager::AssociationDeviceCodeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::AssociationDeviceCodeResponse>* PrepareAsyncassociation_device_codeRaw(::grpc::ClientContext* context, const ::minknow_api::manager::AssociationDeviceCodeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeResponse>* Asyncapply_offline_association_unlock_codeRaw(::grpc::ClientContext* context, const ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeResponse>* PrepareAsyncapply_offline_association_unlock_codeRaw(::grpc::ClientContext* context, const ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::ListDeveloperApiTokensResponse>* Asynclist_developer_api_tokensRaw(::grpc::ClientContext* context, const ::minknow_api::manager::ListDeveloperApiTokensRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::ListDeveloperApiTokensResponse>* PrepareAsynclist_developer_api_tokensRaw(::grpc::ClientContext* context, const ::minknow_api::manager::ListDeveloperApiTokensRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::CreateDeveloperApiTokenResponse>* Asynccreate_developer_api_tokenRaw(::grpc::ClientContext* context, const ::minknow_api::manager::CreateDeveloperApiTokenRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::CreateDeveloperApiTokenResponse>* PrepareAsynccreate_developer_api_tokenRaw(::grpc::ClientContext* context, const ::minknow_api::manager::CreateDeveloperApiTokenRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::RevokeDeveloperApiTokensResponse>* Asyncrevoke_developer_api_tokenRaw(::grpc::ClientContext* context, const ::minknow_api::manager::RevokeDeveloperApiTokenRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::RevokeDeveloperApiTokensResponse>* PrepareAsyncrevoke_developer_api_tokenRaw(::grpc::ClientContext* context, const ::minknow_api::manager::RevokeDeveloperApiTokenRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::FindProtocolsResponse>* Asyncfind_protocolsRaw(::grpc::ClientContext* context, const ::minknow_api::manager::FindProtocolsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::manager::FindProtocolsResponse>* PrepareAsyncfind_protocolsRaw(::grpc::ClientContext* context, const ::minknow_api::manager::FindProtocolsRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_describe_host_;
    const ::grpc::internal::RpcMethod rpcmethod_flow_cell_positions_;
    const ::grpc::internal::RpcMethod rpcmethod_watch_flow_cell_positions_;
    const ::grpc::internal::RpcMethod rpcmethod_reset_position_;
    const ::grpc::internal::RpcMethod rpcmethod_basecaller_api_;
    const ::grpc::internal::RpcMethod rpcmethod_get_guppy_info_;
    const ::grpc::internal::RpcMethod rpcmethod_get_version_info_;
    const ::grpc::internal::RpcMethod rpcmethod_list_protocol_output_dir_files_;
    const ::grpc::internal::RpcMethod rpcmethod_create_directory_;
    const ::grpc::internal::RpcMethod rpcmethod_get_disk_space_info_;
    const ::grpc::internal::RpcMethod rpcmethod_get_default_output_directories_;
    const ::grpc::internal::RpcMethod rpcmethod_stream_disk_space_info_;
    const ::grpc::internal::RpcMethod rpcmethod_get_barcode_kit_info_;
    const ::grpc::internal::RpcMethod rpcmethod_get_lamp_kit_info_;
    const ::grpc::internal::RpcMethod rpcmethod_get_barcode_keys_;
    const ::grpc::internal::RpcMethod rpcmethod_get_flow_cell_types_;
    const ::grpc::internal::RpcMethod rpcmethod_get_sequencing_kits_;
    const ::grpc::internal::RpcMethod rpcmethod_add_simulated_device_;
    const ::grpc::internal::RpcMethod rpcmethod_remove_simulated_device_;
    const ::grpc::internal::RpcMethod rpcmethod_local_authentication_token_path_;
    const ::grpc::internal::RpcMethod rpcmethod_get_alignment_reference_information_;
    const ::grpc::internal::RpcMethod rpcmethod_association_device_code_;
    const ::grpc::internal::RpcMethod rpcmethod_apply_offline_association_unlock_code_;
    const ::grpc::internal::RpcMethod rpcmethod_list_developer_api_tokens_;
    const ::grpc::internal::RpcMethod rpcmethod_create_developer_api_token_;
    const ::grpc::internal::RpcMethod rpcmethod_revoke_developer_api_token_;
    const ::grpc::internal::RpcMethod rpcmethod_find_protocols_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Get information about the machine running MinKNOW.
    //
    // This RPC can be called without providing any authentication tokens.
    //
    // Since 3.6
    virtual ::grpc::Status describe_host(::grpc::ServerContext* context, const ::minknow_api::manager::DescribeHostRequest* request, ::minknow_api::manager::DescribeHostResponse* response);
    // List all known positions where flow cells can be inserted.
    //
    // Provides a snapshot of places where users can insert flow cells. It has a streamed response
    // in case there are too many positions to fit into a single response, but normally there should
    // only be a single response.
    //
    // This RPC can be called without providing any authentication tokens.
    //
    // Since 3.6
    virtual ::grpc::Status flow_cell_positions(::grpc::ServerContext* context, const ::minknow_api::manager::FlowCellPositionsRequest* request, ::grpc::ServerWriter< ::minknow_api::manager::FlowCellPositionsResponse>* writer);
    // Watch for changes in flow cell position availability and state.
    //
    // This is like flow_cell_positions, but updates are streamed as positions come and go (eg:
    // MinIONs being plugged or unplugged), or their status otherwise changes.
    //
    // This RPC can be called without providing any authentication tokens.
    //
    // Since 3.6
    virtual ::grpc::Status watch_flow_cell_positions(::grpc::ServerContext* context, const ::minknow_api::manager::WatchFlowCellPositionsRequest* request, ::grpc::ServerWriter< ::minknow_api::manager::WatchFlowCellPositionsResponse>* writer);
    // Reset a flow cell position.
    //
    // If the hardware is in an error state or has been removed and the software is running, it will
    // stop the software (causing the position to be forgotten if the hardware was removed).
    //
    // If the hardware is not in an error state
    virtual ::grpc::Status reset_position(::grpc::ServerContext* context, const ::minknow_api::manager::ResetPositionRequest* request, ::minknow_api::manager::ResetPositionResponse* response);
    // Get the connection information for the basecaller API.
    //
    // This is the service that implements the minknow_api.basecaller interface for basecalling
    // reads files.
    //
    // This RPC can be called without providing any authentication tokens.
    //
    // Since 3.5
    virtual ::grpc::Status basecaller_api(::grpc::ServerContext* context, const ::minknow_api::manager::BasecallerApiRequest* request, ::minknow_api::manager::BasecallerApiResponse* response);
    // Get information about Guppy, including the port to connect to it on.
    //
    // Since 4.1
    virtual ::grpc::Status get_guppy_info(::grpc::ServerContext* context, const ::minknow_api::manager::GetGuppyInfoRequest* request, ::minknow_api::manager::GetGuppyInfoResponse* response);
    // Current version information includes:
    // - Minknow version
    // - Protocols version (i.e. Bream-4 version)
    // - Configuration version (i.e. Wanda version)
    // - Distribution version
    // - Guppy version
    //
    // This RPC can be called without providing any authentication tokens.
    //
    // See also: instance.get_version_info which provides some similar information on a per instance basis.
    // Since 3.3
    virtual ::grpc::Status get_version_info(::grpc::ServerContext* context, const ::minknow_api::manager::GetVersionInfoRequest* request, ::minknow_api::manager::GetVersionInfoResponse* response);
    // Returns all the files that are within the protocol output dir specified in the user_conf - or a descendant of that directory
    // if `path` is supplied in the request.
    //
    // INVALID_ARGUMENT will be returned if the `path` argument in the request is not a descendant of the protocol output directory
    //
    // NOT_FOUND will be returned if the path does not exist. 'The path' being either the protocol output directory if the `path` argument is not specified
    // or a valid `path` argument is specified but does not exist.
    //
    // Since 3.5
    virtual ::grpc::Status list_protocol_output_dir_files(::grpc::ServerContext* context, const ::minknow_api::manager::ListProtocolOutputDirFilesRequest* request, ::grpc::ServerWriter< ::minknow_api::manager::ListProtocolOutputDirFilesResponse>* writer);
    // Create a directory within the protocol output directory tree.
    //
    // Errors:
    //     INVALID_ARGUMENT will be returned if the parent path (where the directory is requested to
    //         be created) is not within the protocol output directory, or if invalid characters are
    //         in the requested directory name.
    //
    //     FAILED_PRECONDITION will be returned if the parent path is not a directory.
    //
    //     NOT_FOUND will be returned if the parent path does not exist.
    //
    //     ALREADY_EXISTS will be returned if the directory exists and is not a directory (if the
    //         directory already exists, this is treated as success).
    //
    // The possible valid parent paths can be determined using list_protocol_output_dir_files().
    //
    // Since 3.6
    virtual ::grpc::Status create_directory(::grpc::ServerContext* context, const ::minknow_api::manager::CreateDirectoryRequest* request, ::minknow_api::manager::CreateDirectoryResponse* response);
    // Returns information about the amount of disk space available, how much
    // space is needed to stop an experiment cleanly and if MinKNOW thinks
    // that the free disk-space is approaching or past this limit
    //
    // Since 3.7
    virtual ::grpc::Status get_disk_space_info(::grpc::ServerContext* context, const ::minknow_api::manager::GetDiskSpaceInfoRequest* request, ::minknow_api::manager::GetDiskSpaceInfoResponse* response);
    // As with `instance.get_default_output_directories`, this will return the
    // paths that are defined in the config used when an instance of minknow
    // is started.
    //
    // Since 4.3
    virtual ::grpc::Status get_default_output_directories(::grpc::ServerContext* context, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest* request, ::minknow_api::instance::OutputDirectories* response);
    // Stream information about the amount of disk space available, how quickly
    // it is being used, how much space is needed to stop an experiment cleanly
    // and if MinKNOW thinks that the free disk-space is approaching or past
    // this limit
    //
    // Since 4.0
    virtual ::grpc::Status stream_disk_space_info(::grpc::ServerContext* context, const ::minknow_api::manager::StreamDiskSpaceInfoRequest* request, ::grpc::ServerWriter< ::minknow_api::manager::GetDiskSpaceInfoResponse>* writer);
    // Get info about all available barcoding kits
    //
    // Since 4.1
    virtual ::grpc::Status get_barcode_kit_info(::grpc::ServerContext* context, const ::minknow_api::manager::GetBarcodeKitInfoRequest* request, ::minknow_api::manager::GetBarcodeKitInfoResponse* response);
    // Get info about all available lamp kits
    //
    // Since 4.1
    virtual ::grpc::Status get_lamp_kit_info(::grpc::ServerContext* context, const ::minknow_api::manager::GetLampKitInfoRequest* request, ::minknow_api::manager::GetLampKitInfoResponse* response);
    // List all barcode keys associated with the specified barcoding kits
    //
    // Since 4.1
    virtual ::grpc::Status get_barcode_keys(::grpc::ServerContext* context, const ::minknow_api::manager::GetBarcodeKeysRequest* request, ::minknow_api::manager::GetBarcodeKeysResponse* response);
    // List all known types of flow cell.
    //
    // The primary purpose of this RPC is to provide a list of flow cell types for a user to select
    // from (although most flow cells are capable of telling MinKNOW their product code, making user
    // selection unnecessary).
    //
    // A secondary benefit of this call is it allows extra information about flow cell types to be
    // given.
    //
    // Since 4.1
    virtual ::grpc::Status get_flow_cell_types(::grpc::ServerContext* context, const ::minknow_api::manager::GetFlowCellTypesRequest* request, ::minknow_api::manager::GetFlowCellTypesResponse* response);
    // List all known sequencing kits.
    //
    // The intention is to provide a list of sequencing kits for a user to select from, plus extra
    // information that can be used to filter that list.
    //
    // Since 4.1
    virtual ::grpc::Status get_sequencing_kits(::grpc::ServerContext* context, const ::minknow_api::manager::GetSequencingKitsRequest* request, ::minknow_api::manager::GetSequencingKitsResponse* response);
    // Creates a simulated device of the type your system is configured for
    //
    // Since 4.3
    virtual ::grpc::Status add_simulated_device(::grpc::ServerContext* context, const ::minknow_api::manager::AddSimulatedDeviceRequest* request, ::minknow_api::manager::AddSimulatedDeviceResponse* response);
    // Removes a simulated device
    //
    // Since 4.3
    virtual ::grpc::Status remove_simulated_device(::grpc::ServerContext* context, const ::minknow_api::manager::RemoveSimulatedDeviceRequest* request, ::minknow_api::manager::RemoveSimulatedDeviceResponse* response);
    // Get the path for the local authentication token.
    //
    // This RPC is only useful when connecting to MinKNOW from the same computer that MinKNOW is
    // running on (ie: connecting to "localhost"). If this file exists (which it should if MinKNOW's
    // guest mode is not completely disabled), it contains a description of a token that can be used
    // to connect to MinKNOW. This is most useful when MinKNOW's guest mode is set to "local_only",
    // as it certifies that the client is connecting from the local machine. If the guest mode is
    // set to "enabled", no token is required to connect.
    //
    // The contents of the file is a json object with two fields, "token" and "expires". "token" is
    // the string that can be passed in a "local-auth" gRPC authentication metadata field, while
    // "expires" gives the time the token will expire (in RFC3339 format). Note that a new token
    // will be written out shortly before this time (and, in fact, the token will be accepted a
    // short time after).
    //
    //
    // An example token file is::
    //
    //  {
    //    "token": "30fe5214-a7c5-4cb3-b521-b1ec8a49592a",
    //    "expires": "2020-12-18T14:26:12.021934+00:00"
    //  }
    //
    // To connect before 14:26:12.021934 on 2020-12-18, a client would set the metadata field
    // "local-auth" to "30fe5214-a7c5-4cb3-b521-b1ec8a49592a". At around 14:26:12, the client should
    // re-read the file and update the metadata field with the newly-read value.
    //
    // This RPC can be called without providing any authentication tokens.
    //
    // Since 4.2
    virtual ::grpc::Status local_authentication_token_path(::grpc::ServerContext* context, const ::minknow_api::manager::LocalAuthenticationTokenPathRequest* request, ::minknow_api::manager::LocalAuthenticationTokenPathResponse* response);
    // Query information about a reference file.
    //
    // Reference file types are picked up by extension:
    // for fasta: .fasta, .fna, .ffn, .faa, .frn
    // for mmi: .mmi
    //
    // Since 4.4
    virtual ::grpc::Status get_alignment_reference_information(::grpc::ServerContext* context, const ::minknow_api::manager::GetAlignmentReferenceInformationRequest* request, ::minknow_api::manager::GetAlignmentReferenceInformationResponse* response);
    // Get the device code/key for association.
    //
    // This can be used to either get the code that the user must enter into the customer support
    // portal to associate the device with their account, or the key used for online association.
    //
    // Errors:
    //     INVALID_ARGUMENT: The requested flow cell position does not exist.
    //
    // Since 4.4
    virtual ::grpc::Status association_device_code(::grpc::ServerContext* context, const ::minknow_api::manager::AssociationDeviceCodeRequest* request, ::minknow_api::manager::AssociationDeviceCodeResponse* response);
    // Apply the unlock code for offline association.
    //
    // This is the code that the user receives from the customer support portal after entering the
    // device code for this device (see `offline_association_device_code`).
    //
    // This is only required if either `describe_host` indicates that the device as a whole needs
    // association, or `flow_cell_positions` indicates that a particular positions needs it.
    //
    // Errors:
    //     INVALID_ARGUMENT: The requested flow cell position does not exist, or no unlock code
    //         was provided.
    //
    // Note that you will need to check the result to see if the association was successful. Calling
    // this on an already-associated device with a valid unlock code will succeed, but have no
    // effect.
    //
    // Since 4.4
    virtual ::grpc::Status apply_offline_association_unlock_code(::grpc::ServerContext* context, const ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeRequest* request, ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeResponse* response);
    // List all developer API tokens.
    //
    // List all developer tokens, and their expiry times. Note this does not return the actual token value - this is only available at creation time.
    //
    // Since 4.4
    virtual ::grpc::Status list_developer_api_tokens(::grpc::ServerContext* context, const ::minknow_api::manager::ListDeveloperApiTokensRequest* request, ::minknow_api::manager::ListDeveloperApiTokensResponse* response);
    // Create a new developer API token, with a user facing name, and optional expiry time.
    //
    // The response contains the requested token, which will be valid until provided expiry time.
    //
    // The token cannot be obtained a second time, once the CreateDeveloperApiTokenResponse is destroyed.
    //
    // Since 4.4
    virtual ::grpc::Status create_developer_api_token(::grpc::ServerContext* context, const ::minknow_api::manager::CreateDeveloperApiTokenRequest* request, ::minknow_api::manager::CreateDeveloperApiTokenResponse* response);
    // Remove a developer api token.
    //
    // Since 4.4
    virtual ::grpc::Status revoke_developer_api_token(::grpc::ServerContext* context, const ::minknow_api::manager::RevokeDeveloperApiTokenRequest* request, ::minknow_api::manager::RevokeDeveloperApiTokensResponse* response);
    // Find protocols which can be run based on the current device + flowcell.
    //
    // Throws an error if there is no flow cell connected.
    //
    // Since 4.5
    virtual ::grpc::Status find_protocols(::grpc::ServerContext* context, const ::minknow_api::manager::FindProtocolsRequest* request, ::minknow_api::manager::FindProtocolsResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_describe_host : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_describe_host() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_describe_host() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status describe_host(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::DescribeHostRequest* /*request*/, ::minknow_api::manager::DescribeHostResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdescribe_host(::grpc::ServerContext* context, ::minknow_api::manager::DescribeHostRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::manager::DescribeHostResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_flow_cell_positions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_flow_cell_positions() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_flow_cell_positions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status flow_cell_positions(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::FlowCellPositionsRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::manager::FlowCellPositionsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestflow_cell_positions(::grpc::ServerContext* context, ::minknow_api::manager::FlowCellPositionsRequest* request, ::grpc::ServerAsyncWriter< ::minknow_api::manager::FlowCellPositionsResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(1, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_watch_flow_cell_positions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_watch_flow_cell_positions() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_watch_flow_cell_positions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status watch_flow_cell_positions(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::WatchFlowCellPositionsRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::manager::WatchFlowCellPositionsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestwatch_flow_cell_positions(::grpc::ServerContext* context, ::minknow_api::manager::WatchFlowCellPositionsRequest* request, ::grpc::ServerAsyncWriter< ::minknow_api::manager::WatchFlowCellPositionsResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(2, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_reset_position : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_reset_position() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_reset_position() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status reset_position(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::ResetPositionRequest* /*request*/, ::minknow_api::manager::ResetPositionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestreset_position(::grpc::ServerContext* context, ::minknow_api::manager::ResetPositionRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::manager::ResetPositionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_basecaller_api : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_basecaller_api() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_basecaller_api() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status basecaller_api(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::BasecallerApiRequest* /*request*/, ::minknow_api::manager::BasecallerApiResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestbasecaller_api(::grpc::ServerContext* context, ::minknow_api::manager::BasecallerApiRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::manager::BasecallerApiResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_guppy_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_guppy_info() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_get_guppy_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_guppy_info(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetGuppyInfoRequest* /*request*/, ::minknow_api::manager::GetGuppyInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_guppy_info(::grpc::ServerContext* context, ::minknow_api::manager::GetGuppyInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::manager::GetGuppyInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_version_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_version_info() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_get_version_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_version_info(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetVersionInfoRequest* /*request*/, ::minknow_api::manager::GetVersionInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_version_info(::grpc::ServerContext* context, ::minknow_api::manager::GetVersionInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::manager::GetVersionInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_list_protocol_output_dir_files : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_list_protocol_output_dir_files() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_list_protocol_output_dir_files() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status list_protocol_output_dir_files(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::ListProtocolOutputDirFilesRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::manager::ListProtocolOutputDirFilesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestlist_protocol_output_dir_files(::grpc::ServerContext* context, ::minknow_api::manager::ListProtocolOutputDirFilesRequest* request, ::grpc::ServerAsyncWriter< ::minknow_api::manager::ListProtocolOutputDirFilesResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(7, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_create_directory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_create_directory() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_create_directory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create_directory(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::CreateDirectoryRequest* /*request*/, ::minknow_api::manager::CreateDirectoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestcreate_directory(::grpc::ServerContext* context, ::minknow_api::manager::CreateDirectoryRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::manager::CreateDirectoryResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_disk_space_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_disk_space_info() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_get_disk_space_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_disk_space_info(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetDiskSpaceInfoRequest* /*request*/, ::minknow_api::manager::GetDiskSpaceInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_disk_space_info(::grpc::ServerContext* context, ::minknow_api::manager::GetDiskSpaceInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::manager::GetDiskSpaceInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_default_output_directories : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_default_output_directories() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_get_default_output_directories() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_default_output_directories(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest* /*request*/, ::minknow_api::instance::OutputDirectories* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_default_output_directories(::grpc::ServerContext* context, ::minknow_api::instance::GetDefaultOutputDirectoriesRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::instance::OutputDirectories>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_stream_disk_space_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_stream_disk_space_info() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_stream_disk_space_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stream_disk_space_info(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::StreamDiskSpaceInfoRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::manager::GetDiskSpaceInfoResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requeststream_disk_space_info(::grpc::ServerContext* context, ::minknow_api::manager::StreamDiskSpaceInfoRequest* request, ::grpc::ServerAsyncWriter< ::minknow_api::manager::GetDiskSpaceInfoResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(11, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_barcode_kit_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_barcode_kit_info() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_get_barcode_kit_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_barcode_kit_info(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetBarcodeKitInfoRequest* /*request*/, ::minknow_api::manager::GetBarcodeKitInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_barcode_kit_info(::grpc::ServerContext* context, ::minknow_api::manager::GetBarcodeKitInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::manager::GetBarcodeKitInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_lamp_kit_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_lamp_kit_info() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_get_lamp_kit_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_lamp_kit_info(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetLampKitInfoRequest* /*request*/, ::minknow_api::manager::GetLampKitInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_lamp_kit_info(::grpc::ServerContext* context, ::minknow_api::manager::GetLampKitInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::manager::GetLampKitInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_barcode_keys : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_barcode_keys() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_get_barcode_keys() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_barcode_keys(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetBarcodeKeysRequest* /*request*/, ::minknow_api::manager::GetBarcodeKeysResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_barcode_keys(::grpc::ServerContext* context, ::minknow_api::manager::GetBarcodeKeysRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::manager::GetBarcodeKeysResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_flow_cell_types : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_flow_cell_types() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_get_flow_cell_types() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_flow_cell_types(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetFlowCellTypesRequest* /*request*/, ::minknow_api::manager::GetFlowCellTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_flow_cell_types(::grpc::ServerContext* context, ::minknow_api::manager::GetFlowCellTypesRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::manager::GetFlowCellTypesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_sequencing_kits : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_sequencing_kits() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_get_sequencing_kits() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_sequencing_kits(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetSequencingKitsRequest* /*request*/, ::minknow_api::manager::GetSequencingKitsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_sequencing_kits(::grpc::ServerContext* context, ::minknow_api::manager::GetSequencingKitsRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::manager::GetSequencingKitsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_add_simulated_device : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_add_simulated_device() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_add_simulated_device() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status add_simulated_device(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::AddSimulatedDeviceRequest* /*request*/, ::minknow_api::manager::AddSimulatedDeviceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestadd_simulated_device(::grpc::ServerContext* context, ::minknow_api::manager::AddSimulatedDeviceRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::manager::AddSimulatedDeviceResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_remove_simulated_device : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_remove_simulated_device() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_remove_simulated_device() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status remove_simulated_device(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::RemoveSimulatedDeviceRequest* /*request*/, ::minknow_api::manager::RemoveSimulatedDeviceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestremove_simulated_device(::grpc::ServerContext* context, ::minknow_api::manager::RemoveSimulatedDeviceRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::manager::RemoveSimulatedDeviceResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_local_authentication_token_path : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_local_authentication_token_path() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_local_authentication_token_path() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status local_authentication_token_path(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::LocalAuthenticationTokenPathRequest* /*request*/, ::minknow_api::manager::LocalAuthenticationTokenPathResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestlocal_authentication_token_path(::grpc::ServerContext* context, ::minknow_api::manager::LocalAuthenticationTokenPathRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::manager::LocalAuthenticationTokenPathResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_alignment_reference_information : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_alignment_reference_information() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_get_alignment_reference_information() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_alignment_reference_information(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetAlignmentReferenceInformationRequest* /*request*/, ::minknow_api::manager::GetAlignmentReferenceInformationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_alignment_reference_information(::grpc::ServerContext* context, ::minknow_api::manager::GetAlignmentReferenceInformationRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::manager::GetAlignmentReferenceInformationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_association_device_code : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_association_device_code() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_association_device_code() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status association_device_code(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::AssociationDeviceCodeRequest* /*request*/, ::minknow_api::manager::AssociationDeviceCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestassociation_device_code(::grpc::ServerContext* context, ::minknow_api::manager::AssociationDeviceCodeRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::manager::AssociationDeviceCodeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_apply_offline_association_unlock_code : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_apply_offline_association_unlock_code() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_apply_offline_association_unlock_code() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status apply_offline_association_unlock_code(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeRequest* /*request*/, ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestapply_offline_association_unlock_code(::grpc::ServerContext* context, ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_list_developer_api_tokens : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_list_developer_api_tokens() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_list_developer_api_tokens() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status list_developer_api_tokens(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::ListDeveloperApiTokensRequest* /*request*/, ::minknow_api::manager::ListDeveloperApiTokensResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestlist_developer_api_tokens(::grpc::ServerContext* context, ::minknow_api::manager::ListDeveloperApiTokensRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::manager::ListDeveloperApiTokensResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_create_developer_api_token : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_create_developer_api_token() {
      ::grpc::Service::MarkMethodAsync(24);
    }
    ~WithAsyncMethod_create_developer_api_token() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create_developer_api_token(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::CreateDeveloperApiTokenRequest* /*request*/, ::minknow_api::manager::CreateDeveloperApiTokenResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestcreate_developer_api_token(::grpc::ServerContext* context, ::minknow_api::manager::CreateDeveloperApiTokenRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::manager::CreateDeveloperApiTokenResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_revoke_developer_api_token : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_revoke_developer_api_token() {
      ::grpc::Service::MarkMethodAsync(25);
    }
    ~WithAsyncMethod_revoke_developer_api_token() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status revoke_developer_api_token(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::RevokeDeveloperApiTokenRequest* /*request*/, ::minknow_api::manager::RevokeDeveloperApiTokensResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestrevoke_developer_api_token(::grpc::ServerContext* context, ::minknow_api::manager::RevokeDeveloperApiTokenRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::manager::RevokeDeveloperApiTokensResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_find_protocols : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_find_protocols() {
      ::grpc::Service::MarkMethodAsync(26);
    }
    ~WithAsyncMethod_find_protocols() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status find_protocols(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::FindProtocolsRequest* /*request*/, ::minknow_api::manager::FindProtocolsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestfind_protocols(::grpc::ServerContext* context, ::minknow_api::manager::FindProtocolsRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::manager::FindProtocolsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_describe_host<WithAsyncMethod_flow_cell_positions<WithAsyncMethod_watch_flow_cell_positions<WithAsyncMethod_reset_position<WithAsyncMethod_basecaller_api<WithAsyncMethod_get_guppy_info<WithAsyncMethod_get_version_info<WithAsyncMethod_list_protocol_output_dir_files<WithAsyncMethod_create_directory<WithAsyncMethod_get_disk_space_info<WithAsyncMethod_get_default_output_directories<WithAsyncMethod_stream_disk_space_info<WithAsyncMethod_get_barcode_kit_info<WithAsyncMethod_get_lamp_kit_info<WithAsyncMethod_get_barcode_keys<WithAsyncMethod_get_flow_cell_types<WithAsyncMethod_get_sequencing_kits<WithAsyncMethod_add_simulated_device<WithAsyncMethod_remove_simulated_device<WithAsyncMethod_local_authentication_token_path<WithAsyncMethod_get_alignment_reference_information<WithAsyncMethod_association_device_code<WithAsyncMethod_apply_offline_association_unlock_code<WithAsyncMethod_list_developer_api_tokens<WithAsyncMethod_create_developer_api_token<WithAsyncMethod_revoke_developer_api_token<WithAsyncMethod_find_protocols<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_describe_host : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_describe_host() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::DescribeHostRequest, ::minknow_api::manager::DescribeHostResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::manager::DescribeHostRequest* request, ::minknow_api::manager::DescribeHostResponse* response) { return this->describe_host(context, request, response); }));}
    void SetMessageAllocatorFor_describe_host(
        ::grpc::MessageAllocator< ::minknow_api::manager::DescribeHostRequest, ::minknow_api::manager::DescribeHostResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::DescribeHostRequest, ::minknow_api::manager::DescribeHostResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_describe_host() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status describe_host(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::DescribeHostRequest* /*request*/, ::minknow_api::manager::DescribeHostResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* describe_host(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::manager::DescribeHostRequest* /*request*/, ::minknow_api::manager::DescribeHostResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_flow_cell_positions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_flow_cell_positions() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackServerStreamingHandler< ::minknow_api::manager::FlowCellPositionsRequest, ::minknow_api::manager::FlowCellPositionsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::manager::FlowCellPositionsRequest* request) { return this->flow_cell_positions(context, request); }));
    }
    ~WithCallbackMethod_flow_cell_positions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status flow_cell_positions(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::FlowCellPositionsRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::manager::FlowCellPositionsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::minknow_api::manager::FlowCellPositionsResponse>* flow_cell_positions(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::manager::FlowCellPositionsRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_watch_flow_cell_positions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_watch_flow_cell_positions() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackServerStreamingHandler< ::minknow_api::manager::WatchFlowCellPositionsRequest, ::minknow_api::manager::WatchFlowCellPositionsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::manager::WatchFlowCellPositionsRequest* request) { return this->watch_flow_cell_positions(context, request); }));
    }
    ~WithCallbackMethod_watch_flow_cell_positions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status watch_flow_cell_positions(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::WatchFlowCellPositionsRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::manager::WatchFlowCellPositionsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::minknow_api::manager::WatchFlowCellPositionsResponse>* watch_flow_cell_positions(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::manager::WatchFlowCellPositionsRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_reset_position : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_reset_position() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::ResetPositionRequest, ::minknow_api::manager::ResetPositionResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::manager::ResetPositionRequest* request, ::minknow_api::manager::ResetPositionResponse* response) { return this->reset_position(context, request, response); }));}
    void SetMessageAllocatorFor_reset_position(
        ::grpc::MessageAllocator< ::minknow_api::manager::ResetPositionRequest, ::minknow_api::manager::ResetPositionResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::ResetPositionRequest, ::minknow_api::manager::ResetPositionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_reset_position() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status reset_position(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::ResetPositionRequest* /*request*/, ::minknow_api::manager::ResetPositionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* reset_position(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::manager::ResetPositionRequest* /*request*/, ::minknow_api::manager::ResetPositionResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_basecaller_api : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_basecaller_api() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::BasecallerApiRequest, ::minknow_api::manager::BasecallerApiResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::manager::BasecallerApiRequest* request, ::minknow_api::manager::BasecallerApiResponse* response) { return this->basecaller_api(context, request, response); }));}
    void SetMessageAllocatorFor_basecaller_api(
        ::grpc::MessageAllocator< ::minknow_api::manager::BasecallerApiRequest, ::minknow_api::manager::BasecallerApiResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::BasecallerApiRequest, ::minknow_api::manager::BasecallerApiResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_basecaller_api() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status basecaller_api(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::BasecallerApiRequest* /*request*/, ::minknow_api::manager::BasecallerApiResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* basecaller_api(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::manager::BasecallerApiRequest* /*request*/, ::minknow_api::manager::BasecallerApiResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_guppy_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_guppy_info() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::GetGuppyInfoRequest, ::minknow_api::manager::GetGuppyInfoResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::manager::GetGuppyInfoRequest* request, ::minknow_api::manager::GetGuppyInfoResponse* response) { return this->get_guppy_info(context, request, response); }));}
    void SetMessageAllocatorFor_get_guppy_info(
        ::grpc::MessageAllocator< ::minknow_api::manager::GetGuppyInfoRequest, ::minknow_api::manager::GetGuppyInfoResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::GetGuppyInfoRequest, ::minknow_api::manager::GetGuppyInfoResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_guppy_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_guppy_info(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetGuppyInfoRequest* /*request*/, ::minknow_api::manager::GetGuppyInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_guppy_info(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::manager::GetGuppyInfoRequest* /*request*/, ::minknow_api::manager::GetGuppyInfoResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_version_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_version_info() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::GetVersionInfoRequest, ::minknow_api::manager::GetVersionInfoResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::manager::GetVersionInfoRequest* request, ::minknow_api::manager::GetVersionInfoResponse* response) { return this->get_version_info(context, request, response); }));}
    void SetMessageAllocatorFor_get_version_info(
        ::grpc::MessageAllocator< ::minknow_api::manager::GetVersionInfoRequest, ::minknow_api::manager::GetVersionInfoResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::GetVersionInfoRequest, ::minknow_api::manager::GetVersionInfoResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_version_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_version_info(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetVersionInfoRequest* /*request*/, ::minknow_api::manager::GetVersionInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_version_info(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::manager::GetVersionInfoRequest* /*request*/, ::minknow_api::manager::GetVersionInfoResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_list_protocol_output_dir_files : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_list_protocol_output_dir_files() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackServerStreamingHandler< ::minknow_api::manager::ListProtocolOutputDirFilesRequest, ::minknow_api::manager::ListProtocolOutputDirFilesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::manager::ListProtocolOutputDirFilesRequest* request) { return this->list_protocol_output_dir_files(context, request); }));
    }
    ~WithCallbackMethod_list_protocol_output_dir_files() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status list_protocol_output_dir_files(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::ListProtocolOutputDirFilesRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::manager::ListProtocolOutputDirFilesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::minknow_api::manager::ListProtocolOutputDirFilesResponse>* list_protocol_output_dir_files(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::manager::ListProtocolOutputDirFilesRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_create_directory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_create_directory() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::CreateDirectoryRequest, ::minknow_api::manager::CreateDirectoryResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::manager::CreateDirectoryRequest* request, ::minknow_api::manager::CreateDirectoryResponse* response) { return this->create_directory(context, request, response); }));}
    void SetMessageAllocatorFor_create_directory(
        ::grpc::MessageAllocator< ::minknow_api::manager::CreateDirectoryRequest, ::minknow_api::manager::CreateDirectoryResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::CreateDirectoryRequest, ::minknow_api::manager::CreateDirectoryResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_create_directory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create_directory(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::CreateDirectoryRequest* /*request*/, ::minknow_api::manager::CreateDirectoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* create_directory(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::manager::CreateDirectoryRequest* /*request*/, ::minknow_api::manager::CreateDirectoryResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_disk_space_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_disk_space_info() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::GetDiskSpaceInfoRequest, ::minknow_api::manager::GetDiskSpaceInfoResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::manager::GetDiskSpaceInfoRequest* request, ::minknow_api::manager::GetDiskSpaceInfoResponse* response) { return this->get_disk_space_info(context, request, response); }));}
    void SetMessageAllocatorFor_get_disk_space_info(
        ::grpc::MessageAllocator< ::minknow_api::manager::GetDiskSpaceInfoRequest, ::minknow_api::manager::GetDiskSpaceInfoResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::GetDiskSpaceInfoRequest, ::minknow_api::manager::GetDiskSpaceInfoResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_disk_space_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_disk_space_info(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetDiskSpaceInfoRequest* /*request*/, ::minknow_api::manager::GetDiskSpaceInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_disk_space_info(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::manager::GetDiskSpaceInfoRequest* /*request*/, ::minknow_api::manager::GetDiskSpaceInfoResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_default_output_directories : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_default_output_directories() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::instance::GetDefaultOutputDirectoriesRequest, ::minknow_api::instance::OutputDirectories>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest* request, ::minknow_api::instance::OutputDirectories* response) { return this->get_default_output_directories(context, request, response); }));}
    void SetMessageAllocatorFor_get_default_output_directories(
        ::grpc::MessageAllocator< ::minknow_api::instance::GetDefaultOutputDirectoriesRequest, ::minknow_api::instance::OutputDirectories>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::instance::GetDefaultOutputDirectoriesRequest, ::minknow_api::instance::OutputDirectories>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_default_output_directories() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_default_output_directories(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest* /*request*/, ::minknow_api::instance::OutputDirectories* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_default_output_directories(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest* /*request*/, ::minknow_api::instance::OutputDirectories* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_stream_disk_space_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_stream_disk_space_info() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackServerStreamingHandler< ::minknow_api::manager::StreamDiskSpaceInfoRequest, ::minknow_api::manager::GetDiskSpaceInfoResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::manager::StreamDiskSpaceInfoRequest* request) { return this->stream_disk_space_info(context, request); }));
    }
    ~WithCallbackMethod_stream_disk_space_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stream_disk_space_info(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::StreamDiskSpaceInfoRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::manager::GetDiskSpaceInfoResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::minknow_api::manager::GetDiskSpaceInfoResponse>* stream_disk_space_info(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::manager::StreamDiskSpaceInfoRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_barcode_kit_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_barcode_kit_info() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::GetBarcodeKitInfoRequest, ::minknow_api::manager::GetBarcodeKitInfoResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::manager::GetBarcodeKitInfoRequest* request, ::minknow_api::manager::GetBarcodeKitInfoResponse* response) { return this->get_barcode_kit_info(context, request, response); }));}
    void SetMessageAllocatorFor_get_barcode_kit_info(
        ::grpc::MessageAllocator< ::minknow_api::manager::GetBarcodeKitInfoRequest, ::minknow_api::manager::GetBarcodeKitInfoResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::GetBarcodeKitInfoRequest, ::minknow_api::manager::GetBarcodeKitInfoResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_barcode_kit_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_barcode_kit_info(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetBarcodeKitInfoRequest* /*request*/, ::minknow_api::manager::GetBarcodeKitInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_barcode_kit_info(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::manager::GetBarcodeKitInfoRequest* /*request*/, ::minknow_api::manager::GetBarcodeKitInfoResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_lamp_kit_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_lamp_kit_info() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::GetLampKitInfoRequest, ::minknow_api::manager::GetLampKitInfoResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::manager::GetLampKitInfoRequest* request, ::minknow_api::manager::GetLampKitInfoResponse* response) { return this->get_lamp_kit_info(context, request, response); }));}
    void SetMessageAllocatorFor_get_lamp_kit_info(
        ::grpc::MessageAllocator< ::minknow_api::manager::GetLampKitInfoRequest, ::minknow_api::manager::GetLampKitInfoResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::GetLampKitInfoRequest, ::minknow_api::manager::GetLampKitInfoResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_lamp_kit_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_lamp_kit_info(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetLampKitInfoRequest* /*request*/, ::minknow_api::manager::GetLampKitInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_lamp_kit_info(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::manager::GetLampKitInfoRequest* /*request*/, ::minknow_api::manager::GetLampKitInfoResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_barcode_keys : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_barcode_keys() {
      ::grpc::Service::MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::GetBarcodeKeysRequest, ::minknow_api::manager::GetBarcodeKeysResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::manager::GetBarcodeKeysRequest* request, ::minknow_api::manager::GetBarcodeKeysResponse* response) { return this->get_barcode_keys(context, request, response); }));}
    void SetMessageAllocatorFor_get_barcode_keys(
        ::grpc::MessageAllocator< ::minknow_api::manager::GetBarcodeKeysRequest, ::minknow_api::manager::GetBarcodeKeysResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::GetBarcodeKeysRequest, ::minknow_api::manager::GetBarcodeKeysResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_barcode_keys() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_barcode_keys(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetBarcodeKeysRequest* /*request*/, ::minknow_api::manager::GetBarcodeKeysResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_barcode_keys(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::manager::GetBarcodeKeysRequest* /*request*/, ::minknow_api::manager::GetBarcodeKeysResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_flow_cell_types : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_flow_cell_types() {
      ::grpc::Service::MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::GetFlowCellTypesRequest, ::minknow_api::manager::GetFlowCellTypesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::manager::GetFlowCellTypesRequest* request, ::minknow_api::manager::GetFlowCellTypesResponse* response) { return this->get_flow_cell_types(context, request, response); }));}
    void SetMessageAllocatorFor_get_flow_cell_types(
        ::grpc::MessageAllocator< ::minknow_api::manager::GetFlowCellTypesRequest, ::minknow_api::manager::GetFlowCellTypesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::GetFlowCellTypesRequest, ::minknow_api::manager::GetFlowCellTypesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_flow_cell_types() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_flow_cell_types(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetFlowCellTypesRequest* /*request*/, ::minknow_api::manager::GetFlowCellTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_flow_cell_types(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::manager::GetFlowCellTypesRequest* /*request*/, ::minknow_api::manager::GetFlowCellTypesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_sequencing_kits : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_sequencing_kits() {
      ::grpc::Service::MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::GetSequencingKitsRequest, ::minknow_api::manager::GetSequencingKitsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::manager::GetSequencingKitsRequest* request, ::minknow_api::manager::GetSequencingKitsResponse* response) { return this->get_sequencing_kits(context, request, response); }));}
    void SetMessageAllocatorFor_get_sequencing_kits(
        ::grpc::MessageAllocator< ::minknow_api::manager::GetSequencingKitsRequest, ::minknow_api::manager::GetSequencingKitsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::GetSequencingKitsRequest, ::minknow_api::manager::GetSequencingKitsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_sequencing_kits() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_sequencing_kits(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetSequencingKitsRequest* /*request*/, ::minknow_api::manager::GetSequencingKitsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_sequencing_kits(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::manager::GetSequencingKitsRequest* /*request*/, ::minknow_api::manager::GetSequencingKitsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_add_simulated_device : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_add_simulated_device() {
      ::grpc::Service::MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::AddSimulatedDeviceRequest, ::minknow_api::manager::AddSimulatedDeviceResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::manager::AddSimulatedDeviceRequest* request, ::minknow_api::manager::AddSimulatedDeviceResponse* response) { return this->add_simulated_device(context, request, response); }));}
    void SetMessageAllocatorFor_add_simulated_device(
        ::grpc::MessageAllocator< ::minknow_api::manager::AddSimulatedDeviceRequest, ::minknow_api::manager::AddSimulatedDeviceResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::AddSimulatedDeviceRequest, ::minknow_api::manager::AddSimulatedDeviceResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_add_simulated_device() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status add_simulated_device(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::AddSimulatedDeviceRequest* /*request*/, ::minknow_api::manager::AddSimulatedDeviceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* add_simulated_device(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::manager::AddSimulatedDeviceRequest* /*request*/, ::minknow_api::manager::AddSimulatedDeviceResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_remove_simulated_device : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_remove_simulated_device() {
      ::grpc::Service::MarkMethodCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::RemoveSimulatedDeviceRequest, ::minknow_api::manager::RemoveSimulatedDeviceResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::manager::RemoveSimulatedDeviceRequest* request, ::minknow_api::manager::RemoveSimulatedDeviceResponse* response) { return this->remove_simulated_device(context, request, response); }));}
    void SetMessageAllocatorFor_remove_simulated_device(
        ::grpc::MessageAllocator< ::minknow_api::manager::RemoveSimulatedDeviceRequest, ::minknow_api::manager::RemoveSimulatedDeviceResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::RemoveSimulatedDeviceRequest, ::minknow_api::manager::RemoveSimulatedDeviceResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_remove_simulated_device() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status remove_simulated_device(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::RemoveSimulatedDeviceRequest* /*request*/, ::minknow_api::manager::RemoveSimulatedDeviceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* remove_simulated_device(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::manager::RemoveSimulatedDeviceRequest* /*request*/, ::minknow_api::manager::RemoveSimulatedDeviceResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_local_authentication_token_path : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_local_authentication_token_path() {
      ::grpc::Service::MarkMethodCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::LocalAuthenticationTokenPathRequest, ::minknow_api::manager::LocalAuthenticationTokenPathResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::manager::LocalAuthenticationTokenPathRequest* request, ::minknow_api::manager::LocalAuthenticationTokenPathResponse* response) { return this->local_authentication_token_path(context, request, response); }));}
    void SetMessageAllocatorFor_local_authentication_token_path(
        ::grpc::MessageAllocator< ::minknow_api::manager::LocalAuthenticationTokenPathRequest, ::minknow_api::manager::LocalAuthenticationTokenPathResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(19);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::LocalAuthenticationTokenPathRequest, ::minknow_api::manager::LocalAuthenticationTokenPathResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_local_authentication_token_path() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status local_authentication_token_path(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::LocalAuthenticationTokenPathRequest* /*request*/, ::minknow_api::manager::LocalAuthenticationTokenPathResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* local_authentication_token_path(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::manager::LocalAuthenticationTokenPathRequest* /*request*/, ::minknow_api::manager::LocalAuthenticationTokenPathResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_alignment_reference_information : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_alignment_reference_information() {
      ::grpc::Service::MarkMethodCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::GetAlignmentReferenceInformationRequest, ::minknow_api::manager::GetAlignmentReferenceInformationResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::manager::GetAlignmentReferenceInformationRequest* request, ::minknow_api::manager::GetAlignmentReferenceInformationResponse* response) { return this->get_alignment_reference_information(context, request, response); }));}
    void SetMessageAllocatorFor_get_alignment_reference_information(
        ::grpc::MessageAllocator< ::minknow_api::manager::GetAlignmentReferenceInformationRequest, ::minknow_api::manager::GetAlignmentReferenceInformationResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(20);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::GetAlignmentReferenceInformationRequest, ::minknow_api::manager::GetAlignmentReferenceInformationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_alignment_reference_information() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_alignment_reference_information(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetAlignmentReferenceInformationRequest* /*request*/, ::minknow_api::manager::GetAlignmentReferenceInformationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_alignment_reference_information(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::manager::GetAlignmentReferenceInformationRequest* /*request*/, ::minknow_api::manager::GetAlignmentReferenceInformationResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_association_device_code : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_association_device_code() {
      ::grpc::Service::MarkMethodCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::AssociationDeviceCodeRequest, ::minknow_api::manager::AssociationDeviceCodeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::manager::AssociationDeviceCodeRequest* request, ::minknow_api::manager::AssociationDeviceCodeResponse* response) { return this->association_device_code(context, request, response); }));}
    void SetMessageAllocatorFor_association_device_code(
        ::grpc::MessageAllocator< ::minknow_api::manager::AssociationDeviceCodeRequest, ::minknow_api::manager::AssociationDeviceCodeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(21);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::AssociationDeviceCodeRequest, ::minknow_api::manager::AssociationDeviceCodeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_association_device_code() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status association_device_code(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::AssociationDeviceCodeRequest* /*request*/, ::minknow_api::manager::AssociationDeviceCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* association_device_code(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::manager::AssociationDeviceCodeRequest* /*request*/, ::minknow_api::manager::AssociationDeviceCodeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_apply_offline_association_unlock_code : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_apply_offline_association_unlock_code() {
      ::grpc::Service::MarkMethodCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeRequest, ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeRequest* request, ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeResponse* response) { return this->apply_offline_association_unlock_code(context, request, response); }));}
    void SetMessageAllocatorFor_apply_offline_association_unlock_code(
        ::grpc::MessageAllocator< ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeRequest, ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(22);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeRequest, ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_apply_offline_association_unlock_code() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status apply_offline_association_unlock_code(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeRequest* /*request*/, ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* apply_offline_association_unlock_code(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeRequest* /*request*/, ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_list_developer_api_tokens : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_list_developer_api_tokens() {
      ::grpc::Service::MarkMethodCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::ListDeveloperApiTokensRequest, ::minknow_api::manager::ListDeveloperApiTokensResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::manager::ListDeveloperApiTokensRequest* request, ::minknow_api::manager::ListDeveloperApiTokensResponse* response) { return this->list_developer_api_tokens(context, request, response); }));}
    void SetMessageAllocatorFor_list_developer_api_tokens(
        ::grpc::MessageAllocator< ::minknow_api::manager::ListDeveloperApiTokensRequest, ::minknow_api::manager::ListDeveloperApiTokensResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(23);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::ListDeveloperApiTokensRequest, ::minknow_api::manager::ListDeveloperApiTokensResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_list_developer_api_tokens() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status list_developer_api_tokens(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::ListDeveloperApiTokensRequest* /*request*/, ::minknow_api::manager::ListDeveloperApiTokensResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* list_developer_api_tokens(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::manager::ListDeveloperApiTokensRequest* /*request*/, ::minknow_api::manager::ListDeveloperApiTokensResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_create_developer_api_token : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_create_developer_api_token() {
      ::grpc::Service::MarkMethodCallback(24,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::CreateDeveloperApiTokenRequest, ::minknow_api::manager::CreateDeveloperApiTokenResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::manager::CreateDeveloperApiTokenRequest* request, ::minknow_api::manager::CreateDeveloperApiTokenResponse* response) { return this->create_developer_api_token(context, request, response); }));}
    void SetMessageAllocatorFor_create_developer_api_token(
        ::grpc::MessageAllocator< ::minknow_api::manager::CreateDeveloperApiTokenRequest, ::minknow_api::manager::CreateDeveloperApiTokenResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(24);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::CreateDeveloperApiTokenRequest, ::minknow_api::manager::CreateDeveloperApiTokenResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_create_developer_api_token() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create_developer_api_token(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::CreateDeveloperApiTokenRequest* /*request*/, ::minknow_api::manager::CreateDeveloperApiTokenResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* create_developer_api_token(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::manager::CreateDeveloperApiTokenRequest* /*request*/, ::minknow_api::manager::CreateDeveloperApiTokenResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_revoke_developer_api_token : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_revoke_developer_api_token() {
      ::grpc::Service::MarkMethodCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::RevokeDeveloperApiTokenRequest, ::minknow_api::manager::RevokeDeveloperApiTokensResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::manager::RevokeDeveloperApiTokenRequest* request, ::minknow_api::manager::RevokeDeveloperApiTokensResponse* response) { return this->revoke_developer_api_token(context, request, response); }));}
    void SetMessageAllocatorFor_revoke_developer_api_token(
        ::grpc::MessageAllocator< ::minknow_api::manager::RevokeDeveloperApiTokenRequest, ::minknow_api::manager::RevokeDeveloperApiTokensResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(25);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::RevokeDeveloperApiTokenRequest, ::minknow_api::manager::RevokeDeveloperApiTokensResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_revoke_developer_api_token() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status revoke_developer_api_token(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::RevokeDeveloperApiTokenRequest* /*request*/, ::minknow_api::manager::RevokeDeveloperApiTokensResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* revoke_developer_api_token(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::manager::RevokeDeveloperApiTokenRequest* /*request*/, ::minknow_api::manager::RevokeDeveloperApiTokensResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_find_protocols : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_find_protocols() {
      ::grpc::Service::MarkMethodCallback(26,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::FindProtocolsRequest, ::minknow_api::manager::FindProtocolsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::manager::FindProtocolsRequest* request, ::minknow_api::manager::FindProtocolsResponse* response) { return this->find_protocols(context, request, response); }));}
    void SetMessageAllocatorFor_find_protocols(
        ::grpc::MessageAllocator< ::minknow_api::manager::FindProtocolsRequest, ::minknow_api::manager::FindProtocolsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(26);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::manager::FindProtocolsRequest, ::minknow_api::manager::FindProtocolsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_find_protocols() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status find_protocols(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::FindProtocolsRequest* /*request*/, ::minknow_api::manager::FindProtocolsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* find_protocols(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::manager::FindProtocolsRequest* /*request*/, ::minknow_api::manager::FindProtocolsResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_describe_host<WithCallbackMethod_flow_cell_positions<WithCallbackMethod_watch_flow_cell_positions<WithCallbackMethod_reset_position<WithCallbackMethod_basecaller_api<WithCallbackMethod_get_guppy_info<WithCallbackMethod_get_version_info<WithCallbackMethod_list_protocol_output_dir_files<WithCallbackMethod_create_directory<WithCallbackMethod_get_disk_space_info<WithCallbackMethod_get_default_output_directories<WithCallbackMethod_stream_disk_space_info<WithCallbackMethod_get_barcode_kit_info<WithCallbackMethod_get_lamp_kit_info<WithCallbackMethod_get_barcode_keys<WithCallbackMethod_get_flow_cell_types<WithCallbackMethod_get_sequencing_kits<WithCallbackMethod_add_simulated_device<WithCallbackMethod_remove_simulated_device<WithCallbackMethod_local_authentication_token_path<WithCallbackMethod_get_alignment_reference_information<WithCallbackMethod_association_device_code<WithCallbackMethod_apply_offline_association_unlock_code<WithCallbackMethod_list_developer_api_tokens<WithCallbackMethod_create_developer_api_token<WithCallbackMethod_revoke_developer_api_token<WithCallbackMethod_find_protocols<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_describe_host : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_describe_host() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_describe_host() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status describe_host(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::DescribeHostRequest* /*request*/, ::minknow_api::manager::DescribeHostResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_flow_cell_positions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_flow_cell_positions() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_flow_cell_positions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status flow_cell_positions(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::FlowCellPositionsRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::manager::FlowCellPositionsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_watch_flow_cell_positions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_watch_flow_cell_positions() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_watch_flow_cell_positions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status watch_flow_cell_positions(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::WatchFlowCellPositionsRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::manager::WatchFlowCellPositionsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_reset_position : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_reset_position() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_reset_position() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status reset_position(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::ResetPositionRequest* /*request*/, ::minknow_api::manager::ResetPositionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_basecaller_api : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_basecaller_api() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_basecaller_api() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status basecaller_api(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::BasecallerApiRequest* /*request*/, ::minknow_api::manager::BasecallerApiResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_guppy_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_guppy_info() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_get_guppy_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_guppy_info(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetGuppyInfoRequest* /*request*/, ::minknow_api::manager::GetGuppyInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_version_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_version_info() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_get_version_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_version_info(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetVersionInfoRequest* /*request*/, ::minknow_api::manager::GetVersionInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_list_protocol_output_dir_files : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_list_protocol_output_dir_files() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_list_protocol_output_dir_files() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status list_protocol_output_dir_files(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::ListProtocolOutputDirFilesRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::manager::ListProtocolOutputDirFilesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_create_directory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_create_directory() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_create_directory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create_directory(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::CreateDirectoryRequest* /*request*/, ::minknow_api::manager::CreateDirectoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_disk_space_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_disk_space_info() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_get_disk_space_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_disk_space_info(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetDiskSpaceInfoRequest* /*request*/, ::minknow_api::manager::GetDiskSpaceInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_default_output_directories : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_default_output_directories() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_get_default_output_directories() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_default_output_directories(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest* /*request*/, ::minknow_api::instance::OutputDirectories* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_stream_disk_space_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_stream_disk_space_info() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_stream_disk_space_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stream_disk_space_info(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::StreamDiskSpaceInfoRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::manager::GetDiskSpaceInfoResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_barcode_kit_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_barcode_kit_info() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_get_barcode_kit_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_barcode_kit_info(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetBarcodeKitInfoRequest* /*request*/, ::minknow_api::manager::GetBarcodeKitInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_lamp_kit_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_lamp_kit_info() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_get_lamp_kit_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_lamp_kit_info(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetLampKitInfoRequest* /*request*/, ::minknow_api::manager::GetLampKitInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_barcode_keys : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_barcode_keys() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_get_barcode_keys() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_barcode_keys(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetBarcodeKeysRequest* /*request*/, ::minknow_api::manager::GetBarcodeKeysResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_flow_cell_types : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_flow_cell_types() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_get_flow_cell_types() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_flow_cell_types(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetFlowCellTypesRequest* /*request*/, ::minknow_api::manager::GetFlowCellTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_sequencing_kits : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_sequencing_kits() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_get_sequencing_kits() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_sequencing_kits(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetSequencingKitsRequest* /*request*/, ::minknow_api::manager::GetSequencingKitsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_add_simulated_device : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_add_simulated_device() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_add_simulated_device() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status add_simulated_device(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::AddSimulatedDeviceRequest* /*request*/, ::minknow_api::manager::AddSimulatedDeviceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_remove_simulated_device : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_remove_simulated_device() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_remove_simulated_device() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status remove_simulated_device(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::RemoveSimulatedDeviceRequest* /*request*/, ::minknow_api::manager::RemoveSimulatedDeviceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_local_authentication_token_path : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_local_authentication_token_path() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_local_authentication_token_path() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status local_authentication_token_path(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::LocalAuthenticationTokenPathRequest* /*request*/, ::minknow_api::manager::LocalAuthenticationTokenPathResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_alignment_reference_information : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_alignment_reference_information() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_get_alignment_reference_information() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_alignment_reference_information(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetAlignmentReferenceInformationRequest* /*request*/, ::minknow_api::manager::GetAlignmentReferenceInformationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_association_device_code : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_association_device_code() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_association_device_code() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status association_device_code(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::AssociationDeviceCodeRequest* /*request*/, ::minknow_api::manager::AssociationDeviceCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_apply_offline_association_unlock_code : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_apply_offline_association_unlock_code() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_apply_offline_association_unlock_code() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status apply_offline_association_unlock_code(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeRequest* /*request*/, ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_list_developer_api_tokens : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_list_developer_api_tokens() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_list_developer_api_tokens() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status list_developer_api_tokens(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::ListDeveloperApiTokensRequest* /*request*/, ::minknow_api::manager::ListDeveloperApiTokensResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_create_developer_api_token : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_create_developer_api_token() {
      ::grpc::Service::MarkMethodGeneric(24);
    }
    ~WithGenericMethod_create_developer_api_token() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create_developer_api_token(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::CreateDeveloperApiTokenRequest* /*request*/, ::minknow_api::manager::CreateDeveloperApiTokenResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_revoke_developer_api_token : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_revoke_developer_api_token() {
      ::grpc::Service::MarkMethodGeneric(25);
    }
    ~WithGenericMethod_revoke_developer_api_token() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status revoke_developer_api_token(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::RevokeDeveloperApiTokenRequest* /*request*/, ::minknow_api::manager::RevokeDeveloperApiTokensResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_find_protocols : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_find_protocols() {
      ::grpc::Service::MarkMethodGeneric(26);
    }
    ~WithGenericMethod_find_protocols() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status find_protocols(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::FindProtocolsRequest* /*request*/, ::minknow_api::manager::FindProtocolsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_describe_host : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_describe_host() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_describe_host() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status describe_host(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::DescribeHostRequest* /*request*/, ::minknow_api::manager::DescribeHostResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdescribe_host(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_flow_cell_positions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_flow_cell_positions() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_flow_cell_positions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status flow_cell_positions(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::FlowCellPositionsRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::manager::FlowCellPositionsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestflow_cell_positions(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(1, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_watch_flow_cell_positions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_watch_flow_cell_positions() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_watch_flow_cell_positions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status watch_flow_cell_positions(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::WatchFlowCellPositionsRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::manager::WatchFlowCellPositionsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestwatch_flow_cell_positions(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(2, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_reset_position : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_reset_position() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_reset_position() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status reset_position(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::ResetPositionRequest* /*request*/, ::minknow_api::manager::ResetPositionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestreset_position(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_basecaller_api : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_basecaller_api() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_basecaller_api() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status basecaller_api(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::BasecallerApiRequest* /*request*/, ::minknow_api::manager::BasecallerApiResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestbasecaller_api(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_guppy_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_guppy_info() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_get_guppy_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_guppy_info(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetGuppyInfoRequest* /*request*/, ::minknow_api::manager::GetGuppyInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_guppy_info(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_version_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_version_info() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_get_version_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_version_info(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetVersionInfoRequest* /*request*/, ::minknow_api::manager::GetVersionInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_version_info(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_list_protocol_output_dir_files : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_list_protocol_output_dir_files() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_list_protocol_output_dir_files() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status list_protocol_output_dir_files(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::ListProtocolOutputDirFilesRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::manager::ListProtocolOutputDirFilesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestlist_protocol_output_dir_files(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(7, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_create_directory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_create_directory() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_create_directory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create_directory(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::CreateDirectoryRequest* /*request*/, ::minknow_api::manager::CreateDirectoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestcreate_directory(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_disk_space_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_disk_space_info() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_get_disk_space_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_disk_space_info(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetDiskSpaceInfoRequest* /*request*/, ::minknow_api::manager::GetDiskSpaceInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_disk_space_info(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_default_output_directories : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_default_output_directories() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_get_default_output_directories() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_default_output_directories(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest* /*request*/, ::minknow_api::instance::OutputDirectories* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_default_output_directories(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_stream_disk_space_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_stream_disk_space_info() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_stream_disk_space_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stream_disk_space_info(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::StreamDiskSpaceInfoRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::manager::GetDiskSpaceInfoResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requeststream_disk_space_info(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(11, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_barcode_kit_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_barcode_kit_info() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_get_barcode_kit_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_barcode_kit_info(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetBarcodeKitInfoRequest* /*request*/, ::minknow_api::manager::GetBarcodeKitInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_barcode_kit_info(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_lamp_kit_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_lamp_kit_info() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_get_lamp_kit_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_lamp_kit_info(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetLampKitInfoRequest* /*request*/, ::minknow_api::manager::GetLampKitInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_lamp_kit_info(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_barcode_keys : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_barcode_keys() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_get_barcode_keys() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_barcode_keys(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetBarcodeKeysRequest* /*request*/, ::minknow_api::manager::GetBarcodeKeysResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_barcode_keys(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_flow_cell_types : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_flow_cell_types() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_get_flow_cell_types() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_flow_cell_types(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetFlowCellTypesRequest* /*request*/, ::minknow_api::manager::GetFlowCellTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_flow_cell_types(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_sequencing_kits : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_sequencing_kits() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_get_sequencing_kits() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_sequencing_kits(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetSequencingKitsRequest* /*request*/, ::minknow_api::manager::GetSequencingKitsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_sequencing_kits(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_add_simulated_device : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_add_simulated_device() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_add_simulated_device() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status add_simulated_device(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::AddSimulatedDeviceRequest* /*request*/, ::minknow_api::manager::AddSimulatedDeviceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestadd_simulated_device(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_remove_simulated_device : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_remove_simulated_device() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_remove_simulated_device() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status remove_simulated_device(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::RemoveSimulatedDeviceRequest* /*request*/, ::minknow_api::manager::RemoveSimulatedDeviceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestremove_simulated_device(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_local_authentication_token_path : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_local_authentication_token_path() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_local_authentication_token_path() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status local_authentication_token_path(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::LocalAuthenticationTokenPathRequest* /*request*/, ::minknow_api::manager::LocalAuthenticationTokenPathResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestlocal_authentication_token_path(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_alignment_reference_information : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_alignment_reference_information() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_get_alignment_reference_information() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_alignment_reference_information(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetAlignmentReferenceInformationRequest* /*request*/, ::minknow_api::manager::GetAlignmentReferenceInformationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_alignment_reference_information(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_association_device_code : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_association_device_code() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_association_device_code() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status association_device_code(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::AssociationDeviceCodeRequest* /*request*/, ::minknow_api::manager::AssociationDeviceCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestassociation_device_code(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_apply_offline_association_unlock_code : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_apply_offline_association_unlock_code() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_apply_offline_association_unlock_code() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status apply_offline_association_unlock_code(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeRequest* /*request*/, ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestapply_offline_association_unlock_code(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_list_developer_api_tokens : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_list_developer_api_tokens() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_list_developer_api_tokens() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status list_developer_api_tokens(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::ListDeveloperApiTokensRequest* /*request*/, ::minknow_api::manager::ListDeveloperApiTokensResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestlist_developer_api_tokens(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_create_developer_api_token : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_create_developer_api_token() {
      ::grpc::Service::MarkMethodRaw(24);
    }
    ~WithRawMethod_create_developer_api_token() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create_developer_api_token(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::CreateDeveloperApiTokenRequest* /*request*/, ::minknow_api::manager::CreateDeveloperApiTokenResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestcreate_developer_api_token(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_revoke_developer_api_token : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_revoke_developer_api_token() {
      ::grpc::Service::MarkMethodRaw(25);
    }
    ~WithRawMethod_revoke_developer_api_token() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status revoke_developer_api_token(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::RevokeDeveloperApiTokenRequest* /*request*/, ::minknow_api::manager::RevokeDeveloperApiTokensResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestrevoke_developer_api_token(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_find_protocols : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_find_protocols() {
      ::grpc::Service::MarkMethodRaw(26);
    }
    ~WithRawMethod_find_protocols() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status find_protocols(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::FindProtocolsRequest* /*request*/, ::minknow_api::manager::FindProtocolsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestfind_protocols(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_describe_host : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_describe_host() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->describe_host(context, request, response); }));
    }
    ~WithRawCallbackMethod_describe_host() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status describe_host(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::DescribeHostRequest* /*request*/, ::minknow_api::manager::DescribeHostResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* describe_host(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_flow_cell_positions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_flow_cell_positions() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->flow_cell_positions(context, request); }));
    }
    ~WithRawCallbackMethod_flow_cell_positions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status flow_cell_positions(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::FlowCellPositionsRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::manager::FlowCellPositionsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* flow_cell_positions(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_watch_flow_cell_positions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_watch_flow_cell_positions() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->watch_flow_cell_positions(context, request); }));
    }
    ~WithRawCallbackMethod_watch_flow_cell_positions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status watch_flow_cell_positions(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::WatchFlowCellPositionsRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::manager::WatchFlowCellPositionsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* watch_flow_cell_positions(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_reset_position : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_reset_position() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->reset_position(context, request, response); }));
    }
    ~WithRawCallbackMethod_reset_position() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status reset_position(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::ResetPositionRequest* /*request*/, ::minknow_api::manager::ResetPositionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* reset_position(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_basecaller_api : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_basecaller_api() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->basecaller_api(context, request, response); }));
    }
    ~WithRawCallbackMethod_basecaller_api() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status basecaller_api(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::BasecallerApiRequest* /*request*/, ::minknow_api::manager::BasecallerApiResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* basecaller_api(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_guppy_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_guppy_info() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_guppy_info(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_guppy_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_guppy_info(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetGuppyInfoRequest* /*request*/, ::minknow_api::manager::GetGuppyInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_guppy_info(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_version_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_version_info() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_version_info(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_version_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_version_info(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetVersionInfoRequest* /*request*/, ::minknow_api::manager::GetVersionInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_version_info(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_list_protocol_output_dir_files : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_list_protocol_output_dir_files() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->list_protocol_output_dir_files(context, request); }));
    }
    ~WithRawCallbackMethod_list_protocol_output_dir_files() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status list_protocol_output_dir_files(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::ListProtocolOutputDirFilesRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::manager::ListProtocolOutputDirFilesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* list_protocol_output_dir_files(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_create_directory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_create_directory() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->create_directory(context, request, response); }));
    }
    ~WithRawCallbackMethod_create_directory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create_directory(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::CreateDirectoryRequest* /*request*/, ::minknow_api::manager::CreateDirectoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* create_directory(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_disk_space_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_disk_space_info() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_disk_space_info(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_disk_space_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_disk_space_info(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetDiskSpaceInfoRequest* /*request*/, ::minknow_api::manager::GetDiskSpaceInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_disk_space_info(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_default_output_directories : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_default_output_directories() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_default_output_directories(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_default_output_directories() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_default_output_directories(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest* /*request*/, ::minknow_api::instance::OutputDirectories* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_default_output_directories(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_stream_disk_space_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_stream_disk_space_info() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->stream_disk_space_info(context, request); }));
    }
    ~WithRawCallbackMethod_stream_disk_space_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stream_disk_space_info(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::StreamDiskSpaceInfoRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::manager::GetDiskSpaceInfoResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* stream_disk_space_info(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_barcode_kit_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_barcode_kit_info() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_barcode_kit_info(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_barcode_kit_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_barcode_kit_info(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetBarcodeKitInfoRequest* /*request*/, ::minknow_api::manager::GetBarcodeKitInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_barcode_kit_info(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_lamp_kit_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_lamp_kit_info() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_lamp_kit_info(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_lamp_kit_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_lamp_kit_info(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetLampKitInfoRequest* /*request*/, ::minknow_api::manager::GetLampKitInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_lamp_kit_info(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_barcode_keys : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_barcode_keys() {
      ::grpc::Service::MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_barcode_keys(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_barcode_keys() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_barcode_keys(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetBarcodeKeysRequest* /*request*/, ::minknow_api::manager::GetBarcodeKeysResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_barcode_keys(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_flow_cell_types : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_flow_cell_types() {
      ::grpc::Service::MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_flow_cell_types(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_flow_cell_types() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_flow_cell_types(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetFlowCellTypesRequest* /*request*/, ::minknow_api::manager::GetFlowCellTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_flow_cell_types(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_sequencing_kits : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_sequencing_kits() {
      ::grpc::Service::MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_sequencing_kits(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_sequencing_kits() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_sequencing_kits(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetSequencingKitsRequest* /*request*/, ::minknow_api::manager::GetSequencingKitsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_sequencing_kits(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_add_simulated_device : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_add_simulated_device() {
      ::grpc::Service::MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->add_simulated_device(context, request, response); }));
    }
    ~WithRawCallbackMethod_add_simulated_device() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status add_simulated_device(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::AddSimulatedDeviceRequest* /*request*/, ::minknow_api::manager::AddSimulatedDeviceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* add_simulated_device(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_remove_simulated_device : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_remove_simulated_device() {
      ::grpc::Service::MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->remove_simulated_device(context, request, response); }));
    }
    ~WithRawCallbackMethod_remove_simulated_device() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status remove_simulated_device(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::RemoveSimulatedDeviceRequest* /*request*/, ::minknow_api::manager::RemoveSimulatedDeviceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* remove_simulated_device(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_local_authentication_token_path : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_local_authentication_token_path() {
      ::grpc::Service::MarkMethodRawCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->local_authentication_token_path(context, request, response); }));
    }
    ~WithRawCallbackMethod_local_authentication_token_path() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status local_authentication_token_path(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::LocalAuthenticationTokenPathRequest* /*request*/, ::minknow_api::manager::LocalAuthenticationTokenPathResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* local_authentication_token_path(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_alignment_reference_information : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_alignment_reference_information() {
      ::grpc::Service::MarkMethodRawCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_alignment_reference_information(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_alignment_reference_information() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_alignment_reference_information(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetAlignmentReferenceInformationRequest* /*request*/, ::minknow_api::manager::GetAlignmentReferenceInformationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_alignment_reference_information(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_association_device_code : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_association_device_code() {
      ::grpc::Service::MarkMethodRawCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->association_device_code(context, request, response); }));
    }
    ~WithRawCallbackMethod_association_device_code() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status association_device_code(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::AssociationDeviceCodeRequest* /*request*/, ::minknow_api::manager::AssociationDeviceCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* association_device_code(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_apply_offline_association_unlock_code : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_apply_offline_association_unlock_code() {
      ::grpc::Service::MarkMethodRawCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->apply_offline_association_unlock_code(context, request, response); }));
    }
    ~WithRawCallbackMethod_apply_offline_association_unlock_code() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status apply_offline_association_unlock_code(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeRequest* /*request*/, ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* apply_offline_association_unlock_code(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_list_developer_api_tokens : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_list_developer_api_tokens() {
      ::grpc::Service::MarkMethodRawCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->list_developer_api_tokens(context, request, response); }));
    }
    ~WithRawCallbackMethod_list_developer_api_tokens() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status list_developer_api_tokens(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::ListDeveloperApiTokensRequest* /*request*/, ::minknow_api::manager::ListDeveloperApiTokensResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* list_developer_api_tokens(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_create_developer_api_token : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_create_developer_api_token() {
      ::grpc::Service::MarkMethodRawCallback(24,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->create_developer_api_token(context, request, response); }));
    }
    ~WithRawCallbackMethod_create_developer_api_token() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create_developer_api_token(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::CreateDeveloperApiTokenRequest* /*request*/, ::minknow_api::manager::CreateDeveloperApiTokenResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* create_developer_api_token(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_revoke_developer_api_token : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_revoke_developer_api_token() {
      ::grpc::Service::MarkMethodRawCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->revoke_developer_api_token(context, request, response); }));
    }
    ~WithRawCallbackMethod_revoke_developer_api_token() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status revoke_developer_api_token(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::RevokeDeveloperApiTokenRequest* /*request*/, ::minknow_api::manager::RevokeDeveloperApiTokensResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* revoke_developer_api_token(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_find_protocols : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_find_protocols() {
      ::grpc::Service::MarkMethodRawCallback(26,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->find_protocols(context, request, response); }));
    }
    ~WithRawCallbackMethod_find_protocols() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status find_protocols(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::FindProtocolsRequest* /*request*/, ::minknow_api::manager::FindProtocolsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* find_protocols(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_describe_host : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_describe_host() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::manager::DescribeHostRequest, ::minknow_api::manager::DescribeHostResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::manager::DescribeHostRequest, ::minknow_api::manager::DescribeHostResponse>* streamer) {
                       return this->Streameddescribe_host(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_describe_host() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status describe_host(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::DescribeHostRequest* /*request*/, ::minknow_api::manager::DescribeHostResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streameddescribe_host(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::manager::DescribeHostRequest,::minknow_api::manager::DescribeHostResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_reset_position : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_reset_position() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::manager::ResetPositionRequest, ::minknow_api::manager::ResetPositionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::manager::ResetPositionRequest, ::minknow_api::manager::ResetPositionResponse>* streamer) {
                       return this->Streamedreset_position(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_reset_position() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status reset_position(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::ResetPositionRequest* /*request*/, ::minknow_api::manager::ResetPositionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedreset_position(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::manager::ResetPositionRequest,::minknow_api::manager::ResetPositionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_basecaller_api : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_basecaller_api() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::manager::BasecallerApiRequest, ::minknow_api::manager::BasecallerApiResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::manager::BasecallerApiRequest, ::minknow_api::manager::BasecallerApiResponse>* streamer) {
                       return this->Streamedbasecaller_api(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_basecaller_api() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status basecaller_api(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::BasecallerApiRequest* /*request*/, ::minknow_api::manager::BasecallerApiResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedbasecaller_api(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::manager::BasecallerApiRequest,::minknow_api::manager::BasecallerApiResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_guppy_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_guppy_info() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::manager::GetGuppyInfoRequest, ::minknow_api::manager::GetGuppyInfoResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::manager::GetGuppyInfoRequest, ::minknow_api::manager::GetGuppyInfoResponse>* streamer) {
                       return this->Streamedget_guppy_info(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_guppy_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_guppy_info(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetGuppyInfoRequest* /*request*/, ::minknow_api::manager::GetGuppyInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_guppy_info(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::manager::GetGuppyInfoRequest,::minknow_api::manager::GetGuppyInfoResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_version_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_version_info() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::manager::GetVersionInfoRequest, ::minknow_api::manager::GetVersionInfoResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::manager::GetVersionInfoRequest, ::minknow_api::manager::GetVersionInfoResponse>* streamer) {
                       return this->Streamedget_version_info(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_version_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_version_info(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetVersionInfoRequest* /*request*/, ::minknow_api::manager::GetVersionInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_version_info(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::manager::GetVersionInfoRequest,::minknow_api::manager::GetVersionInfoResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_create_directory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_create_directory() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::manager::CreateDirectoryRequest, ::minknow_api::manager::CreateDirectoryResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::manager::CreateDirectoryRequest, ::minknow_api::manager::CreateDirectoryResponse>* streamer) {
                       return this->Streamedcreate_directory(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_create_directory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status create_directory(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::CreateDirectoryRequest* /*request*/, ::minknow_api::manager::CreateDirectoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedcreate_directory(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::manager::CreateDirectoryRequest,::minknow_api::manager::CreateDirectoryResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_disk_space_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_disk_space_info() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::manager::GetDiskSpaceInfoRequest, ::minknow_api::manager::GetDiskSpaceInfoResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::manager::GetDiskSpaceInfoRequest, ::minknow_api::manager::GetDiskSpaceInfoResponse>* streamer) {
                       return this->Streamedget_disk_space_info(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_disk_space_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_disk_space_info(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetDiskSpaceInfoRequest* /*request*/, ::minknow_api::manager::GetDiskSpaceInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_disk_space_info(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::manager::GetDiskSpaceInfoRequest,::minknow_api::manager::GetDiskSpaceInfoResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_default_output_directories : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_default_output_directories() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::instance::GetDefaultOutputDirectoriesRequest, ::minknow_api::instance::OutputDirectories>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::instance::GetDefaultOutputDirectoriesRequest, ::minknow_api::instance::OutputDirectories>* streamer) {
                       return this->Streamedget_default_output_directories(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_default_output_directories() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_default_output_directories(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest* /*request*/, ::minknow_api::instance::OutputDirectories* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_default_output_directories(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::instance::GetDefaultOutputDirectoriesRequest,::minknow_api::instance::OutputDirectories>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_barcode_kit_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_barcode_kit_info() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::manager::GetBarcodeKitInfoRequest, ::minknow_api::manager::GetBarcodeKitInfoResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::manager::GetBarcodeKitInfoRequest, ::minknow_api::manager::GetBarcodeKitInfoResponse>* streamer) {
                       return this->Streamedget_barcode_kit_info(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_barcode_kit_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_barcode_kit_info(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetBarcodeKitInfoRequest* /*request*/, ::minknow_api::manager::GetBarcodeKitInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_barcode_kit_info(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::manager::GetBarcodeKitInfoRequest,::minknow_api::manager::GetBarcodeKitInfoResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_lamp_kit_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_lamp_kit_info() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::manager::GetLampKitInfoRequest, ::minknow_api::manager::GetLampKitInfoResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::manager::GetLampKitInfoRequest, ::minknow_api::manager::GetLampKitInfoResponse>* streamer) {
                       return this->Streamedget_lamp_kit_info(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_lamp_kit_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_lamp_kit_info(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetLampKitInfoRequest* /*request*/, ::minknow_api::manager::GetLampKitInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_lamp_kit_info(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::manager::GetLampKitInfoRequest,::minknow_api::manager::GetLampKitInfoResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_barcode_keys : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_barcode_keys() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::manager::GetBarcodeKeysRequest, ::minknow_api::manager::GetBarcodeKeysResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::manager::GetBarcodeKeysRequest, ::minknow_api::manager::GetBarcodeKeysResponse>* streamer) {
                       return this->Streamedget_barcode_keys(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_barcode_keys() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_barcode_keys(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetBarcodeKeysRequest* /*request*/, ::minknow_api::manager::GetBarcodeKeysResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_barcode_keys(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::manager::GetBarcodeKeysRequest,::minknow_api::manager::GetBarcodeKeysResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_flow_cell_types : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_flow_cell_types() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::manager::GetFlowCellTypesRequest, ::minknow_api::manager::GetFlowCellTypesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::manager::GetFlowCellTypesRequest, ::minknow_api::manager::GetFlowCellTypesResponse>* streamer) {
                       return this->Streamedget_flow_cell_types(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_flow_cell_types() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_flow_cell_types(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetFlowCellTypesRequest* /*request*/, ::minknow_api::manager::GetFlowCellTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_flow_cell_types(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::manager::GetFlowCellTypesRequest,::minknow_api::manager::GetFlowCellTypesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_sequencing_kits : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_sequencing_kits() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::manager::GetSequencingKitsRequest, ::minknow_api::manager::GetSequencingKitsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::manager::GetSequencingKitsRequest, ::minknow_api::manager::GetSequencingKitsResponse>* streamer) {
                       return this->Streamedget_sequencing_kits(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_sequencing_kits() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_sequencing_kits(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetSequencingKitsRequest* /*request*/, ::minknow_api::manager::GetSequencingKitsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_sequencing_kits(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::manager::GetSequencingKitsRequest,::minknow_api::manager::GetSequencingKitsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_add_simulated_device : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_add_simulated_device() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::manager::AddSimulatedDeviceRequest, ::minknow_api::manager::AddSimulatedDeviceResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::manager::AddSimulatedDeviceRequest, ::minknow_api::manager::AddSimulatedDeviceResponse>* streamer) {
                       return this->Streamedadd_simulated_device(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_add_simulated_device() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status add_simulated_device(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::AddSimulatedDeviceRequest* /*request*/, ::minknow_api::manager::AddSimulatedDeviceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedadd_simulated_device(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::manager::AddSimulatedDeviceRequest,::minknow_api::manager::AddSimulatedDeviceResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_remove_simulated_device : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_remove_simulated_device() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::manager::RemoveSimulatedDeviceRequest, ::minknow_api::manager::RemoveSimulatedDeviceResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::manager::RemoveSimulatedDeviceRequest, ::minknow_api::manager::RemoveSimulatedDeviceResponse>* streamer) {
                       return this->Streamedremove_simulated_device(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_remove_simulated_device() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status remove_simulated_device(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::RemoveSimulatedDeviceRequest* /*request*/, ::minknow_api::manager::RemoveSimulatedDeviceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedremove_simulated_device(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::manager::RemoveSimulatedDeviceRequest,::minknow_api::manager::RemoveSimulatedDeviceResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_local_authentication_token_path : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_local_authentication_token_path() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::manager::LocalAuthenticationTokenPathRequest, ::minknow_api::manager::LocalAuthenticationTokenPathResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::manager::LocalAuthenticationTokenPathRequest, ::minknow_api::manager::LocalAuthenticationTokenPathResponse>* streamer) {
                       return this->Streamedlocal_authentication_token_path(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_local_authentication_token_path() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status local_authentication_token_path(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::LocalAuthenticationTokenPathRequest* /*request*/, ::minknow_api::manager::LocalAuthenticationTokenPathResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedlocal_authentication_token_path(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::manager::LocalAuthenticationTokenPathRequest,::minknow_api::manager::LocalAuthenticationTokenPathResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_alignment_reference_information : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_alignment_reference_information() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::manager::GetAlignmentReferenceInformationRequest, ::minknow_api::manager::GetAlignmentReferenceInformationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::manager::GetAlignmentReferenceInformationRequest, ::minknow_api::manager::GetAlignmentReferenceInformationResponse>* streamer) {
                       return this->Streamedget_alignment_reference_information(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_alignment_reference_information() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_alignment_reference_information(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::GetAlignmentReferenceInformationRequest* /*request*/, ::minknow_api::manager::GetAlignmentReferenceInformationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_alignment_reference_information(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::manager::GetAlignmentReferenceInformationRequest,::minknow_api::manager::GetAlignmentReferenceInformationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_association_device_code : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_association_device_code() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::manager::AssociationDeviceCodeRequest, ::minknow_api::manager::AssociationDeviceCodeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::manager::AssociationDeviceCodeRequest, ::minknow_api::manager::AssociationDeviceCodeResponse>* streamer) {
                       return this->Streamedassociation_device_code(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_association_device_code() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status association_device_code(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::AssociationDeviceCodeRequest* /*request*/, ::minknow_api::manager::AssociationDeviceCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedassociation_device_code(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::manager::AssociationDeviceCodeRequest,::minknow_api::manager::AssociationDeviceCodeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_apply_offline_association_unlock_code : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_apply_offline_association_unlock_code() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeRequest, ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeRequest, ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeResponse>* streamer) {
                       return this->Streamedapply_offline_association_unlock_code(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_apply_offline_association_unlock_code() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status apply_offline_association_unlock_code(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeRequest* /*request*/, ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedapply_offline_association_unlock_code(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeRequest,::minknow_api::manager::ApplyOfflineAssociationUnlockCodeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_list_developer_api_tokens : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_list_developer_api_tokens() {
      ::grpc::Service::MarkMethodStreamed(23,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::manager::ListDeveloperApiTokensRequest, ::minknow_api::manager::ListDeveloperApiTokensResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::manager::ListDeveloperApiTokensRequest, ::minknow_api::manager::ListDeveloperApiTokensResponse>* streamer) {
                       return this->Streamedlist_developer_api_tokens(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_list_developer_api_tokens() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status list_developer_api_tokens(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::ListDeveloperApiTokensRequest* /*request*/, ::minknow_api::manager::ListDeveloperApiTokensResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedlist_developer_api_tokens(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::manager::ListDeveloperApiTokensRequest,::minknow_api::manager::ListDeveloperApiTokensResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_create_developer_api_token : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_create_developer_api_token() {
      ::grpc::Service::MarkMethodStreamed(24,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::manager::CreateDeveloperApiTokenRequest, ::minknow_api::manager::CreateDeveloperApiTokenResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::manager::CreateDeveloperApiTokenRequest, ::minknow_api::manager::CreateDeveloperApiTokenResponse>* streamer) {
                       return this->Streamedcreate_developer_api_token(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_create_developer_api_token() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status create_developer_api_token(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::CreateDeveloperApiTokenRequest* /*request*/, ::minknow_api::manager::CreateDeveloperApiTokenResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedcreate_developer_api_token(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::manager::CreateDeveloperApiTokenRequest,::minknow_api::manager::CreateDeveloperApiTokenResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_revoke_developer_api_token : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_revoke_developer_api_token() {
      ::grpc::Service::MarkMethodStreamed(25,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::manager::RevokeDeveloperApiTokenRequest, ::minknow_api::manager::RevokeDeveloperApiTokensResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::manager::RevokeDeveloperApiTokenRequest, ::minknow_api::manager::RevokeDeveloperApiTokensResponse>* streamer) {
                       return this->Streamedrevoke_developer_api_token(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_revoke_developer_api_token() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status revoke_developer_api_token(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::RevokeDeveloperApiTokenRequest* /*request*/, ::minknow_api::manager::RevokeDeveloperApiTokensResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedrevoke_developer_api_token(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::manager::RevokeDeveloperApiTokenRequest,::minknow_api::manager::RevokeDeveloperApiTokensResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_find_protocols : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_find_protocols() {
      ::grpc::Service::MarkMethodStreamed(26,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::manager::FindProtocolsRequest, ::minknow_api::manager::FindProtocolsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::manager::FindProtocolsRequest, ::minknow_api::manager::FindProtocolsResponse>* streamer) {
                       return this->Streamedfind_protocols(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_find_protocols() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status find_protocols(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::FindProtocolsRequest* /*request*/, ::minknow_api::manager::FindProtocolsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedfind_protocols(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::manager::FindProtocolsRequest,::minknow_api::manager::FindProtocolsResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_describe_host<WithStreamedUnaryMethod_reset_position<WithStreamedUnaryMethod_basecaller_api<WithStreamedUnaryMethod_get_guppy_info<WithStreamedUnaryMethod_get_version_info<WithStreamedUnaryMethod_create_directory<WithStreamedUnaryMethod_get_disk_space_info<WithStreamedUnaryMethod_get_default_output_directories<WithStreamedUnaryMethod_get_barcode_kit_info<WithStreamedUnaryMethod_get_lamp_kit_info<WithStreamedUnaryMethod_get_barcode_keys<WithStreamedUnaryMethod_get_flow_cell_types<WithStreamedUnaryMethod_get_sequencing_kits<WithStreamedUnaryMethod_add_simulated_device<WithStreamedUnaryMethod_remove_simulated_device<WithStreamedUnaryMethod_local_authentication_token_path<WithStreamedUnaryMethod_get_alignment_reference_information<WithStreamedUnaryMethod_association_device_code<WithStreamedUnaryMethod_apply_offline_association_unlock_code<WithStreamedUnaryMethod_list_developer_api_tokens<WithStreamedUnaryMethod_create_developer_api_token<WithStreamedUnaryMethod_revoke_developer_api_token<WithStreamedUnaryMethod_find_protocols<Service > > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_flow_cell_positions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_flow_cell_positions() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::minknow_api::manager::FlowCellPositionsRequest, ::minknow_api::manager::FlowCellPositionsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::minknow_api::manager::FlowCellPositionsRequest, ::minknow_api::manager::FlowCellPositionsResponse>* streamer) {
                       return this->Streamedflow_cell_positions(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_flow_cell_positions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status flow_cell_positions(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::FlowCellPositionsRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::manager::FlowCellPositionsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status Streamedflow_cell_positions(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::minknow_api::manager::FlowCellPositionsRequest,::minknow_api::manager::FlowCellPositionsResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_watch_flow_cell_positions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_watch_flow_cell_positions() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::minknow_api::manager::WatchFlowCellPositionsRequest, ::minknow_api::manager::WatchFlowCellPositionsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::minknow_api::manager::WatchFlowCellPositionsRequest, ::minknow_api::manager::WatchFlowCellPositionsResponse>* streamer) {
                       return this->Streamedwatch_flow_cell_positions(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_watch_flow_cell_positions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status watch_flow_cell_positions(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::WatchFlowCellPositionsRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::manager::WatchFlowCellPositionsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status Streamedwatch_flow_cell_positions(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::minknow_api::manager::WatchFlowCellPositionsRequest,::minknow_api::manager::WatchFlowCellPositionsResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_list_protocol_output_dir_files : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_list_protocol_output_dir_files() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::minknow_api::manager::ListProtocolOutputDirFilesRequest, ::minknow_api::manager::ListProtocolOutputDirFilesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::minknow_api::manager::ListProtocolOutputDirFilesRequest, ::minknow_api::manager::ListProtocolOutputDirFilesResponse>* streamer) {
                       return this->Streamedlist_protocol_output_dir_files(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_list_protocol_output_dir_files() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status list_protocol_output_dir_files(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::ListProtocolOutputDirFilesRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::manager::ListProtocolOutputDirFilesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status Streamedlist_protocol_output_dir_files(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::minknow_api::manager::ListProtocolOutputDirFilesRequest,::minknow_api::manager::ListProtocolOutputDirFilesResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_stream_disk_space_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_stream_disk_space_info() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::minknow_api::manager::StreamDiskSpaceInfoRequest, ::minknow_api::manager::GetDiskSpaceInfoResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::minknow_api::manager::StreamDiskSpaceInfoRequest, ::minknow_api::manager::GetDiskSpaceInfoResponse>* streamer) {
                       return this->Streamedstream_disk_space_info(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_stream_disk_space_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status stream_disk_space_info(::grpc::ServerContext* /*context*/, const ::minknow_api::manager::StreamDiskSpaceInfoRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::manager::GetDiskSpaceInfoResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status Streamedstream_disk_space_info(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::minknow_api::manager::StreamDiskSpaceInfoRequest,::minknow_api::manager::GetDiskSpaceInfoResponse>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_flow_cell_positions<WithSplitStreamingMethod_watch_flow_cell_positions<WithSplitStreamingMethod_list_protocol_output_dir_files<WithSplitStreamingMethod_stream_disk_space_info<Service > > > > SplitStreamedService;
  typedef WithStreamedUnaryMethod_describe_host<WithSplitStreamingMethod_flow_cell_positions<WithSplitStreamingMethod_watch_flow_cell_positions<WithStreamedUnaryMethod_reset_position<WithStreamedUnaryMethod_basecaller_api<WithStreamedUnaryMethod_get_guppy_info<WithStreamedUnaryMethod_get_version_info<WithSplitStreamingMethod_list_protocol_output_dir_files<WithStreamedUnaryMethod_create_directory<WithStreamedUnaryMethod_get_disk_space_info<WithStreamedUnaryMethod_get_default_output_directories<WithSplitStreamingMethod_stream_disk_space_info<WithStreamedUnaryMethod_get_barcode_kit_info<WithStreamedUnaryMethod_get_lamp_kit_info<WithStreamedUnaryMethod_get_barcode_keys<WithStreamedUnaryMethod_get_flow_cell_types<WithStreamedUnaryMethod_get_sequencing_kits<WithStreamedUnaryMethod_add_simulated_device<WithStreamedUnaryMethod_remove_simulated_device<WithStreamedUnaryMethod_local_authentication_token_path<WithStreamedUnaryMethod_get_alignment_reference_information<WithStreamedUnaryMethod_association_device_code<WithStreamedUnaryMethod_apply_offline_association_unlock_code<WithStreamedUnaryMethod_list_developer_api_tokens<WithStreamedUnaryMethod_create_developer_api_token<WithStreamedUnaryMethod_revoke_developer_api_token<WithStreamedUnaryMethod_find_protocols<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace manager
}  // namespace minknow_api


#endif  // GRPC_minknow_5fapi_2fmanager_2eproto__INCLUDED
