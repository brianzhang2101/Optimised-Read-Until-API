// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: minknow_api/instance.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_minknow_5fapi_2finstance_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_minknow_5fapi_2finstance_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "minknow_api/acquisition.pb.h"
#include "minknow_api/device.pb.h"
#include "minknow_api/protocol.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_minknow_5fapi_2finstance_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_minknow_5fapi_2finstance_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[23]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_minknow_5fapi_2finstance_2eproto;
namespace minknow_api {
namespace instance {
class BasecallSpeed;
struct BasecallSpeedDefaultTypeInternal;
extern BasecallSpeedDefaultTypeInternal _BasecallSpeed_default_instance_;
class DeviceInfo;
struct DeviceInfoDefaultTypeInternal;
extern DeviceInfoDefaultTypeInternal _DeviceInfo_default_instance_;
class FilesystemDiskSpaceInfo;
struct FilesystemDiskSpaceInfoDefaultTypeInternal;
extern FilesystemDiskSpaceInfoDefaultTypeInternal _FilesystemDiskSpaceInfo_default_instance_;
class GetDefaultOutputDirectoriesRequest;
struct GetDefaultOutputDirectoriesRequestDefaultTypeInternal;
extern GetDefaultOutputDirectoriesRequestDefaultTypeInternal _GetDefaultOutputDirectoriesRequest_default_instance_;
class GetDiskSpaceInfoRequest;
struct GetDiskSpaceInfoRequestDefaultTypeInternal;
extern GetDiskSpaceInfoRequestDefaultTypeInternal _GetDiskSpaceInfoRequest_default_instance_;
class GetDiskSpaceInfoResponse;
struct GetDiskSpaceInfoResponseDefaultTypeInternal;
extern GetDiskSpaceInfoResponseDefaultTypeInternal _GetDiskSpaceInfoResponse_default_instance_;
class GetMachineIdRequest;
struct GetMachineIdRequestDefaultTypeInternal;
extern GetMachineIdRequestDefaultTypeInternal _GetMachineIdRequest_default_instance_;
class GetMachineIdResponse;
struct GetMachineIdResponseDefaultTypeInternal;
extern GetMachineIdResponseDefaultTypeInternal _GetMachineIdResponse_default_instance_;
class GetOutputDirectoriesRequest;
struct GetOutputDirectoriesRequestDefaultTypeInternal;
extern GetOutputDirectoriesRequestDefaultTypeInternal _GetOutputDirectoriesRequest_default_instance_;
class GetVersionInfoRequest;
struct GetVersionInfoRequestDefaultTypeInternal;
extern GetVersionInfoRequestDefaultTypeInternal _GetVersionInfoRequest_default_instance_;
class GetVersionInfoResponse;
struct GetVersionInfoResponseDefaultTypeInternal;
extern GetVersionInfoResponseDefaultTypeInternal _GetVersionInfoResponse_default_instance_;
class GetVersionInfoResponse_MinknowVersion;
struct GetVersionInfoResponse_MinknowVersionDefaultTypeInternal;
extern GetVersionInfoResponse_MinknowVersionDefaultTypeInternal _GetVersionInfoResponse_MinknowVersion_default_instance_;
class N50;
struct N50DefaultTypeInternal;
extern N50DefaultTypeInternal _N50_default_instance_;
class OutputDirectories;
struct OutputDirectoriesDefaultTypeInternal;
extern OutputDirectoriesDefaultTypeInternal _OutputDirectories_default_instance_;
class SetOutputDirectoryRequest;
struct SetOutputDirectoryRequestDefaultTypeInternal;
extern SetOutputDirectoryRequestDefaultTypeInternal _SetOutputDirectoryRequest_default_instance_;
class SetOutputDirectoryResponse;
struct SetOutputDirectoryResponseDefaultTypeInternal;
extern SetOutputDirectoryResponseDefaultTypeInternal _SetOutputDirectoryResponse_default_instance_;
class SetReadsDirectoryRequest;
struct SetReadsDirectoryRequestDefaultTypeInternal;
extern SetReadsDirectoryRequestDefaultTypeInternal _SetReadsDirectoryRequest_default_instance_;
class SetReadsDirectoryResponse;
struct SetReadsDirectoryResponseDefaultTypeInternal;
extern SetReadsDirectoryResponseDefaultTypeInternal _SetReadsDirectoryResponse_default_instance_;
class StreamDiskSpaceInfoRequest;
struct StreamDiskSpaceInfoRequestDefaultTypeInternal;
extern StreamDiskSpaceInfoRequestDefaultTypeInternal _StreamDiskSpaceInfoRequest_default_instance_;
class StreamInstanceActivityRequest;
struct StreamInstanceActivityRequestDefaultTypeInternal;
extern StreamInstanceActivityRequestDefaultTypeInternal _StreamInstanceActivityRequest_default_instance_;
class StreamInstanceActivityResponse;
struct StreamInstanceActivityResponseDefaultTypeInternal;
extern StreamInstanceActivityResponseDefaultTypeInternal _StreamInstanceActivityResponse_default_instance_;
class StreamInstanceActivityResponse_FlowCellHealth;
struct StreamInstanceActivityResponse_FlowCellHealthDefaultTypeInternal;
extern StreamInstanceActivityResponse_FlowCellHealthDefaultTypeInternal _StreamInstanceActivityResponse_FlowCellHealth_default_instance_;
class StreamInstanceActivityResponse_FlowCellHealth_ChannelStatePercentagesEntry_DoNotUse;
struct StreamInstanceActivityResponse_FlowCellHealth_ChannelStatePercentagesEntry_DoNotUseDefaultTypeInternal;
extern StreamInstanceActivityResponse_FlowCellHealth_ChannelStatePercentagesEntry_DoNotUseDefaultTypeInternal _StreamInstanceActivityResponse_FlowCellHealth_ChannelStatePercentagesEntry_DoNotUse_default_instance_;
}  // namespace instance
}  // namespace minknow_api
PROTOBUF_NAMESPACE_OPEN
template<> ::minknow_api::instance::BasecallSpeed* Arena::CreateMaybeMessage<::minknow_api::instance::BasecallSpeed>(Arena*);
template<> ::minknow_api::instance::DeviceInfo* Arena::CreateMaybeMessage<::minknow_api::instance::DeviceInfo>(Arena*);
template<> ::minknow_api::instance::FilesystemDiskSpaceInfo* Arena::CreateMaybeMessage<::minknow_api::instance::FilesystemDiskSpaceInfo>(Arena*);
template<> ::minknow_api::instance::GetDefaultOutputDirectoriesRequest* Arena::CreateMaybeMessage<::minknow_api::instance::GetDefaultOutputDirectoriesRequest>(Arena*);
template<> ::minknow_api::instance::GetDiskSpaceInfoRequest* Arena::CreateMaybeMessage<::minknow_api::instance::GetDiskSpaceInfoRequest>(Arena*);
template<> ::minknow_api::instance::GetDiskSpaceInfoResponse* Arena::CreateMaybeMessage<::minknow_api::instance::GetDiskSpaceInfoResponse>(Arena*);
template<> ::minknow_api::instance::GetMachineIdRequest* Arena::CreateMaybeMessage<::minknow_api::instance::GetMachineIdRequest>(Arena*);
template<> ::minknow_api::instance::GetMachineIdResponse* Arena::CreateMaybeMessage<::minknow_api::instance::GetMachineIdResponse>(Arena*);
template<> ::minknow_api::instance::GetOutputDirectoriesRequest* Arena::CreateMaybeMessage<::minknow_api::instance::GetOutputDirectoriesRequest>(Arena*);
template<> ::minknow_api::instance::GetVersionInfoRequest* Arena::CreateMaybeMessage<::minknow_api::instance::GetVersionInfoRequest>(Arena*);
template<> ::minknow_api::instance::GetVersionInfoResponse* Arena::CreateMaybeMessage<::minknow_api::instance::GetVersionInfoResponse>(Arena*);
template<> ::minknow_api::instance::GetVersionInfoResponse_MinknowVersion* Arena::CreateMaybeMessage<::minknow_api::instance::GetVersionInfoResponse_MinknowVersion>(Arena*);
template<> ::minknow_api::instance::N50* Arena::CreateMaybeMessage<::minknow_api::instance::N50>(Arena*);
template<> ::minknow_api::instance::OutputDirectories* Arena::CreateMaybeMessage<::minknow_api::instance::OutputDirectories>(Arena*);
template<> ::minknow_api::instance::SetOutputDirectoryRequest* Arena::CreateMaybeMessage<::minknow_api::instance::SetOutputDirectoryRequest>(Arena*);
template<> ::minknow_api::instance::SetOutputDirectoryResponse* Arena::CreateMaybeMessage<::minknow_api::instance::SetOutputDirectoryResponse>(Arena*);
template<> ::minknow_api::instance::SetReadsDirectoryRequest* Arena::CreateMaybeMessage<::minknow_api::instance::SetReadsDirectoryRequest>(Arena*);
template<> ::minknow_api::instance::SetReadsDirectoryResponse* Arena::CreateMaybeMessage<::minknow_api::instance::SetReadsDirectoryResponse>(Arena*);
template<> ::minknow_api::instance::StreamDiskSpaceInfoRequest* Arena::CreateMaybeMessage<::minknow_api::instance::StreamDiskSpaceInfoRequest>(Arena*);
template<> ::minknow_api::instance::StreamInstanceActivityRequest* Arena::CreateMaybeMessage<::minknow_api::instance::StreamInstanceActivityRequest>(Arena*);
template<> ::minknow_api::instance::StreamInstanceActivityResponse* Arena::CreateMaybeMessage<::minknow_api::instance::StreamInstanceActivityResponse>(Arena*);
template<> ::minknow_api::instance::StreamInstanceActivityResponse_FlowCellHealth* Arena::CreateMaybeMessage<::minknow_api::instance::StreamInstanceActivityResponse_FlowCellHealth>(Arena*);
template<> ::minknow_api::instance::StreamInstanceActivityResponse_FlowCellHealth_ChannelStatePercentagesEntry_DoNotUse* Arena::CreateMaybeMessage<::minknow_api::instance::StreamInstanceActivityResponse_FlowCellHealth_ChannelStatePercentagesEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace minknow_api {
namespace instance {

enum GetVersionInfoResponse_DistributionStatus : int {
  GetVersionInfoResponse_DistributionStatus_UNKNOWN = 0,
  GetVersionInfoResponse_DistributionStatus_STABLE = 1,
  GetVersionInfoResponse_DistributionStatus_UNSTABLE = 2,
  GetVersionInfoResponse_DistributionStatus_MODIFIED = 3,
  GetVersionInfoResponse_DistributionStatus_GetVersionInfoResponse_DistributionStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  GetVersionInfoResponse_DistributionStatus_GetVersionInfoResponse_DistributionStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool GetVersionInfoResponse_DistributionStatus_IsValid(int value);
constexpr GetVersionInfoResponse_DistributionStatus GetVersionInfoResponse_DistributionStatus_DistributionStatus_MIN = GetVersionInfoResponse_DistributionStatus_UNKNOWN;
constexpr GetVersionInfoResponse_DistributionStatus GetVersionInfoResponse_DistributionStatus_DistributionStatus_MAX = GetVersionInfoResponse_DistributionStatus_MODIFIED;
constexpr int GetVersionInfoResponse_DistributionStatus_DistributionStatus_ARRAYSIZE = GetVersionInfoResponse_DistributionStatus_DistributionStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GetVersionInfoResponse_DistributionStatus_descriptor();
template<typename T>
inline const std::string& GetVersionInfoResponse_DistributionStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GetVersionInfoResponse_DistributionStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GetVersionInfoResponse_DistributionStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GetVersionInfoResponse_DistributionStatus_descriptor(), enum_t_value);
}
inline bool GetVersionInfoResponse_DistributionStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GetVersionInfoResponse_DistributionStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GetVersionInfoResponse_DistributionStatus>(
    GetVersionInfoResponse_DistributionStatus_descriptor(), name, value);
}
enum GetVersionInfoResponse_InstallationType : int {
  GetVersionInfoResponse_InstallationType_ONT = 0,
  GetVersionInfoResponse_InstallationType_NC = 1,
  GetVersionInfoResponse_InstallationType_PROD = 2,
  GetVersionInfoResponse_InstallationType_Q_RELEASE = 3,
  GetVersionInfoResponse_InstallationType_OND_RELEASE = 4,
  GetVersionInfoResponse_InstallationType_GetVersionInfoResponse_InstallationType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  GetVersionInfoResponse_InstallationType_GetVersionInfoResponse_InstallationType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool GetVersionInfoResponse_InstallationType_IsValid(int value);
constexpr GetVersionInfoResponse_InstallationType GetVersionInfoResponse_InstallationType_InstallationType_MIN = GetVersionInfoResponse_InstallationType_ONT;
constexpr GetVersionInfoResponse_InstallationType GetVersionInfoResponse_InstallationType_InstallationType_MAX = GetVersionInfoResponse_InstallationType_OND_RELEASE;
constexpr int GetVersionInfoResponse_InstallationType_InstallationType_ARRAYSIZE = GetVersionInfoResponse_InstallationType_InstallationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GetVersionInfoResponse_InstallationType_descriptor();
template<typename T>
inline const std::string& GetVersionInfoResponse_InstallationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GetVersionInfoResponse_InstallationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GetVersionInfoResponse_InstallationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GetVersionInfoResponse_InstallationType_descriptor(), enum_t_value);
}
inline bool GetVersionInfoResponse_InstallationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GetVersionInfoResponse_InstallationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GetVersionInfoResponse_InstallationType>(
    GetVersionInfoResponse_InstallationType_descriptor(), name, value);
}
// ===================================================================

class GetVersionInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:minknow_api.instance.GetVersionInfoRequest) */ {
 public:
  inline GetVersionInfoRequest() : GetVersionInfoRequest(nullptr) {}
  explicit constexpr GetVersionInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetVersionInfoRequest(const GetVersionInfoRequest& from);
  GetVersionInfoRequest(GetVersionInfoRequest&& from) noexcept
    : GetVersionInfoRequest() {
    *this = ::std::move(from);
  }

  inline GetVersionInfoRequest& operator=(const GetVersionInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetVersionInfoRequest& operator=(GetVersionInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetVersionInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetVersionInfoRequest* internal_default_instance() {
    return reinterpret_cast<const GetVersionInfoRequest*>(
               &_GetVersionInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GetVersionInfoRequest& a, GetVersionInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetVersionInfoRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetVersionInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetVersionInfoRequest* New() const final {
    return new GetVersionInfoRequest();
  }

  GetVersionInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetVersionInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetVersionInfoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetVersionInfoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.instance.GetVersionInfoRequest";
  }
  protected:
  explicit GetVersionInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:minknow_api.instance.GetVersionInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2finstance_2eproto;
};
// -------------------------------------------------------------------

class GetVersionInfoResponse_MinknowVersion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.instance.GetVersionInfoResponse.MinknowVersion) */ {
 public:
  inline GetVersionInfoResponse_MinknowVersion() : GetVersionInfoResponse_MinknowVersion(nullptr) {}
  ~GetVersionInfoResponse_MinknowVersion() override;
  explicit constexpr GetVersionInfoResponse_MinknowVersion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetVersionInfoResponse_MinknowVersion(const GetVersionInfoResponse_MinknowVersion& from);
  GetVersionInfoResponse_MinknowVersion(GetVersionInfoResponse_MinknowVersion&& from) noexcept
    : GetVersionInfoResponse_MinknowVersion() {
    *this = ::std::move(from);
  }

  inline GetVersionInfoResponse_MinknowVersion& operator=(const GetVersionInfoResponse_MinknowVersion& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetVersionInfoResponse_MinknowVersion& operator=(GetVersionInfoResponse_MinknowVersion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetVersionInfoResponse_MinknowVersion& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetVersionInfoResponse_MinknowVersion* internal_default_instance() {
    return reinterpret_cast<const GetVersionInfoResponse_MinknowVersion*>(
               &_GetVersionInfoResponse_MinknowVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GetVersionInfoResponse_MinknowVersion& a, GetVersionInfoResponse_MinknowVersion& b) {
    a.Swap(&b);
  }
  inline void Swap(GetVersionInfoResponse_MinknowVersion* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetVersionInfoResponse_MinknowVersion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetVersionInfoResponse_MinknowVersion* New() const final {
    return new GetVersionInfoResponse_MinknowVersion();
  }

  GetVersionInfoResponse_MinknowVersion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetVersionInfoResponse_MinknowVersion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetVersionInfoResponse_MinknowVersion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetVersionInfoResponse_MinknowVersion& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetVersionInfoResponse_MinknowVersion* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.instance.GetVersionInfoResponse.MinknowVersion";
  }
  protected:
  explicit GetVersionInfoResponse_MinknowVersion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFullFieldNumber = 4,
    kMajorFieldNumber = 1,
    kMinorFieldNumber = 2,
    kPatchFieldNumber = 3,
  };
  // string full = 4;
  void clear_full();
  const std::string& full() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_full(ArgT0&& arg0, ArgT... args);
  std::string* mutable_full();
  PROTOBUF_MUST_USE_RESULT std::string* release_full();
  void set_allocated_full(std::string* full);
  private:
  const std::string& _internal_full() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_full(const std::string& value);
  std::string* _internal_mutable_full();
  public:

  // int32 major = 1;
  void clear_major();
  ::PROTOBUF_NAMESPACE_ID::int32 major() const;
  void set_major(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_major() const;
  void _internal_set_major(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 minor = 2;
  void clear_minor();
  ::PROTOBUF_NAMESPACE_ID::int32 minor() const;
  void set_minor(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_minor() const;
  void _internal_set_minor(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 patch = 3;
  void clear_patch();
  ::PROTOBUF_NAMESPACE_ID::int32 patch() const;
  void set_patch(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_patch() const;
  void _internal_set_patch(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.instance.GetVersionInfoResponse.MinknowVersion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr full_;
  ::PROTOBUF_NAMESPACE_ID::int32 major_;
  ::PROTOBUF_NAMESPACE_ID::int32 minor_;
  ::PROTOBUF_NAMESPACE_ID::int32 patch_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2finstance_2eproto;
};
// -------------------------------------------------------------------

class GetVersionInfoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.instance.GetVersionInfoResponse) */ {
 public:
  inline GetVersionInfoResponse() : GetVersionInfoResponse(nullptr) {}
  ~GetVersionInfoResponse() override;
  explicit constexpr GetVersionInfoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetVersionInfoResponse(const GetVersionInfoResponse& from);
  GetVersionInfoResponse(GetVersionInfoResponse&& from) noexcept
    : GetVersionInfoResponse() {
    *this = ::std::move(from);
  }

  inline GetVersionInfoResponse& operator=(const GetVersionInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetVersionInfoResponse& operator=(GetVersionInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetVersionInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetVersionInfoResponse* internal_default_instance() {
    return reinterpret_cast<const GetVersionInfoResponse*>(
               &_GetVersionInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GetVersionInfoResponse& a, GetVersionInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetVersionInfoResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetVersionInfoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetVersionInfoResponse* New() const final {
    return new GetVersionInfoResponse();
  }

  GetVersionInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetVersionInfoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetVersionInfoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetVersionInfoResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetVersionInfoResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.instance.GetVersionInfoResponse";
  }
  protected:
  explicit GetVersionInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GetVersionInfoResponse_MinknowVersion MinknowVersion;

  typedef GetVersionInfoResponse_DistributionStatus DistributionStatus;
  static constexpr DistributionStatus UNKNOWN =
    GetVersionInfoResponse_DistributionStatus_UNKNOWN;
  static constexpr DistributionStatus STABLE =
    GetVersionInfoResponse_DistributionStatus_STABLE;
  static constexpr DistributionStatus UNSTABLE =
    GetVersionInfoResponse_DistributionStatus_UNSTABLE;
  static constexpr DistributionStatus MODIFIED =
    GetVersionInfoResponse_DistributionStatus_MODIFIED;
  static inline bool DistributionStatus_IsValid(int value) {
    return GetVersionInfoResponse_DistributionStatus_IsValid(value);
  }
  static constexpr DistributionStatus DistributionStatus_MIN =
    GetVersionInfoResponse_DistributionStatus_DistributionStatus_MIN;
  static constexpr DistributionStatus DistributionStatus_MAX =
    GetVersionInfoResponse_DistributionStatus_DistributionStatus_MAX;
  static constexpr int DistributionStatus_ARRAYSIZE =
    GetVersionInfoResponse_DistributionStatus_DistributionStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DistributionStatus_descriptor() {
    return GetVersionInfoResponse_DistributionStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& DistributionStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DistributionStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DistributionStatus_Name.");
    return GetVersionInfoResponse_DistributionStatus_Name(enum_t_value);
  }
  static inline bool DistributionStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DistributionStatus* value) {
    return GetVersionInfoResponse_DistributionStatus_Parse(name, value);
  }

  typedef GetVersionInfoResponse_InstallationType InstallationType;
  static constexpr InstallationType ONT =
    GetVersionInfoResponse_InstallationType_ONT;
  static constexpr InstallationType NC =
    GetVersionInfoResponse_InstallationType_NC;
  static constexpr InstallationType PROD =
    GetVersionInfoResponse_InstallationType_PROD;
  static constexpr InstallationType Q_RELEASE =
    GetVersionInfoResponse_InstallationType_Q_RELEASE;
  static constexpr InstallationType OND_RELEASE =
    GetVersionInfoResponse_InstallationType_OND_RELEASE;
  static inline bool InstallationType_IsValid(int value) {
    return GetVersionInfoResponse_InstallationType_IsValid(value);
  }
  static constexpr InstallationType InstallationType_MIN =
    GetVersionInfoResponse_InstallationType_InstallationType_MIN;
  static constexpr InstallationType InstallationType_MAX =
    GetVersionInfoResponse_InstallationType_InstallationType_MAX;
  static constexpr int InstallationType_ARRAYSIZE =
    GetVersionInfoResponse_InstallationType_InstallationType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  InstallationType_descriptor() {
    return GetVersionInfoResponse_InstallationType_descriptor();
  }
  template<typename T>
  static inline const std::string& InstallationType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, InstallationType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function InstallationType_Name.");
    return GetVersionInfoResponse_InstallationType_Name(enum_t_value);
  }
  static inline bool InstallationType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      InstallationType* value) {
    return GetVersionInfoResponse_InstallationType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kProtocolsFieldNumber = 2,
    kDistributionVersionFieldNumber = 3,
    kConfigurationFieldNumber = 5,
    kMinknowFieldNumber = 1,
    kDistributionStatusFieldNumber = 4,
    kInstallationTypeFieldNumber = 6,
  };
  // string protocols = 2;
  void clear_protocols();
  const std::string& protocols() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_protocols(ArgT0&& arg0, ArgT... args);
  std::string* mutable_protocols();
  PROTOBUF_MUST_USE_RESULT std::string* release_protocols();
  void set_allocated_protocols(std::string* protocols);
  private:
  const std::string& _internal_protocols() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_protocols(const std::string& value);
  std::string* _internal_mutable_protocols();
  public:

  // string distribution_version = 3;
  void clear_distribution_version();
  const std::string& distribution_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_distribution_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_distribution_version();
  PROTOBUF_MUST_USE_RESULT std::string* release_distribution_version();
  void set_allocated_distribution_version(std::string* distribution_version);
  private:
  const std::string& _internal_distribution_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_distribution_version(const std::string& value);
  std::string* _internal_mutable_distribution_version();
  public:

  // string configuration = 5;
  void clear_configuration();
  const std::string& configuration() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_configuration(ArgT0&& arg0, ArgT... args);
  std::string* mutable_configuration();
  PROTOBUF_MUST_USE_RESULT std::string* release_configuration();
  void set_allocated_configuration(std::string* configuration);
  private:
  const std::string& _internal_configuration() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_configuration(const std::string& value);
  std::string* _internal_mutable_configuration();
  public:

  // .minknow_api.instance.GetVersionInfoResponse.MinknowVersion minknow = 1;
  bool has_minknow() const;
  private:
  bool _internal_has_minknow() const;
  public:
  void clear_minknow();
  const ::minknow_api::instance::GetVersionInfoResponse_MinknowVersion& minknow() const;
  PROTOBUF_MUST_USE_RESULT ::minknow_api::instance::GetVersionInfoResponse_MinknowVersion* release_minknow();
  ::minknow_api::instance::GetVersionInfoResponse_MinknowVersion* mutable_minknow();
  void set_allocated_minknow(::minknow_api::instance::GetVersionInfoResponse_MinknowVersion* minknow);
  private:
  const ::minknow_api::instance::GetVersionInfoResponse_MinknowVersion& _internal_minknow() const;
  ::minknow_api::instance::GetVersionInfoResponse_MinknowVersion* _internal_mutable_minknow();
  public:
  void unsafe_arena_set_allocated_minknow(
      ::minknow_api::instance::GetVersionInfoResponse_MinknowVersion* minknow);
  ::minknow_api::instance::GetVersionInfoResponse_MinknowVersion* unsafe_arena_release_minknow();

  // .minknow_api.instance.GetVersionInfoResponse.DistributionStatus distribution_status = 4;
  void clear_distribution_status();
  ::minknow_api::instance::GetVersionInfoResponse_DistributionStatus distribution_status() const;
  void set_distribution_status(::minknow_api::instance::GetVersionInfoResponse_DistributionStatus value);
  private:
  ::minknow_api::instance::GetVersionInfoResponse_DistributionStatus _internal_distribution_status() const;
  void _internal_set_distribution_status(::minknow_api::instance::GetVersionInfoResponse_DistributionStatus value);
  public:

  // .minknow_api.instance.GetVersionInfoResponse.InstallationType installation_type = 6;
  void clear_installation_type();
  ::minknow_api::instance::GetVersionInfoResponse_InstallationType installation_type() const;
  void set_installation_type(::minknow_api::instance::GetVersionInfoResponse_InstallationType value);
  private:
  ::minknow_api::instance::GetVersionInfoResponse_InstallationType _internal_installation_type() const;
  void _internal_set_installation_type(::minknow_api::instance::GetVersionInfoResponse_InstallationType value);
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.instance.GetVersionInfoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr protocols_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr distribution_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr configuration_;
  ::minknow_api::instance::GetVersionInfoResponse_MinknowVersion* minknow_;
  int distribution_status_;
  int installation_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2finstance_2eproto;
};
// -------------------------------------------------------------------

class GetOutputDirectoriesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:minknow_api.instance.GetOutputDirectoriesRequest) */ {
 public:
  inline GetOutputDirectoriesRequest() : GetOutputDirectoriesRequest(nullptr) {}
  explicit constexpr GetOutputDirectoriesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOutputDirectoriesRequest(const GetOutputDirectoriesRequest& from);
  GetOutputDirectoriesRequest(GetOutputDirectoriesRequest&& from) noexcept
    : GetOutputDirectoriesRequest() {
    *this = ::std::move(from);
  }

  inline GetOutputDirectoriesRequest& operator=(const GetOutputDirectoriesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOutputDirectoriesRequest& operator=(GetOutputDirectoriesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOutputDirectoriesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOutputDirectoriesRequest* internal_default_instance() {
    return reinterpret_cast<const GetOutputDirectoriesRequest*>(
               &_GetOutputDirectoriesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GetOutputDirectoriesRequest& a, GetOutputDirectoriesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOutputDirectoriesRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOutputDirectoriesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetOutputDirectoriesRequest* New() const final {
    return new GetOutputDirectoriesRequest();
  }

  GetOutputDirectoriesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetOutputDirectoriesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetOutputDirectoriesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetOutputDirectoriesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.instance.GetOutputDirectoriesRequest";
  }
  protected:
  explicit GetOutputDirectoriesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:minknow_api.instance.GetOutputDirectoriesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2finstance_2eproto;
};
// -------------------------------------------------------------------

class OutputDirectories final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.instance.OutputDirectories) */ {
 public:
  inline OutputDirectories() : OutputDirectories(nullptr) {}
  ~OutputDirectories() override;
  explicit constexpr OutputDirectories(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OutputDirectories(const OutputDirectories& from);
  OutputDirectories(OutputDirectories&& from) noexcept
    : OutputDirectories() {
    *this = ::std::move(from);
  }

  inline OutputDirectories& operator=(const OutputDirectories& from) {
    CopyFrom(from);
    return *this;
  }
  inline OutputDirectories& operator=(OutputDirectories&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OutputDirectories& default_instance() {
    return *internal_default_instance();
  }
  static inline const OutputDirectories* internal_default_instance() {
    return reinterpret_cast<const OutputDirectories*>(
               &_OutputDirectories_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(OutputDirectories& a, OutputDirectories& b) {
    a.Swap(&b);
  }
  inline void Swap(OutputDirectories* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OutputDirectories* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OutputDirectories* New() const final {
    return new OutputDirectories();
  }

  OutputDirectories* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OutputDirectories>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OutputDirectories& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OutputDirectories& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OutputDirectories* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.instance.OutputDirectories";
  }
  protected:
  explicit OutputDirectories(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOutputFieldNumber = 1,
    kLogFieldNumber = 2,
    kReadsFieldNumber = 3,
  };
  // string output = 1;
  void clear_output();
  const std::string& output() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_output(ArgT0&& arg0, ArgT... args);
  std::string* mutable_output();
  PROTOBUF_MUST_USE_RESULT std::string* release_output();
  void set_allocated_output(std::string* output);
  private:
  const std::string& _internal_output() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_output(const std::string& value);
  std::string* _internal_mutable_output();
  public:

  // string log = 2;
  void clear_log();
  const std::string& log() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_log(ArgT0&& arg0, ArgT... args);
  std::string* mutable_log();
  PROTOBUF_MUST_USE_RESULT std::string* release_log();
  void set_allocated_log(std::string* log);
  private:
  const std::string& _internal_log() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_log(const std::string& value);
  std::string* _internal_mutable_log();
  public:

  // string reads = 3;
  void clear_reads();
  const std::string& reads() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reads(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reads();
  PROTOBUF_MUST_USE_RESULT std::string* release_reads();
  void set_allocated_reads(std::string* reads);
  private:
  const std::string& _internal_reads() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reads(const std::string& value);
  std::string* _internal_mutable_reads();
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.instance.OutputDirectories)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr output_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr log_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reads_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2finstance_2eproto;
};
// -------------------------------------------------------------------

class GetDefaultOutputDirectoriesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:minknow_api.instance.GetDefaultOutputDirectoriesRequest) */ {
 public:
  inline GetDefaultOutputDirectoriesRequest() : GetDefaultOutputDirectoriesRequest(nullptr) {}
  explicit constexpr GetDefaultOutputDirectoriesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetDefaultOutputDirectoriesRequest(const GetDefaultOutputDirectoriesRequest& from);
  GetDefaultOutputDirectoriesRequest(GetDefaultOutputDirectoriesRequest&& from) noexcept
    : GetDefaultOutputDirectoriesRequest() {
    *this = ::std::move(from);
  }

  inline GetDefaultOutputDirectoriesRequest& operator=(const GetDefaultOutputDirectoriesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDefaultOutputDirectoriesRequest& operator=(GetDefaultOutputDirectoriesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDefaultOutputDirectoriesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDefaultOutputDirectoriesRequest* internal_default_instance() {
    return reinterpret_cast<const GetDefaultOutputDirectoriesRequest*>(
               &_GetDefaultOutputDirectoriesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetDefaultOutputDirectoriesRequest& a, GetDefaultOutputDirectoriesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDefaultOutputDirectoriesRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDefaultOutputDirectoriesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetDefaultOutputDirectoriesRequest* New() const final {
    return new GetDefaultOutputDirectoriesRequest();
  }

  GetDefaultOutputDirectoriesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetDefaultOutputDirectoriesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetDefaultOutputDirectoriesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetDefaultOutputDirectoriesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.instance.GetDefaultOutputDirectoriesRequest";
  }
  protected:
  explicit GetDefaultOutputDirectoriesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:minknow_api.instance.GetDefaultOutputDirectoriesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2finstance_2eproto;
};
// -------------------------------------------------------------------

class SetOutputDirectoryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.instance.SetOutputDirectoryRequest) */ {
 public:
  inline SetOutputDirectoryRequest() : SetOutputDirectoryRequest(nullptr) {}
  ~SetOutputDirectoryRequest() override;
  explicit constexpr SetOutputDirectoryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetOutputDirectoryRequest(const SetOutputDirectoryRequest& from);
  SetOutputDirectoryRequest(SetOutputDirectoryRequest&& from) noexcept
    : SetOutputDirectoryRequest() {
    *this = ::std::move(from);
  }

  inline SetOutputDirectoryRequest& operator=(const SetOutputDirectoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetOutputDirectoryRequest& operator=(SetOutputDirectoryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetOutputDirectoryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetOutputDirectoryRequest* internal_default_instance() {
    return reinterpret_cast<const SetOutputDirectoryRequest*>(
               &_SetOutputDirectoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SetOutputDirectoryRequest& a, SetOutputDirectoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetOutputDirectoryRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetOutputDirectoryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetOutputDirectoryRequest* New() const final {
    return new SetOutputDirectoryRequest();
  }

  SetOutputDirectoryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetOutputDirectoryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetOutputDirectoryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetOutputDirectoryRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetOutputDirectoryRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.instance.SetOutputDirectoryRequest";
  }
  protected:
  explicit SetOutputDirectoryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
  };
  // string path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_MUST_USE_RESULT std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.instance.SetOutputDirectoryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2finstance_2eproto;
};
// -------------------------------------------------------------------

class SetOutputDirectoryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:minknow_api.instance.SetOutputDirectoryResponse) */ {
 public:
  inline SetOutputDirectoryResponse() : SetOutputDirectoryResponse(nullptr) {}
  explicit constexpr SetOutputDirectoryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetOutputDirectoryResponse(const SetOutputDirectoryResponse& from);
  SetOutputDirectoryResponse(SetOutputDirectoryResponse&& from) noexcept
    : SetOutputDirectoryResponse() {
    *this = ::std::move(from);
  }

  inline SetOutputDirectoryResponse& operator=(const SetOutputDirectoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetOutputDirectoryResponse& operator=(SetOutputDirectoryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetOutputDirectoryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetOutputDirectoryResponse* internal_default_instance() {
    return reinterpret_cast<const SetOutputDirectoryResponse*>(
               &_SetOutputDirectoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SetOutputDirectoryResponse& a, SetOutputDirectoryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetOutputDirectoryResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetOutputDirectoryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetOutputDirectoryResponse* New() const final {
    return new SetOutputDirectoryResponse();
  }

  SetOutputDirectoryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetOutputDirectoryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetOutputDirectoryResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetOutputDirectoryResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.instance.SetOutputDirectoryResponse";
  }
  protected:
  explicit SetOutputDirectoryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:minknow_api.instance.SetOutputDirectoryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2finstance_2eproto;
};
// -------------------------------------------------------------------

class SetReadsDirectoryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.instance.SetReadsDirectoryRequest) */ {
 public:
  inline SetReadsDirectoryRequest() : SetReadsDirectoryRequest(nullptr) {}
  ~SetReadsDirectoryRequest() override;
  explicit constexpr SetReadsDirectoryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetReadsDirectoryRequest(const SetReadsDirectoryRequest& from);
  SetReadsDirectoryRequest(SetReadsDirectoryRequest&& from) noexcept
    : SetReadsDirectoryRequest() {
    *this = ::std::move(from);
  }

  inline SetReadsDirectoryRequest& operator=(const SetReadsDirectoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetReadsDirectoryRequest& operator=(SetReadsDirectoryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetReadsDirectoryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetReadsDirectoryRequest* internal_default_instance() {
    return reinterpret_cast<const SetReadsDirectoryRequest*>(
               &_SetReadsDirectoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SetReadsDirectoryRequest& a, SetReadsDirectoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetReadsDirectoryRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetReadsDirectoryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetReadsDirectoryRequest* New() const final {
    return new SetReadsDirectoryRequest();
  }

  SetReadsDirectoryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetReadsDirectoryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetReadsDirectoryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetReadsDirectoryRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetReadsDirectoryRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.instance.SetReadsDirectoryRequest";
  }
  protected:
  explicit SetReadsDirectoryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
  };
  // string path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_MUST_USE_RESULT std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.instance.SetReadsDirectoryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2finstance_2eproto;
};
// -------------------------------------------------------------------

class SetReadsDirectoryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:minknow_api.instance.SetReadsDirectoryResponse) */ {
 public:
  inline SetReadsDirectoryResponse() : SetReadsDirectoryResponse(nullptr) {}
  explicit constexpr SetReadsDirectoryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetReadsDirectoryResponse(const SetReadsDirectoryResponse& from);
  SetReadsDirectoryResponse(SetReadsDirectoryResponse&& from) noexcept
    : SetReadsDirectoryResponse() {
    *this = ::std::move(from);
  }

  inline SetReadsDirectoryResponse& operator=(const SetReadsDirectoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetReadsDirectoryResponse& operator=(SetReadsDirectoryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetReadsDirectoryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetReadsDirectoryResponse* internal_default_instance() {
    return reinterpret_cast<const SetReadsDirectoryResponse*>(
               &_SetReadsDirectoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SetReadsDirectoryResponse& a, SetReadsDirectoryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetReadsDirectoryResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetReadsDirectoryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetReadsDirectoryResponse* New() const final {
    return new SetReadsDirectoryResponse();
  }

  SetReadsDirectoryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetReadsDirectoryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetReadsDirectoryResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetReadsDirectoryResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.instance.SetReadsDirectoryResponse";
  }
  protected:
  explicit SetReadsDirectoryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:minknow_api.instance.SetReadsDirectoryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2finstance_2eproto;
};
// -------------------------------------------------------------------

class FilesystemDiskSpaceInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.instance.FilesystemDiskSpaceInfo) */ {
 public:
  inline FilesystemDiskSpaceInfo() : FilesystemDiskSpaceInfo(nullptr) {}
  ~FilesystemDiskSpaceInfo() override;
  explicit constexpr FilesystemDiskSpaceInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FilesystemDiskSpaceInfo(const FilesystemDiskSpaceInfo& from);
  FilesystemDiskSpaceInfo(FilesystemDiskSpaceInfo&& from) noexcept
    : FilesystemDiskSpaceInfo() {
    *this = ::std::move(from);
  }

  inline FilesystemDiskSpaceInfo& operator=(const FilesystemDiskSpaceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FilesystemDiskSpaceInfo& operator=(FilesystemDiskSpaceInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FilesystemDiskSpaceInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const FilesystemDiskSpaceInfo* internal_default_instance() {
    return reinterpret_cast<const FilesystemDiskSpaceInfo*>(
               &_FilesystemDiskSpaceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(FilesystemDiskSpaceInfo& a, FilesystemDiskSpaceInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(FilesystemDiskSpaceInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FilesystemDiskSpaceInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FilesystemDiskSpaceInfo* New() const final {
    return new FilesystemDiskSpaceInfo();
  }

  FilesystemDiskSpaceInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FilesystemDiskSpaceInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FilesystemDiskSpaceInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FilesystemDiskSpaceInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FilesystemDiskSpaceInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.instance.FilesystemDiskSpaceInfo";
  }
  protected:
  explicit FilesystemDiskSpaceInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWhatFieldNumber = 4,
    kFilesystemIdFieldNumber = 1,
    kBytesAvailableFieldNumber = 2,
    kBytesCapacityFieldNumber = 3,
    kBytesToStopCleanlyFieldNumber = 5,
    kBytesWhenAlertIssuedFieldNumber = 6,
    kBytesPerSecondFieldNumber = 9,
    kRecommendAlertFieldNumber = 7,
    kRecommendStopFieldNumber = 8,
  };
  // repeated string what = 4;
  int what_size() const;
  private:
  int _internal_what_size() const;
  public:
  void clear_what();
  const std::string& what(int index) const;
  std::string* mutable_what(int index);
  void set_what(int index, const std::string& value);
  void set_what(int index, std::string&& value);
  void set_what(int index, const char* value);
  void set_what(int index, const char* value, size_t size);
  std::string* add_what();
  void add_what(const std::string& value);
  void add_what(std::string&& value);
  void add_what(const char* value);
  void add_what(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& what() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_what();
  private:
  const std::string& _internal_what(int index) const;
  std::string* _internal_add_what();
  public:

  // string filesystem_id = 1;
  void clear_filesystem_id();
  const std::string& filesystem_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filesystem_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filesystem_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_filesystem_id();
  void set_allocated_filesystem_id(std::string* filesystem_id);
  private:
  const std::string& _internal_filesystem_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filesystem_id(const std::string& value);
  std::string* _internal_mutable_filesystem_id();
  public:

  // uint64 bytes_available = 2;
  void clear_bytes_available();
  ::PROTOBUF_NAMESPACE_ID::uint64 bytes_available() const;
  void set_bytes_available(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_bytes_available() const;
  void _internal_set_bytes_available(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 bytes_capacity = 3;
  void clear_bytes_capacity();
  ::PROTOBUF_NAMESPACE_ID::uint64 bytes_capacity() const;
  void set_bytes_capacity(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_bytes_capacity() const;
  void _internal_set_bytes_capacity(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 bytes_to_stop_cleanly = 5;
  void clear_bytes_to_stop_cleanly();
  ::PROTOBUF_NAMESPACE_ID::uint64 bytes_to_stop_cleanly() const;
  void set_bytes_to_stop_cleanly(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_bytes_to_stop_cleanly() const;
  void _internal_set_bytes_to_stop_cleanly(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 bytes_when_alert_issued = 6;
  void clear_bytes_when_alert_issued();
  ::PROTOBUF_NAMESPACE_ID::uint64 bytes_when_alert_issued() const;
  void set_bytes_when_alert_issued(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_bytes_when_alert_issued() const;
  void _internal_set_bytes_when_alert_issued(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // int64 bytes_per_second = 9;
  void clear_bytes_per_second();
  ::PROTOBUF_NAMESPACE_ID::int64 bytes_per_second() const;
  void set_bytes_per_second(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_bytes_per_second() const;
  void _internal_set_bytes_per_second(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // bool recommend_alert = 7;
  void clear_recommend_alert();
  bool recommend_alert() const;
  void set_recommend_alert(bool value);
  private:
  bool _internal_recommend_alert() const;
  void _internal_set_recommend_alert(bool value);
  public:

  // bool recommend_stop = 8;
  void clear_recommend_stop();
  bool recommend_stop() const;
  void set_recommend_stop(bool value);
  private:
  bool _internal_recommend_stop() const;
  void _internal_set_recommend_stop(bool value);
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.instance.FilesystemDiskSpaceInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> what_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filesystem_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 bytes_available_;
  ::PROTOBUF_NAMESPACE_ID::uint64 bytes_capacity_;
  ::PROTOBUF_NAMESPACE_ID::uint64 bytes_to_stop_cleanly_;
  ::PROTOBUF_NAMESPACE_ID::uint64 bytes_when_alert_issued_;
  ::PROTOBUF_NAMESPACE_ID::int64 bytes_per_second_;
  bool recommend_alert_;
  bool recommend_stop_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2finstance_2eproto;
};
// -------------------------------------------------------------------

class GetDiskSpaceInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:minknow_api.instance.GetDiskSpaceInfoRequest) */ {
 public:
  inline GetDiskSpaceInfoRequest() : GetDiskSpaceInfoRequest(nullptr) {}
  explicit constexpr GetDiskSpaceInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetDiskSpaceInfoRequest(const GetDiskSpaceInfoRequest& from);
  GetDiskSpaceInfoRequest(GetDiskSpaceInfoRequest&& from) noexcept
    : GetDiskSpaceInfoRequest() {
    *this = ::std::move(from);
  }

  inline GetDiskSpaceInfoRequest& operator=(const GetDiskSpaceInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDiskSpaceInfoRequest& operator=(GetDiskSpaceInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDiskSpaceInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDiskSpaceInfoRequest* internal_default_instance() {
    return reinterpret_cast<const GetDiskSpaceInfoRequest*>(
               &_GetDiskSpaceInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetDiskSpaceInfoRequest& a, GetDiskSpaceInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDiskSpaceInfoRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDiskSpaceInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetDiskSpaceInfoRequest* New() const final {
    return new GetDiskSpaceInfoRequest();
  }

  GetDiskSpaceInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetDiskSpaceInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetDiskSpaceInfoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetDiskSpaceInfoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.instance.GetDiskSpaceInfoRequest";
  }
  protected:
  explicit GetDiskSpaceInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:minknow_api.instance.GetDiskSpaceInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2finstance_2eproto;
};
// -------------------------------------------------------------------

class StreamDiskSpaceInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.instance.StreamDiskSpaceInfoRequest) */ {
 public:
  inline StreamDiskSpaceInfoRequest() : StreamDiskSpaceInfoRequest(nullptr) {}
  ~StreamDiskSpaceInfoRequest() override;
  explicit constexpr StreamDiskSpaceInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamDiskSpaceInfoRequest(const StreamDiskSpaceInfoRequest& from);
  StreamDiskSpaceInfoRequest(StreamDiskSpaceInfoRequest&& from) noexcept
    : StreamDiskSpaceInfoRequest() {
    *this = ::std::move(from);
  }

  inline StreamDiskSpaceInfoRequest& operator=(const StreamDiskSpaceInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamDiskSpaceInfoRequest& operator=(StreamDiskSpaceInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamDiskSpaceInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamDiskSpaceInfoRequest* internal_default_instance() {
    return reinterpret_cast<const StreamDiskSpaceInfoRequest*>(
               &_StreamDiskSpaceInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(StreamDiskSpaceInfoRequest& a, StreamDiskSpaceInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamDiskSpaceInfoRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamDiskSpaceInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StreamDiskSpaceInfoRequest* New() const final {
    return new StreamDiskSpaceInfoRequest();
  }

  StreamDiskSpaceInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StreamDiskSpaceInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamDiskSpaceInfoRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StreamDiskSpaceInfoRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamDiskSpaceInfoRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.instance.StreamDiskSpaceInfoRequest";
  }
  protected:
  explicit StreamDiskSpaceInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeriodFieldNumber = 1,
  };
  // uint32 period = 1;
  void clear_period();
  ::PROTOBUF_NAMESPACE_ID::uint32 period() const;
  void set_period(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_period() const;
  void _internal_set_period(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.instance.StreamDiskSpaceInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 period_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2finstance_2eproto;
};
// -------------------------------------------------------------------

class GetDiskSpaceInfoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.instance.GetDiskSpaceInfoResponse) */ {
 public:
  inline GetDiskSpaceInfoResponse() : GetDiskSpaceInfoResponse(nullptr) {}
  ~GetDiskSpaceInfoResponse() override;
  explicit constexpr GetDiskSpaceInfoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetDiskSpaceInfoResponse(const GetDiskSpaceInfoResponse& from);
  GetDiskSpaceInfoResponse(GetDiskSpaceInfoResponse&& from) noexcept
    : GetDiskSpaceInfoResponse() {
    *this = ::std::move(from);
  }

  inline GetDiskSpaceInfoResponse& operator=(const GetDiskSpaceInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDiskSpaceInfoResponse& operator=(GetDiskSpaceInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDiskSpaceInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDiskSpaceInfoResponse* internal_default_instance() {
    return reinterpret_cast<const GetDiskSpaceInfoResponse*>(
               &_GetDiskSpaceInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetDiskSpaceInfoResponse& a, GetDiskSpaceInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDiskSpaceInfoResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDiskSpaceInfoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetDiskSpaceInfoResponse* New() const final {
    return new GetDiskSpaceInfoResponse();
  }

  GetDiskSpaceInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetDiskSpaceInfoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetDiskSpaceInfoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetDiskSpaceInfoResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDiskSpaceInfoResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.instance.GetDiskSpaceInfoResponse";
  }
  protected:
  explicit GetDiskSpaceInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilesystemDiskSpaceInfoFieldNumber = 1,
  };
  // repeated .minknow_api.instance.FilesystemDiskSpaceInfo filesystem_disk_space_info = 1;
  int filesystem_disk_space_info_size() const;
  private:
  int _internal_filesystem_disk_space_info_size() const;
  public:
  void clear_filesystem_disk_space_info();
  ::minknow_api::instance::FilesystemDiskSpaceInfo* mutable_filesystem_disk_space_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::instance::FilesystemDiskSpaceInfo >*
      mutable_filesystem_disk_space_info();
  private:
  const ::minknow_api::instance::FilesystemDiskSpaceInfo& _internal_filesystem_disk_space_info(int index) const;
  ::minknow_api::instance::FilesystemDiskSpaceInfo* _internal_add_filesystem_disk_space_info();
  public:
  const ::minknow_api::instance::FilesystemDiskSpaceInfo& filesystem_disk_space_info(int index) const;
  ::minknow_api::instance::FilesystemDiskSpaceInfo* add_filesystem_disk_space_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::instance::FilesystemDiskSpaceInfo >&
      filesystem_disk_space_info() const;

  // @@protoc_insertion_point(class_scope:minknow_api.instance.GetDiskSpaceInfoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::instance::FilesystemDiskSpaceInfo > filesystem_disk_space_info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2finstance_2eproto;
};
// -------------------------------------------------------------------

class GetMachineIdRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:minknow_api.instance.GetMachineIdRequest) */ {
 public:
  inline GetMachineIdRequest() : GetMachineIdRequest(nullptr) {}
  explicit constexpr GetMachineIdRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetMachineIdRequest(const GetMachineIdRequest& from);
  GetMachineIdRequest(GetMachineIdRequest&& from) noexcept
    : GetMachineIdRequest() {
    *this = ::std::move(from);
  }

  inline GetMachineIdRequest& operator=(const GetMachineIdRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMachineIdRequest& operator=(GetMachineIdRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetMachineIdRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetMachineIdRequest* internal_default_instance() {
    return reinterpret_cast<const GetMachineIdRequest*>(
               &_GetMachineIdRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetMachineIdRequest& a, GetMachineIdRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetMachineIdRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetMachineIdRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetMachineIdRequest* New() const final {
    return new GetMachineIdRequest();
  }

  GetMachineIdRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetMachineIdRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetMachineIdRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetMachineIdRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.instance.GetMachineIdRequest";
  }
  protected:
  explicit GetMachineIdRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:minknow_api.instance.GetMachineIdRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2finstance_2eproto;
};
// -------------------------------------------------------------------

class GetMachineIdResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.instance.GetMachineIdResponse) */ {
 public:
  inline GetMachineIdResponse() : GetMachineIdResponse(nullptr) {}
  ~GetMachineIdResponse() override;
  explicit constexpr GetMachineIdResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetMachineIdResponse(const GetMachineIdResponse& from);
  GetMachineIdResponse(GetMachineIdResponse&& from) noexcept
    : GetMachineIdResponse() {
    *this = ::std::move(from);
  }

  inline GetMachineIdResponse& operator=(const GetMachineIdResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMachineIdResponse& operator=(GetMachineIdResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetMachineIdResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetMachineIdResponse* internal_default_instance() {
    return reinterpret_cast<const GetMachineIdResponse*>(
               &_GetMachineIdResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetMachineIdResponse& a, GetMachineIdResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetMachineIdResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetMachineIdResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetMachineIdResponse* New() const final {
    return new GetMachineIdResponse();
  }

  GetMachineIdResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetMachineIdResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetMachineIdResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetMachineIdResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetMachineIdResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.instance.GetMachineIdResponse";
  }
  protected:
  explicit GetMachineIdResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMachineIdFieldNumber = 1,
  };
  // string machine_id = 1;
  void clear_machine_id();
  const std::string& machine_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_machine_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_machine_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_machine_id();
  void set_allocated_machine_id(std::string* machine_id);
  private:
  const std::string& _internal_machine_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_machine_id(const std::string& value);
  std::string* _internal_mutable_machine_id();
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.instance.GetMachineIdResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr machine_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2finstance_2eproto;
};
// -------------------------------------------------------------------

class StreamInstanceActivityRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:minknow_api.instance.StreamInstanceActivityRequest) */ {
 public:
  inline StreamInstanceActivityRequest() : StreamInstanceActivityRequest(nullptr) {}
  explicit constexpr StreamInstanceActivityRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamInstanceActivityRequest(const StreamInstanceActivityRequest& from);
  StreamInstanceActivityRequest(StreamInstanceActivityRequest&& from) noexcept
    : StreamInstanceActivityRequest() {
    *this = ::std::move(from);
  }

  inline StreamInstanceActivityRequest& operator=(const StreamInstanceActivityRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamInstanceActivityRequest& operator=(StreamInstanceActivityRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamInstanceActivityRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamInstanceActivityRequest* internal_default_instance() {
    return reinterpret_cast<const StreamInstanceActivityRequest*>(
               &_StreamInstanceActivityRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(StreamInstanceActivityRequest& a, StreamInstanceActivityRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamInstanceActivityRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamInstanceActivityRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StreamInstanceActivityRequest* New() const final {
    return new StreamInstanceActivityRequest();
  }

  StreamInstanceActivityRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StreamInstanceActivityRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const StreamInstanceActivityRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const StreamInstanceActivityRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.instance.StreamInstanceActivityRequest";
  }
  protected:
  explicit StreamInstanceActivityRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:minknow_api.instance.StreamInstanceActivityRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2finstance_2eproto;
};
// -------------------------------------------------------------------

class DeviceInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.instance.DeviceInfo) */ {
 public:
  inline DeviceInfo() : DeviceInfo(nullptr) {}
  ~DeviceInfo() override;
  explicit constexpr DeviceInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceInfo(const DeviceInfo& from);
  DeviceInfo(DeviceInfo&& from) noexcept
    : DeviceInfo() {
    *this = ::std::move(from);
  }

  inline DeviceInfo& operator=(const DeviceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceInfo& operator=(DeviceInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceInfo* internal_default_instance() {
    return reinterpret_cast<const DeviceInfo*>(
               &_DeviceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(DeviceInfo& a, DeviceInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeviceInfo* New() const final {
    return new DeviceInfo();
  }

  DeviceInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeviceInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeviceInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.instance.DeviceInfo";
  }
  protected:
  explicit DeviceInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceInfoFieldNumber = 2,
    kDeviceStateFieldNumber = 1,
  };
  // .minknow_api.device.GetDeviceInfoResponse device_info = 2;
  bool has_device_info() const;
  private:
  bool _internal_has_device_info() const;
  public:
  void clear_device_info();
  const ::minknow_api::device::GetDeviceInfoResponse& device_info() const;
  PROTOBUF_MUST_USE_RESULT ::minknow_api::device::GetDeviceInfoResponse* release_device_info();
  ::minknow_api::device::GetDeviceInfoResponse* mutable_device_info();
  void set_allocated_device_info(::minknow_api::device::GetDeviceInfoResponse* device_info);
  private:
  const ::minknow_api::device::GetDeviceInfoResponse& _internal_device_info() const;
  ::minknow_api::device::GetDeviceInfoResponse* _internal_mutable_device_info();
  public:
  void unsafe_arena_set_allocated_device_info(
      ::minknow_api::device::GetDeviceInfoResponse* device_info);
  ::minknow_api::device::GetDeviceInfoResponse* unsafe_arena_release_device_info();

  // .minknow_api.device.GetDeviceStateResponse.DeviceState device_state = 1;
  void clear_device_state();
  ::minknow_api::device::GetDeviceStateResponse_DeviceState device_state() const;
  void set_device_state(::minknow_api::device::GetDeviceStateResponse_DeviceState value);
  private:
  ::minknow_api::device::GetDeviceStateResponse_DeviceState _internal_device_state() const;
  void _internal_set_device_state(::minknow_api::device::GetDeviceStateResponse_DeviceState value);
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.instance.DeviceInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::minknow_api::device::GetDeviceInfoResponse* device_info_;
  int device_state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2finstance_2eproto;
};
// -------------------------------------------------------------------

class BasecallSpeed final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.instance.BasecallSpeed) */ {
 public:
  inline BasecallSpeed() : BasecallSpeed(nullptr) {}
  ~BasecallSpeed() override;
  explicit constexpr BasecallSpeed(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BasecallSpeed(const BasecallSpeed& from);
  BasecallSpeed(BasecallSpeed&& from) noexcept
    : BasecallSpeed() {
    *this = ::std::move(from);
  }

  inline BasecallSpeed& operator=(const BasecallSpeed& from) {
    CopyFrom(from);
    return *this;
  }
  inline BasecallSpeed& operator=(BasecallSpeed&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BasecallSpeed& default_instance() {
    return *internal_default_instance();
  }
  static inline const BasecallSpeed* internal_default_instance() {
    return reinterpret_cast<const BasecallSpeed*>(
               &_BasecallSpeed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(BasecallSpeed& a, BasecallSpeed& b) {
    a.Swap(&b);
  }
  inline void Swap(BasecallSpeed* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BasecallSpeed* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BasecallSpeed* New() const final {
    return new BasecallSpeed();
  }

  BasecallSpeed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BasecallSpeed>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BasecallSpeed& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BasecallSpeed& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BasecallSpeed* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.instance.BasecallSpeed";
  }
  protected:
  explicit BasecallSpeed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMeanBasecallSpeedFieldNumber = 1,
  };
  // float mean_basecall_speed = 1;
  void clear_mean_basecall_speed();
  float mean_basecall_speed() const;
  void set_mean_basecall_speed(float value);
  private:
  float _internal_mean_basecall_speed() const;
  void _internal_set_mean_basecall_speed(float value);
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.instance.BasecallSpeed)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float mean_basecall_speed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2finstance_2eproto;
};
// -------------------------------------------------------------------

class N50 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.instance.N50) */ {
 public:
  inline N50() : N50(nullptr) {}
  ~N50() override;
  explicit constexpr N50(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  N50(const N50& from);
  N50(N50&& from) noexcept
    : N50() {
    *this = ::std::move(from);
  }

  inline N50& operator=(const N50& from) {
    CopyFrom(from);
    return *this;
  }
  inline N50& operator=(N50&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const N50& default_instance() {
    return *internal_default_instance();
  }
  static inline const N50* internal_default_instance() {
    return reinterpret_cast<const N50*>(
               &_N50_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(N50& a, N50& b) {
    a.Swap(&b);
  }
  inline void Swap(N50* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(N50* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline N50* New() const final {
    return new N50();
  }

  N50* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<N50>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const N50& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const N50& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(N50* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.instance.N50";
  }
  protected:
  explicit N50(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kN50FieldNumber = 1,
  };
  // float n50 = 1;
  void clear_n50();
  float n50() const;
  void set_n50(float value);
  private:
  float _internal_n50() const;
  void _internal_set_n50(float value);
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.instance.N50)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float n50_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2finstance_2eproto;
};
// -------------------------------------------------------------------

class StreamInstanceActivityResponse_FlowCellHealth_ChannelStatePercentagesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<StreamInstanceActivityResponse_FlowCellHealth_ChannelStatePercentagesEntry_DoNotUse, 
    std::string, float,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<StreamInstanceActivityResponse_FlowCellHealth_ChannelStatePercentagesEntry_DoNotUse, 
    std::string, float,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT> SuperType;
  StreamInstanceActivityResponse_FlowCellHealth_ChannelStatePercentagesEntry_DoNotUse();
  explicit constexpr StreamInstanceActivityResponse_FlowCellHealth_ChannelStatePercentagesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit StreamInstanceActivityResponse_FlowCellHealth_ChannelStatePercentagesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const StreamInstanceActivityResponse_FlowCellHealth_ChannelStatePercentagesEntry_DoNotUse& other);
  static const StreamInstanceActivityResponse_FlowCellHealth_ChannelStatePercentagesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const StreamInstanceActivityResponse_FlowCellHealth_ChannelStatePercentagesEntry_DoNotUse*>(&_StreamInstanceActivityResponse_FlowCellHealth_ChannelStatePercentagesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "minknow_api.instance.StreamInstanceActivityResponse.FlowCellHealth.ChannelStatePercentagesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class StreamInstanceActivityResponse_FlowCellHealth final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.instance.StreamInstanceActivityResponse.FlowCellHealth) */ {
 public:
  inline StreamInstanceActivityResponse_FlowCellHealth() : StreamInstanceActivityResponse_FlowCellHealth(nullptr) {}
  ~StreamInstanceActivityResponse_FlowCellHealth() override;
  explicit constexpr StreamInstanceActivityResponse_FlowCellHealth(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamInstanceActivityResponse_FlowCellHealth(const StreamInstanceActivityResponse_FlowCellHealth& from);
  StreamInstanceActivityResponse_FlowCellHealth(StreamInstanceActivityResponse_FlowCellHealth&& from) noexcept
    : StreamInstanceActivityResponse_FlowCellHealth() {
    *this = ::std::move(from);
  }

  inline StreamInstanceActivityResponse_FlowCellHealth& operator=(const StreamInstanceActivityResponse_FlowCellHealth& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamInstanceActivityResponse_FlowCellHealth& operator=(StreamInstanceActivityResponse_FlowCellHealth&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamInstanceActivityResponse_FlowCellHealth& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamInstanceActivityResponse_FlowCellHealth* internal_default_instance() {
    return reinterpret_cast<const StreamInstanceActivityResponse_FlowCellHealth*>(
               &_StreamInstanceActivityResponse_FlowCellHealth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(StreamInstanceActivityResponse_FlowCellHealth& a, StreamInstanceActivityResponse_FlowCellHealth& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamInstanceActivityResponse_FlowCellHealth* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamInstanceActivityResponse_FlowCellHealth* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StreamInstanceActivityResponse_FlowCellHealth* New() const final {
    return new StreamInstanceActivityResponse_FlowCellHealth();
  }

  StreamInstanceActivityResponse_FlowCellHealth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StreamInstanceActivityResponse_FlowCellHealth>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamInstanceActivityResponse_FlowCellHealth& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StreamInstanceActivityResponse_FlowCellHealth& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamInstanceActivityResponse_FlowCellHealth* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.instance.StreamInstanceActivityResponse.FlowCellHealth";
  }
  protected:
  explicit StreamInstanceActivityResponse_FlowCellHealth(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kChannelStatePercentagesFieldNumber = 1,
  };
  // map<string, float> channel_state_percentages = 1;
  int channel_state_percentages_size() const;
  private:
  int _internal_channel_state_percentages_size() const;
  public:
  void clear_channel_state_percentages();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, float >&
      _internal_channel_state_percentages() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, float >*
      _internal_mutable_channel_state_percentages();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, float >&
      channel_state_percentages() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, float >*
      mutable_channel_state_percentages();

  // @@protoc_insertion_point(class_scope:minknow_api.instance.StreamInstanceActivityResponse.FlowCellHealth)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      StreamInstanceActivityResponse_FlowCellHealth_ChannelStatePercentagesEntry_DoNotUse,
      std::string, float,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT> channel_state_percentages_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2finstance_2eproto;
};
// -------------------------------------------------------------------

class StreamInstanceActivityResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.instance.StreamInstanceActivityResponse) */ {
 public:
  inline StreamInstanceActivityResponse() : StreamInstanceActivityResponse(nullptr) {}
  ~StreamInstanceActivityResponse() override;
  explicit constexpr StreamInstanceActivityResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamInstanceActivityResponse(const StreamInstanceActivityResponse& from);
  StreamInstanceActivityResponse(StreamInstanceActivityResponse&& from) noexcept
    : StreamInstanceActivityResponse() {
    *this = ::std::move(from);
  }

  inline StreamInstanceActivityResponse& operator=(const StreamInstanceActivityResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamInstanceActivityResponse& operator=(StreamInstanceActivityResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamInstanceActivityResponse& default_instance() {
    return *internal_default_instance();
  }
  enum StreamValueCase {
    kDeviceInfo = 1,
    kFlowCellInfo = 2,
    kProtocolRunInfo = 3,
    kAcquisitionRunInfo = 4,
    kFlowCellHealth = 5,
    kYieldSummary = 6,
    kBasecallSpeed = 7,
    kN50 = 8,
    STREAM_VALUE_NOT_SET = 0,
  };

  static inline const StreamInstanceActivityResponse* internal_default_instance() {
    return reinterpret_cast<const StreamInstanceActivityResponse*>(
               &_StreamInstanceActivityResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(StreamInstanceActivityResponse& a, StreamInstanceActivityResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamInstanceActivityResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamInstanceActivityResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StreamInstanceActivityResponse* New() const final {
    return new StreamInstanceActivityResponse();
  }

  StreamInstanceActivityResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StreamInstanceActivityResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamInstanceActivityResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StreamInstanceActivityResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamInstanceActivityResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.instance.StreamInstanceActivityResponse";
  }
  protected:
  explicit StreamInstanceActivityResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StreamInstanceActivityResponse_FlowCellHealth FlowCellHealth;

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceInfoFieldNumber = 1,
    kFlowCellInfoFieldNumber = 2,
    kProtocolRunInfoFieldNumber = 3,
    kAcquisitionRunInfoFieldNumber = 4,
    kFlowCellHealthFieldNumber = 5,
    kYieldSummaryFieldNumber = 6,
    kBasecallSpeedFieldNumber = 7,
    kN50FieldNumber = 8,
  };
  // .minknow_api.instance.DeviceInfo device_info = 1;
  bool has_device_info() const;
  private:
  bool _internal_has_device_info() const;
  public:
  void clear_device_info();
  const ::minknow_api::instance::DeviceInfo& device_info() const;
  PROTOBUF_MUST_USE_RESULT ::minknow_api::instance::DeviceInfo* release_device_info();
  ::minknow_api::instance::DeviceInfo* mutable_device_info();
  void set_allocated_device_info(::minknow_api::instance::DeviceInfo* device_info);
  private:
  const ::minknow_api::instance::DeviceInfo& _internal_device_info() const;
  ::minknow_api::instance::DeviceInfo* _internal_mutable_device_info();
  public:
  void unsafe_arena_set_allocated_device_info(
      ::minknow_api::instance::DeviceInfo* device_info);
  ::minknow_api::instance::DeviceInfo* unsafe_arena_release_device_info();

  // .minknow_api.device.GetFlowCellInfoResponse flow_cell_info = 2;
  bool has_flow_cell_info() const;
  private:
  bool _internal_has_flow_cell_info() const;
  public:
  void clear_flow_cell_info();
  const ::minknow_api::device::GetFlowCellInfoResponse& flow_cell_info() const;
  PROTOBUF_MUST_USE_RESULT ::minknow_api::device::GetFlowCellInfoResponse* release_flow_cell_info();
  ::minknow_api::device::GetFlowCellInfoResponse* mutable_flow_cell_info();
  void set_allocated_flow_cell_info(::minknow_api::device::GetFlowCellInfoResponse* flow_cell_info);
  private:
  const ::minknow_api::device::GetFlowCellInfoResponse& _internal_flow_cell_info() const;
  ::minknow_api::device::GetFlowCellInfoResponse* _internal_mutable_flow_cell_info();
  public:
  void unsafe_arena_set_allocated_flow_cell_info(
      ::minknow_api::device::GetFlowCellInfoResponse* flow_cell_info);
  ::minknow_api::device::GetFlowCellInfoResponse* unsafe_arena_release_flow_cell_info();

  // .minknow_api.protocol.ProtocolRunInfo protocol_run_info = 3;
  bool has_protocol_run_info() const;
  private:
  bool _internal_has_protocol_run_info() const;
  public:
  void clear_protocol_run_info();
  const ::minknow_api::protocol::ProtocolRunInfo& protocol_run_info() const;
  PROTOBUF_MUST_USE_RESULT ::minknow_api::protocol::ProtocolRunInfo* release_protocol_run_info();
  ::minknow_api::protocol::ProtocolRunInfo* mutable_protocol_run_info();
  void set_allocated_protocol_run_info(::minknow_api::protocol::ProtocolRunInfo* protocol_run_info);
  private:
  const ::minknow_api::protocol::ProtocolRunInfo& _internal_protocol_run_info() const;
  ::minknow_api::protocol::ProtocolRunInfo* _internal_mutable_protocol_run_info();
  public:
  void unsafe_arena_set_allocated_protocol_run_info(
      ::minknow_api::protocol::ProtocolRunInfo* protocol_run_info);
  ::minknow_api::protocol::ProtocolRunInfo* unsafe_arena_release_protocol_run_info();

  // .minknow_api.acquisition.AcquisitionRunInfo acquisition_run_info = 4;
  bool has_acquisition_run_info() const;
  private:
  bool _internal_has_acquisition_run_info() const;
  public:
  void clear_acquisition_run_info();
  const ::minknow_api::acquisition::AcquisitionRunInfo& acquisition_run_info() const;
  PROTOBUF_MUST_USE_RESULT ::minknow_api::acquisition::AcquisitionRunInfo* release_acquisition_run_info();
  ::minknow_api::acquisition::AcquisitionRunInfo* mutable_acquisition_run_info();
  void set_allocated_acquisition_run_info(::minknow_api::acquisition::AcquisitionRunInfo* acquisition_run_info);
  private:
  const ::minknow_api::acquisition::AcquisitionRunInfo& _internal_acquisition_run_info() const;
  ::minknow_api::acquisition::AcquisitionRunInfo* _internal_mutable_acquisition_run_info();
  public:
  void unsafe_arena_set_allocated_acquisition_run_info(
      ::minknow_api::acquisition::AcquisitionRunInfo* acquisition_run_info);
  ::minknow_api::acquisition::AcquisitionRunInfo* unsafe_arena_release_acquisition_run_info();

  // .minknow_api.instance.StreamInstanceActivityResponse.FlowCellHealth flow_cell_health = 5;
  bool has_flow_cell_health() const;
  private:
  bool _internal_has_flow_cell_health() const;
  public:
  void clear_flow_cell_health();
  const ::minknow_api::instance::StreamInstanceActivityResponse_FlowCellHealth& flow_cell_health() const;
  PROTOBUF_MUST_USE_RESULT ::minknow_api::instance::StreamInstanceActivityResponse_FlowCellHealth* release_flow_cell_health();
  ::minknow_api::instance::StreamInstanceActivityResponse_FlowCellHealth* mutable_flow_cell_health();
  void set_allocated_flow_cell_health(::minknow_api::instance::StreamInstanceActivityResponse_FlowCellHealth* flow_cell_health);
  private:
  const ::minknow_api::instance::StreamInstanceActivityResponse_FlowCellHealth& _internal_flow_cell_health() const;
  ::minknow_api::instance::StreamInstanceActivityResponse_FlowCellHealth* _internal_mutable_flow_cell_health();
  public:
  void unsafe_arena_set_allocated_flow_cell_health(
      ::minknow_api::instance::StreamInstanceActivityResponse_FlowCellHealth* flow_cell_health);
  ::minknow_api::instance::StreamInstanceActivityResponse_FlowCellHealth* unsafe_arena_release_flow_cell_health();

  // .minknow_api.acquisition.AcquisitionYieldSummary yield_summary = 6;
  bool has_yield_summary() const;
  private:
  bool _internal_has_yield_summary() const;
  public:
  void clear_yield_summary();
  const ::minknow_api::acquisition::AcquisitionYieldSummary& yield_summary() const;
  PROTOBUF_MUST_USE_RESULT ::minknow_api::acquisition::AcquisitionYieldSummary* release_yield_summary();
  ::minknow_api::acquisition::AcquisitionYieldSummary* mutable_yield_summary();
  void set_allocated_yield_summary(::minknow_api::acquisition::AcquisitionYieldSummary* yield_summary);
  private:
  const ::minknow_api::acquisition::AcquisitionYieldSummary& _internal_yield_summary() const;
  ::minknow_api::acquisition::AcquisitionYieldSummary* _internal_mutable_yield_summary();
  public:
  void unsafe_arena_set_allocated_yield_summary(
      ::minknow_api::acquisition::AcquisitionYieldSummary* yield_summary);
  ::minknow_api::acquisition::AcquisitionYieldSummary* unsafe_arena_release_yield_summary();

  // .minknow_api.instance.BasecallSpeed basecall_speed = 7;
  bool has_basecall_speed() const;
  private:
  bool _internal_has_basecall_speed() const;
  public:
  void clear_basecall_speed();
  const ::minknow_api::instance::BasecallSpeed& basecall_speed() const;
  PROTOBUF_MUST_USE_RESULT ::minknow_api::instance::BasecallSpeed* release_basecall_speed();
  ::minknow_api::instance::BasecallSpeed* mutable_basecall_speed();
  void set_allocated_basecall_speed(::minknow_api::instance::BasecallSpeed* basecall_speed);
  private:
  const ::minknow_api::instance::BasecallSpeed& _internal_basecall_speed() const;
  ::minknow_api::instance::BasecallSpeed* _internal_mutable_basecall_speed();
  public:
  void unsafe_arena_set_allocated_basecall_speed(
      ::minknow_api::instance::BasecallSpeed* basecall_speed);
  ::minknow_api::instance::BasecallSpeed* unsafe_arena_release_basecall_speed();

  // .minknow_api.instance.N50 n50 = 8;
  bool has_n50() const;
  private:
  bool _internal_has_n50() const;
  public:
  void clear_n50();
  const ::minknow_api::instance::N50& n50() const;
  PROTOBUF_MUST_USE_RESULT ::minknow_api::instance::N50* release_n50();
  ::minknow_api::instance::N50* mutable_n50();
  void set_allocated_n50(::minknow_api::instance::N50* n50);
  private:
  const ::minknow_api::instance::N50& _internal_n50() const;
  ::minknow_api::instance::N50* _internal_mutable_n50();
  public:
  void unsafe_arena_set_allocated_n50(
      ::minknow_api::instance::N50* n50);
  ::minknow_api::instance::N50* unsafe_arena_release_n50();

  void clear_stream_value();
  StreamValueCase stream_value_case() const;
  // @@protoc_insertion_point(class_scope:minknow_api.instance.StreamInstanceActivityResponse)
 private:
  class _Internal;
  void set_has_device_info();
  void set_has_flow_cell_info();
  void set_has_protocol_run_info();
  void set_has_acquisition_run_info();
  void set_has_flow_cell_health();
  void set_has_yield_summary();
  void set_has_basecall_speed();
  void set_has_n50();

  inline bool has_stream_value() const;
  inline void clear_has_stream_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union StreamValueUnion {
    constexpr StreamValueUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::minknow_api::instance::DeviceInfo* device_info_;
    ::minknow_api::device::GetFlowCellInfoResponse* flow_cell_info_;
    ::minknow_api::protocol::ProtocolRunInfo* protocol_run_info_;
    ::minknow_api::acquisition::AcquisitionRunInfo* acquisition_run_info_;
    ::minknow_api::instance::StreamInstanceActivityResponse_FlowCellHealth* flow_cell_health_;
    ::minknow_api::acquisition::AcquisitionYieldSummary* yield_summary_;
    ::minknow_api::instance::BasecallSpeed* basecall_speed_;
    ::minknow_api::instance::N50* n50_;
  } stream_value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_minknow_5fapi_2finstance_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GetVersionInfoRequest

// -------------------------------------------------------------------

// GetVersionInfoResponse_MinknowVersion

// int32 major = 1;
inline void GetVersionInfoResponse_MinknowVersion::clear_major() {
  major_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetVersionInfoResponse_MinknowVersion::_internal_major() const {
  return major_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetVersionInfoResponse_MinknowVersion::major() const {
  // @@protoc_insertion_point(field_get:minknow_api.instance.GetVersionInfoResponse.MinknowVersion.major)
  return _internal_major();
}
inline void GetVersionInfoResponse_MinknowVersion::_internal_set_major(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  major_ = value;
}
inline void GetVersionInfoResponse_MinknowVersion::set_major(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_major(value);
  // @@protoc_insertion_point(field_set:minknow_api.instance.GetVersionInfoResponse.MinknowVersion.major)
}

// int32 minor = 2;
inline void GetVersionInfoResponse_MinknowVersion::clear_minor() {
  minor_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetVersionInfoResponse_MinknowVersion::_internal_minor() const {
  return minor_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetVersionInfoResponse_MinknowVersion::minor() const {
  // @@protoc_insertion_point(field_get:minknow_api.instance.GetVersionInfoResponse.MinknowVersion.minor)
  return _internal_minor();
}
inline void GetVersionInfoResponse_MinknowVersion::_internal_set_minor(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  minor_ = value;
}
inline void GetVersionInfoResponse_MinknowVersion::set_minor(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_minor(value);
  // @@protoc_insertion_point(field_set:minknow_api.instance.GetVersionInfoResponse.MinknowVersion.minor)
}

// int32 patch = 3;
inline void GetVersionInfoResponse_MinknowVersion::clear_patch() {
  patch_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetVersionInfoResponse_MinknowVersion::_internal_patch() const {
  return patch_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetVersionInfoResponse_MinknowVersion::patch() const {
  // @@protoc_insertion_point(field_get:minknow_api.instance.GetVersionInfoResponse.MinknowVersion.patch)
  return _internal_patch();
}
inline void GetVersionInfoResponse_MinknowVersion::_internal_set_patch(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  patch_ = value;
}
inline void GetVersionInfoResponse_MinknowVersion::set_patch(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_patch(value);
  // @@protoc_insertion_point(field_set:minknow_api.instance.GetVersionInfoResponse.MinknowVersion.patch)
}

// string full = 4;
inline void GetVersionInfoResponse_MinknowVersion::clear_full() {
  full_.ClearToEmpty();
}
inline const std::string& GetVersionInfoResponse_MinknowVersion::full() const {
  // @@protoc_insertion_point(field_get:minknow_api.instance.GetVersionInfoResponse.MinknowVersion.full)
  return _internal_full();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetVersionInfoResponse_MinknowVersion::set_full(ArgT0&& arg0, ArgT... args) {
 
 full_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.instance.GetVersionInfoResponse.MinknowVersion.full)
}
inline std::string* GetVersionInfoResponse_MinknowVersion::mutable_full() {
  std::string* _s = _internal_mutable_full();
  // @@protoc_insertion_point(field_mutable:minknow_api.instance.GetVersionInfoResponse.MinknowVersion.full)
  return _s;
}
inline const std::string& GetVersionInfoResponse_MinknowVersion::_internal_full() const {
  return full_.Get();
}
inline void GetVersionInfoResponse_MinknowVersion::_internal_set_full(const std::string& value) {
  
  full_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetVersionInfoResponse_MinknowVersion::_internal_mutable_full() {
  
  return full_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetVersionInfoResponse_MinknowVersion::release_full() {
  // @@protoc_insertion_point(field_release:minknow_api.instance.GetVersionInfoResponse.MinknowVersion.full)
  return full_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetVersionInfoResponse_MinknowVersion::set_allocated_full(std::string* full) {
  if (full != nullptr) {
    
  } else {
    
  }
  full_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), full,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.instance.GetVersionInfoResponse.MinknowVersion.full)
}

// -------------------------------------------------------------------

// GetVersionInfoResponse

// .minknow_api.instance.GetVersionInfoResponse.MinknowVersion minknow = 1;
inline bool GetVersionInfoResponse::_internal_has_minknow() const {
  return this != internal_default_instance() && minknow_ != nullptr;
}
inline bool GetVersionInfoResponse::has_minknow() const {
  return _internal_has_minknow();
}
inline void GetVersionInfoResponse::clear_minknow() {
  if (GetArenaForAllocation() == nullptr && minknow_ != nullptr) {
    delete minknow_;
  }
  minknow_ = nullptr;
}
inline const ::minknow_api::instance::GetVersionInfoResponse_MinknowVersion& GetVersionInfoResponse::_internal_minknow() const {
  const ::minknow_api::instance::GetVersionInfoResponse_MinknowVersion* p = minknow_;
  return p != nullptr ? *p : reinterpret_cast<const ::minknow_api::instance::GetVersionInfoResponse_MinknowVersion&>(
      ::minknow_api::instance::_GetVersionInfoResponse_MinknowVersion_default_instance_);
}
inline const ::minknow_api::instance::GetVersionInfoResponse_MinknowVersion& GetVersionInfoResponse::minknow() const {
  // @@protoc_insertion_point(field_get:minknow_api.instance.GetVersionInfoResponse.minknow)
  return _internal_minknow();
}
inline void GetVersionInfoResponse::unsafe_arena_set_allocated_minknow(
    ::minknow_api::instance::GetVersionInfoResponse_MinknowVersion* minknow) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(minknow_);
  }
  minknow_ = minknow;
  if (minknow) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minknow_api.instance.GetVersionInfoResponse.minknow)
}
inline ::minknow_api::instance::GetVersionInfoResponse_MinknowVersion* GetVersionInfoResponse::release_minknow() {
  
  ::minknow_api::instance::GetVersionInfoResponse_MinknowVersion* temp = minknow_;
  minknow_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::minknow_api::instance::GetVersionInfoResponse_MinknowVersion* GetVersionInfoResponse::unsafe_arena_release_minknow() {
  // @@protoc_insertion_point(field_release:minknow_api.instance.GetVersionInfoResponse.minknow)
  
  ::minknow_api::instance::GetVersionInfoResponse_MinknowVersion* temp = minknow_;
  minknow_ = nullptr;
  return temp;
}
inline ::minknow_api::instance::GetVersionInfoResponse_MinknowVersion* GetVersionInfoResponse::_internal_mutable_minknow() {
  
  if (minknow_ == nullptr) {
    auto* p = CreateMaybeMessage<::minknow_api::instance::GetVersionInfoResponse_MinknowVersion>(GetArenaForAllocation());
    minknow_ = p;
  }
  return minknow_;
}
inline ::minknow_api::instance::GetVersionInfoResponse_MinknowVersion* GetVersionInfoResponse::mutable_minknow() {
  ::minknow_api::instance::GetVersionInfoResponse_MinknowVersion* _msg = _internal_mutable_minknow();
  // @@protoc_insertion_point(field_mutable:minknow_api.instance.GetVersionInfoResponse.minknow)
  return _msg;
}
inline void GetVersionInfoResponse::set_allocated_minknow(::minknow_api::instance::GetVersionInfoResponse_MinknowVersion* minknow) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete minknow_;
  }
  if (minknow) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::minknow_api::instance::GetVersionInfoResponse_MinknowVersion>::GetOwningArena(minknow);
    if (message_arena != submessage_arena) {
      minknow = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, minknow, submessage_arena);
    }
    
  } else {
    
  }
  minknow_ = minknow;
  // @@protoc_insertion_point(field_set_allocated:minknow_api.instance.GetVersionInfoResponse.minknow)
}

// string protocols = 2;
inline void GetVersionInfoResponse::clear_protocols() {
  protocols_.ClearToEmpty();
}
inline const std::string& GetVersionInfoResponse::protocols() const {
  // @@protoc_insertion_point(field_get:minknow_api.instance.GetVersionInfoResponse.protocols)
  return _internal_protocols();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetVersionInfoResponse::set_protocols(ArgT0&& arg0, ArgT... args) {
 
 protocols_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.instance.GetVersionInfoResponse.protocols)
}
inline std::string* GetVersionInfoResponse::mutable_protocols() {
  std::string* _s = _internal_mutable_protocols();
  // @@protoc_insertion_point(field_mutable:minknow_api.instance.GetVersionInfoResponse.protocols)
  return _s;
}
inline const std::string& GetVersionInfoResponse::_internal_protocols() const {
  return protocols_.Get();
}
inline void GetVersionInfoResponse::_internal_set_protocols(const std::string& value) {
  
  protocols_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetVersionInfoResponse::_internal_mutable_protocols() {
  
  return protocols_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetVersionInfoResponse::release_protocols() {
  // @@protoc_insertion_point(field_release:minknow_api.instance.GetVersionInfoResponse.protocols)
  return protocols_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetVersionInfoResponse::set_allocated_protocols(std::string* protocols) {
  if (protocols != nullptr) {
    
  } else {
    
  }
  protocols_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), protocols,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.instance.GetVersionInfoResponse.protocols)
}

// string distribution_version = 3;
inline void GetVersionInfoResponse::clear_distribution_version() {
  distribution_version_.ClearToEmpty();
}
inline const std::string& GetVersionInfoResponse::distribution_version() const {
  // @@protoc_insertion_point(field_get:minknow_api.instance.GetVersionInfoResponse.distribution_version)
  return _internal_distribution_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetVersionInfoResponse::set_distribution_version(ArgT0&& arg0, ArgT... args) {
 
 distribution_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.instance.GetVersionInfoResponse.distribution_version)
}
inline std::string* GetVersionInfoResponse::mutable_distribution_version() {
  std::string* _s = _internal_mutable_distribution_version();
  // @@protoc_insertion_point(field_mutable:minknow_api.instance.GetVersionInfoResponse.distribution_version)
  return _s;
}
inline const std::string& GetVersionInfoResponse::_internal_distribution_version() const {
  return distribution_version_.Get();
}
inline void GetVersionInfoResponse::_internal_set_distribution_version(const std::string& value) {
  
  distribution_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetVersionInfoResponse::_internal_mutable_distribution_version() {
  
  return distribution_version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetVersionInfoResponse::release_distribution_version() {
  // @@protoc_insertion_point(field_release:minknow_api.instance.GetVersionInfoResponse.distribution_version)
  return distribution_version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetVersionInfoResponse::set_allocated_distribution_version(std::string* distribution_version) {
  if (distribution_version != nullptr) {
    
  } else {
    
  }
  distribution_version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), distribution_version,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.instance.GetVersionInfoResponse.distribution_version)
}

// .minknow_api.instance.GetVersionInfoResponse.DistributionStatus distribution_status = 4;
inline void GetVersionInfoResponse::clear_distribution_status() {
  distribution_status_ = 0;
}
inline ::minknow_api::instance::GetVersionInfoResponse_DistributionStatus GetVersionInfoResponse::_internal_distribution_status() const {
  return static_cast< ::minknow_api::instance::GetVersionInfoResponse_DistributionStatus >(distribution_status_);
}
inline ::minknow_api::instance::GetVersionInfoResponse_DistributionStatus GetVersionInfoResponse::distribution_status() const {
  // @@protoc_insertion_point(field_get:minknow_api.instance.GetVersionInfoResponse.distribution_status)
  return _internal_distribution_status();
}
inline void GetVersionInfoResponse::_internal_set_distribution_status(::minknow_api::instance::GetVersionInfoResponse_DistributionStatus value) {
  
  distribution_status_ = value;
}
inline void GetVersionInfoResponse::set_distribution_status(::minknow_api::instance::GetVersionInfoResponse_DistributionStatus value) {
  _internal_set_distribution_status(value);
  // @@protoc_insertion_point(field_set:minknow_api.instance.GetVersionInfoResponse.distribution_status)
}

// string configuration = 5;
inline void GetVersionInfoResponse::clear_configuration() {
  configuration_.ClearToEmpty();
}
inline const std::string& GetVersionInfoResponse::configuration() const {
  // @@protoc_insertion_point(field_get:minknow_api.instance.GetVersionInfoResponse.configuration)
  return _internal_configuration();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetVersionInfoResponse::set_configuration(ArgT0&& arg0, ArgT... args) {
 
 configuration_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.instance.GetVersionInfoResponse.configuration)
}
inline std::string* GetVersionInfoResponse::mutable_configuration() {
  std::string* _s = _internal_mutable_configuration();
  // @@protoc_insertion_point(field_mutable:minknow_api.instance.GetVersionInfoResponse.configuration)
  return _s;
}
inline const std::string& GetVersionInfoResponse::_internal_configuration() const {
  return configuration_.Get();
}
inline void GetVersionInfoResponse::_internal_set_configuration(const std::string& value) {
  
  configuration_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetVersionInfoResponse::_internal_mutable_configuration() {
  
  return configuration_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetVersionInfoResponse::release_configuration() {
  // @@protoc_insertion_point(field_release:minknow_api.instance.GetVersionInfoResponse.configuration)
  return configuration_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetVersionInfoResponse::set_allocated_configuration(std::string* configuration) {
  if (configuration != nullptr) {
    
  } else {
    
  }
  configuration_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), configuration,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.instance.GetVersionInfoResponse.configuration)
}

// .minknow_api.instance.GetVersionInfoResponse.InstallationType installation_type = 6;
inline void GetVersionInfoResponse::clear_installation_type() {
  installation_type_ = 0;
}
inline ::minknow_api::instance::GetVersionInfoResponse_InstallationType GetVersionInfoResponse::_internal_installation_type() const {
  return static_cast< ::minknow_api::instance::GetVersionInfoResponse_InstallationType >(installation_type_);
}
inline ::minknow_api::instance::GetVersionInfoResponse_InstallationType GetVersionInfoResponse::installation_type() const {
  // @@protoc_insertion_point(field_get:minknow_api.instance.GetVersionInfoResponse.installation_type)
  return _internal_installation_type();
}
inline void GetVersionInfoResponse::_internal_set_installation_type(::minknow_api::instance::GetVersionInfoResponse_InstallationType value) {
  
  installation_type_ = value;
}
inline void GetVersionInfoResponse::set_installation_type(::minknow_api::instance::GetVersionInfoResponse_InstallationType value) {
  _internal_set_installation_type(value);
  // @@protoc_insertion_point(field_set:minknow_api.instance.GetVersionInfoResponse.installation_type)
}

// -------------------------------------------------------------------

// GetOutputDirectoriesRequest

// -------------------------------------------------------------------

// OutputDirectories

// string output = 1;
inline void OutputDirectories::clear_output() {
  output_.ClearToEmpty();
}
inline const std::string& OutputDirectories::output() const {
  // @@protoc_insertion_point(field_get:minknow_api.instance.OutputDirectories.output)
  return _internal_output();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OutputDirectories::set_output(ArgT0&& arg0, ArgT... args) {
 
 output_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.instance.OutputDirectories.output)
}
inline std::string* OutputDirectories::mutable_output() {
  std::string* _s = _internal_mutable_output();
  // @@protoc_insertion_point(field_mutable:minknow_api.instance.OutputDirectories.output)
  return _s;
}
inline const std::string& OutputDirectories::_internal_output() const {
  return output_.Get();
}
inline void OutputDirectories::_internal_set_output(const std::string& value) {
  
  output_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OutputDirectories::_internal_mutable_output() {
  
  return output_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OutputDirectories::release_output() {
  // @@protoc_insertion_point(field_release:minknow_api.instance.OutputDirectories.output)
  return output_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OutputDirectories::set_allocated_output(std::string* output) {
  if (output != nullptr) {
    
  } else {
    
  }
  output_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), output,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.instance.OutputDirectories.output)
}

// string log = 2;
inline void OutputDirectories::clear_log() {
  log_.ClearToEmpty();
}
inline const std::string& OutputDirectories::log() const {
  // @@protoc_insertion_point(field_get:minknow_api.instance.OutputDirectories.log)
  return _internal_log();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OutputDirectories::set_log(ArgT0&& arg0, ArgT... args) {
 
 log_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.instance.OutputDirectories.log)
}
inline std::string* OutputDirectories::mutable_log() {
  std::string* _s = _internal_mutable_log();
  // @@protoc_insertion_point(field_mutable:minknow_api.instance.OutputDirectories.log)
  return _s;
}
inline const std::string& OutputDirectories::_internal_log() const {
  return log_.Get();
}
inline void OutputDirectories::_internal_set_log(const std::string& value) {
  
  log_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OutputDirectories::_internal_mutable_log() {
  
  return log_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OutputDirectories::release_log() {
  // @@protoc_insertion_point(field_release:minknow_api.instance.OutputDirectories.log)
  return log_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OutputDirectories::set_allocated_log(std::string* log) {
  if (log != nullptr) {
    
  } else {
    
  }
  log_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), log,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.instance.OutputDirectories.log)
}

// string reads = 3;
inline void OutputDirectories::clear_reads() {
  reads_.ClearToEmpty();
}
inline const std::string& OutputDirectories::reads() const {
  // @@protoc_insertion_point(field_get:minknow_api.instance.OutputDirectories.reads)
  return _internal_reads();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OutputDirectories::set_reads(ArgT0&& arg0, ArgT... args) {
 
 reads_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.instance.OutputDirectories.reads)
}
inline std::string* OutputDirectories::mutable_reads() {
  std::string* _s = _internal_mutable_reads();
  // @@protoc_insertion_point(field_mutable:minknow_api.instance.OutputDirectories.reads)
  return _s;
}
inline const std::string& OutputDirectories::_internal_reads() const {
  return reads_.Get();
}
inline void OutputDirectories::_internal_set_reads(const std::string& value) {
  
  reads_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OutputDirectories::_internal_mutable_reads() {
  
  return reads_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OutputDirectories::release_reads() {
  // @@protoc_insertion_point(field_release:minknow_api.instance.OutputDirectories.reads)
  return reads_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OutputDirectories::set_allocated_reads(std::string* reads) {
  if (reads != nullptr) {
    
  } else {
    
  }
  reads_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reads,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.instance.OutputDirectories.reads)
}

// -------------------------------------------------------------------

// GetDefaultOutputDirectoriesRequest

// -------------------------------------------------------------------

// SetOutputDirectoryRequest

// string path = 1;
inline void SetOutputDirectoryRequest::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& SetOutputDirectoryRequest::path() const {
  // @@protoc_insertion_point(field_get:minknow_api.instance.SetOutputDirectoryRequest.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetOutputDirectoryRequest::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.instance.SetOutputDirectoryRequest.path)
}
inline std::string* SetOutputDirectoryRequest::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:minknow_api.instance.SetOutputDirectoryRequest.path)
  return _s;
}
inline const std::string& SetOutputDirectoryRequest::_internal_path() const {
  return path_.Get();
}
inline void SetOutputDirectoryRequest::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SetOutputDirectoryRequest::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SetOutputDirectoryRequest::release_path() {
  // @@protoc_insertion_point(field_release:minknow_api.instance.SetOutputDirectoryRequest.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SetOutputDirectoryRequest::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.instance.SetOutputDirectoryRequest.path)
}

// -------------------------------------------------------------------

// SetOutputDirectoryResponse

// -------------------------------------------------------------------

// SetReadsDirectoryRequest

// string path = 1;
inline void SetReadsDirectoryRequest::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& SetReadsDirectoryRequest::path() const {
  // @@protoc_insertion_point(field_get:minknow_api.instance.SetReadsDirectoryRequest.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetReadsDirectoryRequest::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.instance.SetReadsDirectoryRequest.path)
}
inline std::string* SetReadsDirectoryRequest::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:minknow_api.instance.SetReadsDirectoryRequest.path)
  return _s;
}
inline const std::string& SetReadsDirectoryRequest::_internal_path() const {
  return path_.Get();
}
inline void SetReadsDirectoryRequest::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SetReadsDirectoryRequest::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SetReadsDirectoryRequest::release_path() {
  // @@protoc_insertion_point(field_release:minknow_api.instance.SetReadsDirectoryRequest.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SetReadsDirectoryRequest::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.instance.SetReadsDirectoryRequest.path)
}

// -------------------------------------------------------------------

// SetReadsDirectoryResponse

// -------------------------------------------------------------------

// FilesystemDiskSpaceInfo

// string filesystem_id = 1;
inline void FilesystemDiskSpaceInfo::clear_filesystem_id() {
  filesystem_id_.ClearToEmpty();
}
inline const std::string& FilesystemDiskSpaceInfo::filesystem_id() const {
  // @@protoc_insertion_point(field_get:minknow_api.instance.FilesystemDiskSpaceInfo.filesystem_id)
  return _internal_filesystem_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FilesystemDiskSpaceInfo::set_filesystem_id(ArgT0&& arg0, ArgT... args) {
 
 filesystem_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.instance.FilesystemDiskSpaceInfo.filesystem_id)
}
inline std::string* FilesystemDiskSpaceInfo::mutable_filesystem_id() {
  std::string* _s = _internal_mutable_filesystem_id();
  // @@protoc_insertion_point(field_mutable:minknow_api.instance.FilesystemDiskSpaceInfo.filesystem_id)
  return _s;
}
inline const std::string& FilesystemDiskSpaceInfo::_internal_filesystem_id() const {
  return filesystem_id_.Get();
}
inline void FilesystemDiskSpaceInfo::_internal_set_filesystem_id(const std::string& value) {
  
  filesystem_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FilesystemDiskSpaceInfo::_internal_mutable_filesystem_id() {
  
  return filesystem_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FilesystemDiskSpaceInfo::release_filesystem_id() {
  // @@protoc_insertion_point(field_release:minknow_api.instance.FilesystemDiskSpaceInfo.filesystem_id)
  return filesystem_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FilesystemDiskSpaceInfo::set_allocated_filesystem_id(std::string* filesystem_id) {
  if (filesystem_id != nullptr) {
    
  } else {
    
  }
  filesystem_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filesystem_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.instance.FilesystemDiskSpaceInfo.filesystem_id)
}

// uint64 bytes_available = 2;
inline void FilesystemDiskSpaceInfo::clear_bytes_available() {
  bytes_available_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FilesystemDiskSpaceInfo::_internal_bytes_available() const {
  return bytes_available_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FilesystemDiskSpaceInfo::bytes_available() const {
  // @@protoc_insertion_point(field_get:minknow_api.instance.FilesystemDiskSpaceInfo.bytes_available)
  return _internal_bytes_available();
}
inline void FilesystemDiskSpaceInfo::_internal_set_bytes_available(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  bytes_available_ = value;
}
inline void FilesystemDiskSpaceInfo::set_bytes_available(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_bytes_available(value);
  // @@protoc_insertion_point(field_set:minknow_api.instance.FilesystemDiskSpaceInfo.bytes_available)
}

// uint64 bytes_capacity = 3;
inline void FilesystemDiskSpaceInfo::clear_bytes_capacity() {
  bytes_capacity_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FilesystemDiskSpaceInfo::_internal_bytes_capacity() const {
  return bytes_capacity_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FilesystemDiskSpaceInfo::bytes_capacity() const {
  // @@protoc_insertion_point(field_get:minknow_api.instance.FilesystemDiskSpaceInfo.bytes_capacity)
  return _internal_bytes_capacity();
}
inline void FilesystemDiskSpaceInfo::_internal_set_bytes_capacity(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  bytes_capacity_ = value;
}
inline void FilesystemDiskSpaceInfo::set_bytes_capacity(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_bytes_capacity(value);
  // @@protoc_insertion_point(field_set:minknow_api.instance.FilesystemDiskSpaceInfo.bytes_capacity)
}

// repeated string what = 4;
inline int FilesystemDiskSpaceInfo::_internal_what_size() const {
  return what_.size();
}
inline int FilesystemDiskSpaceInfo::what_size() const {
  return _internal_what_size();
}
inline void FilesystemDiskSpaceInfo::clear_what() {
  what_.Clear();
}
inline std::string* FilesystemDiskSpaceInfo::add_what() {
  std::string* _s = _internal_add_what();
  // @@protoc_insertion_point(field_add_mutable:minknow_api.instance.FilesystemDiskSpaceInfo.what)
  return _s;
}
inline const std::string& FilesystemDiskSpaceInfo::_internal_what(int index) const {
  return what_.Get(index);
}
inline const std::string& FilesystemDiskSpaceInfo::what(int index) const {
  // @@protoc_insertion_point(field_get:minknow_api.instance.FilesystemDiskSpaceInfo.what)
  return _internal_what(index);
}
inline std::string* FilesystemDiskSpaceInfo::mutable_what(int index) {
  // @@protoc_insertion_point(field_mutable:minknow_api.instance.FilesystemDiskSpaceInfo.what)
  return what_.Mutable(index);
}
inline void FilesystemDiskSpaceInfo::set_what(int index, const std::string& value) {
  what_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:minknow_api.instance.FilesystemDiskSpaceInfo.what)
}
inline void FilesystemDiskSpaceInfo::set_what(int index, std::string&& value) {
  what_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:minknow_api.instance.FilesystemDiskSpaceInfo.what)
}
inline void FilesystemDiskSpaceInfo::set_what(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  what_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:minknow_api.instance.FilesystemDiskSpaceInfo.what)
}
inline void FilesystemDiskSpaceInfo::set_what(int index, const char* value, size_t size) {
  what_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:minknow_api.instance.FilesystemDiskSpaceInfo.what)
}
inline std::string* FilesystemDiskSpaceInfo::_internal_add_what() {
  return what_.Add();
}
inline void FilesystemDiskSpaceInfo::add_what(const std::string& value) {
  what_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:minknow_api.instance.FilesystemDiskSpaceInfo.what)
}
inline void FilesystemDiskSpaceInfo::add_what(std::string&& value) {
  what_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:minknow_api.instance.FilesystemDiskSpaceInfo.what)
}
inline void FilesystemDiskSpaceInfo::add_what(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  what_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:minknow_api.instance.FilesystemDiskSpaceInfo.what)
}
inline void FilesystemDiskSpaceInfo::add_what(const char* value, size_t size) {
  what_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:minknow_api.instance.FilesystemDiskSpaceInfo.what)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FilesystemDiskSpaceInfo::what() const {
  // @@protoc_insertion_point(field_list:minknow_api.instance.FilesystemDiskSpaceInfo.what)
  return what_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FilesystemDiskSpaceInfo::mutable_what() {
  // @@protoc_insertion_point(field_mutable_list:minknow_api.instance.FilesystemDiskSpaceInfo.what)
  return &what_;
}

// uint64 bytes_to_stop_cleanly = 5;
inline void FilesystemDiskSpaceInfo::clear_bytes_to_stop_cleanly() {
  bytes_to_stop_cleanly_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FilesystemDiskSpaceInfo::_internal_bytes_to_stop_cleanly() const {
  return bytes_to_stop_cleanly_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FilesystemDiskSpaceInfo::bytes_to_stop_cleanly() const {
  // @@protoc_insertion_point(field_get:minknow_api.instance.FilesystemDiskSpaceInfo.bytes_to_stop_cleanly)
  return _internal_bytes_to_stop_cleanly();
}
inline void FilesystemDiskSpaceInfo::_internal_set_bytes_to_stop_cleanly(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  bytes_to_stop_cleanly_ = value;
}
inline void FilesystemDiskSpaceInfo::set_bytes_to_stop_cleanly(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_bytes_to_stop_cleanly(value);
  // @@protoc_insertion_point(field_set:minknow_api.instance.FilesystemDiskSpaceInfo.bytes_to_stop_cleanly)
}

// uint64 bytes_when_alert_issued = 6;
inline void FilesystemDiskSpaceInfo::clear_bytes_when_alert_issued() {
  bytes_when_alert_issued_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FilesystemDiskSpaceInfo::_internal_bytes_when_alert_issued() const {
  return bytes_when_alert_issued_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FilesystemDiskSpaceInfo::bytes_when_alert_issued() const {
  // @@protoc_insertion_point(field_get:minknow_api.instance.FilesystemDiskSpaceInfo.bytes_when_alert_issued)
  return _internal_bytes_when_alert_issued();
}
inline void FilesystemDiskSpaceInfo::_internal_set_bytes_when_alert_issued(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  bytes_when_alert_issued_ = value;
}
inline void FilesystemDiskSpaceInfo::set_bytes_when_alert_issued(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_bytes_when_alert_issued(value);
  // @@protoc_insertion_point(field_set:minknow_api.instance.FilesystemDiskSpaceInfo.bytes_when_alert_issued)
}

// bool recommend_alert = 7;
inline void FilesystemDiskSpaceInfo::clear_recommend_alert() {
  recommend_alert_ = false;
}
inline bool FilesystemDiskSpaceInfo::_internal_recommend_alert() const {
  return recommend_alert_;
}
inline bool FilesystemDiskSpaceInfo::recommend_alert() const {
  // @@protoc_insertion_point(field_get:minknow_api.instance.FilesystemDiskSpaceInfo.recommend_alert)
  return _internal_recommend_alert();
}
inline void FilesystemDiskSpaceInfo::_internal_set_recommend_alert(bool value) {
  
  recommend_alert_ = value;
}
inline void FilesystemDiskSpaceInfo::set_recommend_alert(bool value) {
  _internal_set_recommend_alert(value);
  // @@protoc_insertion_point(field_set:minknow_api.instance.FilesystemDiskSpaceInfo.recommend_alert)
}

// bool recommend_stop = 8;
inline void FilesystemDiskSpaceInfo::clear_recommend_stop() {
  recommend_stop_ = false;
}
inline bool FilesystemDiskSpaceInfo::_internal_recommend_stop() const {
  return recommend_stop_;
}
inline bool FilesystemDiskSpaceInfo::recommend_stop() const {
  // @@protoc_insertion_point(field_get:minknow_api.instance.FilesystemDiskSpaceInfo.recommend_stop)
  return _internal_recommend_stop();
}
inline void FilesystemDiskSpaceInfo::_internal_set_recommend_stop(bool value) {
  
  recommend_stop_ = value;
}
inline void FilesystemDiskSpaceInfo::set_recommend_stop(bool value) {
  _internal_set_recommend_stop(value);
  // @@protoc_insertion_point(field_set:minknow_api.instance.FilesystemDiskSpaceInfo.recommend_stop)
}

// int64 bytes_per_second = 9;
inline void FilesystemDiskSpaceInfo::clear_bytes_per_second() {
  bytes_per_second_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FilesystemDiskSpaceInfo::_internal_bytes_per_second() const {
  return bytes_per_second_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FilesystemDiskSpaceInfo::bytes_per_second() const {
  // @@protoc_insertion_point(field_get:minknow_api.instance.FilesystemDiskSpaceInfo.bytes_per_second)
  return _internal_bytes_per_second();
}
inline void FilesystemDiskSpaceInfo::_internal_set_bytes_per_second(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  bytes_per_second_ = value;
}
inline void FilesystemDiskSpaceInfo::set_bytes_per_second(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_bytes_per_second(value);
  // @@protoc_insertion_point(field_set:minknow_api.instance.FilesystemDiskSpaceInfo.bytes_per_second)
}

// -------------------------------------------------------------------

// GetDiskSpaceInfoRequest

// -------------------------------------------------------------------

// StreamDiskSpaceInfoRequest

// uint32 period = 1;
inline void StreamDiskSpaceInfoRequest::clear_period() {
  period_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StreamDiskSpaceInfoRequest::_internal_period() const {
  return period_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StreamDiskSpaceInfoRequest::period() const {
  // @@protoc_insertion_point(field_get:minknow_api.instance.StreamDiskSpaceInfoRequest.period)
  return _internal_period();
}
inline void StreamDiskSpaceInfoRequest::_internal_set_period(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  period_ = value;
}
inline void StreamDiskSpaceInfoRequest::set_period(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_period(value);
  // @@protoc_insertion_point(field_set:minknow_api.instance.StreamDiskSpaceInfoRequest.period)
}

// -------------------------------------------------------------------

// GetDiskSpaceInfoResponse

// repeated .minknow_api.instance.FilesystemDiskSpaceInfo filesystem_disk_space_info = 1;
inline int GetDiskSpaceInfoResponse::_internal_filesystem_disk_space_info_size() const {
  return filesystem_disk_space_info_.size();
}
inline int GetDiskSpaceInfoResponse::filesystem_disk_space_info_size() const {
  return _internal_filesystem_disk_space_info_size();
}
inline void GetDiskSpaceInfoResponse::clear_filesystem_disk_space_info() {
  filesystem_disk_space_info_.Clear();
}
inline ::minknow_api::instance::FilesystemDiskSpaceInfo* GetDiskSpaceInfoResponse::mutable_filesystem_disk_space_info(int index) {
  // @@protoc_insertion_point(field_mutable:minknow_api.instance.GetDiskSpaceInfoResponse.filesystem_disk_space_info)
  return filesystem_disk_space_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::instance::FilesystemDiskSpaceInfo >*
GetDiskSpaceInfoResponse::mutable_filesystem_disk_space_info() {
  // @@protoc_insertion_point(field_mutable_list:minknow_api.instance.GetDiskSpaceInfoResponse.filesystem_disk_space_info)
  return &filesystem_disk_space_info_;
}
inline const ::minknow_api::instance::FilesystemDiskSpaceInfo& GetDiskSpaceInfoResponse::_internal_filesystem_disk_space_info(int index) const {
  return filesystem_disk_space_info_.Get(index);
}
inline const ::minknow_api::instance::FilesystemDiskSpaceInfo& GetDiskSpaceInfoResponse::filesystem_disk_space_info(int index) const {
  // @@protoc_insertion_point(field_get:minknow_api.instance.GetDiskSpaceInfoResponse.filesystem_disk_space_info)
  return _internal_filesystem_disk_space_info(index);
}
inline ::minknow_api::instance::FilesystemDiskSpaceInfo* GetDiskSpaceInfoResponse::_internal_add_filesystem_disk_space_info() {
  return filesystem_disk_space_info_.Add();
}
inline ::minknow_api::instance::FilesystemDiskSpaceInfo* GetDiskSpaceInfoResponse::add_filesystem_disk_space_info() {
  ::minknow_api::instance::FilesystemDiskSpaceInfo* _add = _internal_add_filesystem_disk_space_info();
  // @@protoc_insertion_point(field_add:minknow_api.instance.GetDiskSpaceInfoResponse.filesystem_disk_space_info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::instance::FilesystemDiskSpaceInfo >&
GetDiskSpaceInfoResponse::filesystem_disk_space_info() const {
  // @@protoc_insertion_point(field_list:minknow_api.instance.GetDiskSpaceInfoResponse.filesystem_disk_space_info)
  return filesystem_disk_space_info_;
}

// -------------------------------------------------------------------

// GetMachineIdRequest

// -------------------------------------------------------------------

// GetMachineIdResponse

// string machine_id = 1;
inline void GetMachineIdResponse::clear_machine_id() {
  machine_id_.ClearToEmpty();
}
inline const std::string& GetMachineIdResponse::machine_id() const {
  // @@protoc_insertion_point(field_get:minknow_api.instance.GetMachineIdResponse.machine_id)
  return _internal_machine_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetMachineIdResponse::set_machine_id(ArgT0&& arg0, ArgT... args) {
 
 machine_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.instance.GetMachineIdResponse.machine_id)
}
inline std::string* GetMachineIdResponse::mutable_machine_id() {
  std::string* _s = _internal_mutable_machine_id();
  // @@protoc_insertion_point(field_mutable:minknow_api.instance.GetMachineIdResponse.machine_id)
  return _s;
}
inline const std::string& GetMachineIdResponse::_internal_machine_id() const {
  return machine_id_.Get();
}
inline void GetMachineIdResponse::_internal_set_machine_id(const std::string& value) {
  
  machine_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetMachineIdResponse::_internal_mutable_machine_id() {
  
  return machine_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetMachineIdResponse::release_machine_id() {
  // @@protoc_insertion_point(field_release:minknow_api.instance.GetMachineIdResponse.machine_id)
  return machine_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetMachineIdResponse::set_allocated_machine_id(std::string* machine_id) {
  if (machine_id != nullptr) {
    
  } else {
    
  }
  machine_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), machine_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.instance.GetMachineIdResponse.machine_id)
}

// -------------------------------------------------------------------

// StreamInstanceActivityRequest

// -------------------------------------------------------------------

// DeviceInfo

// .minknow_api.device.GetDeviceStateResponse.DeviceState device_state = 1;
inline void DeviceInfo::clear_device_state() {
  device_state_ = 0;
}
inline ::minknow_api::device::GetDeviceStateResponse_DeviceState DeviceInfo::_internal_device_state() const {
  return static_cast< ::minknow_api::device::GetDeviceStateResponse_DeviceState >(device_state_);
}
inline ::minknow_api::device::GetDeviceStateResponse_DeviceState DeviceInfo::device_state() const {
  // @@protoc_insertion_point(field_get:minknow_api.instance.DeviceInfo.device_state)
  return _internal_device_state();
}
inline void DeviceInfo::_internal_set_device_state(::minknow_api::device::GetDeviceStateResponse_DeviceState value) {
  
  device_state_ = value;
}
inline void DeviceInfo::set_device_state(::minknow_api::device::GetDeviceStateResponse_DeviceState value) {
  _internal_set_device_state(value);
  // @@protoc_insertion_point(field_set:minknow_api.instance.DeviceInfo.device_state)
}

// .minknow_api.device.GetDeviceInfoResponse device_info = 2;
inline bool DeviceInfo::_internal_has_device_info() const {
  return this != internal_default_instance() && device_info_ != nullptr;
}
inline bool DeviceInfo::has_device_info() const {
  return _internal_has_device_info();
}
inline const ::minknow_api::device::GetDeviceInfoResponse& DeviceInfo::_internal_device_info() const {
  const ::minknow_api::device::GetDeviceInfoResponse* p = device_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::minknow_api::device::GetDeviceInfoResponse&>(
      ::minknow_api::device::_GetDeviceInfoResponse_default_instance_);
}
inline const ::minknow_api::device::GetDeviceInfoResponse& DeviceInfo::device_info() const {
  // @@protoc_insertion_point(field_get:minknow_api.instance.DeviceInfo.device_info)
  return _internal_device_info();
}
inline void DeviceInfo::unsafe_arena_set_allocated_device_info(
    ::minknow_api::device::GetDeviceInfoResponse* device_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device_info_);
  }
  device_info_ = device_info;
  if (device_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minknow_api.instance.DeviceInfo.device_info)
}
inline ::minknow_api::device::GetDeviceInfoResponse* DeviceInfo::release_device_info() {
  
  ::minknow_api::device::GetDeviceInfoResponse* temp = device_info_;
  device_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::minknow_api::device::GetDeviceInfoResponse* DeviceInfo::unsafe_arena_release_device_info() {
  // @@protoc_insertion_point(field_release:minknow_api.instance.DeviceInfo.device_info)
  
  ::minknow_api::device::GetDeviceInfoResponse* temp = device_info_;
  device_info_ = nullptr;
  return temp;
}
inline ::minknow_api::device::GetDeviceInfoResponse* DeviceInfo::_internal_mutable_device_info() {
  
  if (device_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::minknow_api::device::GetDeviceInfoResponse>(GetArenaForAllocation());
    device_info_ = p;
  }
  return device_info_;
}
inline ::minknow_api::device::GetDeviceInfoResponse* DeviceInfo::mutable_device_info() {
  ::minknow_api::device::GetDeviceInfoResponse* _msg = _internal_mutable_device_info();
  // @@protoc_insertion_point(field_mutable:minknow_api.instance.DeviceInfo.device_info)
  return _msg;
}
inline void DeviceInfo::set_allocated_device_info(::minknow_api::device::GetDeviceInfoResponse* device_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(device_info_);
  }
  if (device_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device_info));
    if (message_arena != submessage_arena) {
      device_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_info, submessage_arena);
    }
    
  } else {
    
  }
  device_info_ = device_info;
  // @@protoc_insertion_point(field_set_allocated:minknow_api.instance.DeviceInfo.device_info)
}

// -------------------------------------------------------------------

// BasecallSpeed

// float mean_basecall_speed = 1;
inline void BasecallSpeed::clear_mean_basecall_speed() {
  mean_basecall_speed_ = 0;
}
inline float BasecallSpeed::_internal_mean_basecall_speed() const {
  return mean_basecall_speed_;
}
inline float BasecallSpeed::mean_basecall_speed() const {
  // @@protoc_insertion_point(field_get:minknow_api.instance.BasecallSpeed.mean_basecall_speed)
  return _internal_mean_basecall_speed();
}
inline void BasecallSpeed::_internal_set_mean_basecall_speed(float value) {
  
  mean_basecall_speed_ = value;
}
inline void BasecallSpeed::set_mean_basecall_speed(float value) {
  _internal_set_mean_basecall_speed(value);
  // @@protoc_insertion_point(field_set:minknow_api.instance.BasecallSpeed.mean_basecall_speed)
}

// -------------------------------------------------------------------

// N50

// float n50 = 1;
inline void N50::clear_n50() {
  n50_ = 0;
}
inline float N50::_internal_n50() const {
  return n50_;
}
inline float N50::n50() const {
  // @@protoc_insertion_point(field_get:minknow_api.instance.N50.n50)
  return _internal_n50();
}
inline void N50::_internal_set_n50(float value) {
  
  n50_ = value;
}
inline void N50::set_n50(float value) {
  _internal_set_n50(value);
  // @@protoc_insertion_point(field_set:minknow_api.instance.N50.n50)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// StreamInstanceActivityResponse_FlowCellHealth

// map<string, float> channel_state_percentages = 1;
inline int StreamInstanceActivityResponse_FlowCellHealth::_internal_channel_state_percentages_size() const {
  return channel_state_percentages_.size();
}
inline int StreamInstanceActivityResponse_FlowCellHealth::channel_state_percentages_size() const {
  return _internal_channel_state_percentages_size();
}
inline void StreamInstanceActivityResponse_FlowCellHealth::clear_channel_state_percentages() {
  channel_state_percentages_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, float >&
StreamInstanceActivityResponse_FlowCellHealth::_internal_channel_state_percentages() const {
  return channel_state_percentages_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, float >&
StreamInstanceActivityResponse_FlowCellHealth::channel_state_percentages() const {
  // @@protoc_insertion_point(field_map:minknow_api.instance.StreamInstanceActivityResponse.FlowCellHealth.channel_state_percentages)
  return _internal_channel_state_percentages();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, float >*
StreamInstanceActivityResponse_FlowCellHealth::_internal_mutable_channel_state_percentages() {
  return channel_state_percentages_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, float >*
StreamInstanceActivityResponse_FlowCellHealth::mutable_channel_state_percentages() {
  // @@protoc_insertion_point(field_mutable_map:minknow_api.instance.StreamInstanceActivityResponse.FlowCellHealth.channel_state_percentages)
  return _internal_mutable_channel_state_percentages();
}

// -------------------------------------------------------------------

// StreamInstanceActivityResponse

// .minknow_api.instance.DeviceInfo device_info = 1;
inline bool StreamInstanceActivityResponse::_internal_has_device_info() const {
  return stream_value_case() == kDeviceInfo;
}
inline bool StreamInstanceActivityResponse::has_device_info() const {
  return _internal_has_device_info();
}
inline void StreamInstanceActivityResponse::set_has_device_info() {
  _oneof_case_[0] = kDeviceInfo;
}
inline void StreamInstanceActivityResponse::clear_device_info() {
  if (_internal_has_device_info()) {
    if (GetArenaForAllocation() == nullptr) {
      delete stream_value_.device_info_;
    }
    clear_has_stream_value();
  }
}
inline ::minknow_api::instance::DeviceInfo* StreamInstanceActivityResponse::release_device_info() {
  // @@protoc_insertion_point(field_release:minknow_api.instance.StreamInstanceActivityResponse.device_info)
  if (_internal_has_device_info()) {
    clear_has_stream_value();
      ::minknow_api::instance::DeviceInfo* temp = stream_value_.device_info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    stream_value_.device_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::minknow_api::instance::DeviceInfo& StreamInstanceActivityResponse::_internal_device_info() const {
  return _internal_has_device_info()
      ? *stream_value_.device_info_
      : reinterpret_cast< ::minknow_api::instance::DeviceInfo&>(::minknow_api::instance::_DeviceInfo_default_instance_);
}
inline const ::minknow_api::instance::DeviceInfo& StreamInstanceActivityResponse::device_info() const {
  // @@protoc_insertion_point(field_get:minknow_api.instance.StreamInstanceActivityResponse.device_info)
  return _internal_device_info();
}
inline ::minknow_api::instance::DeviceInfo* StreamInstanceActivityResponse::unsafe_arena_release_device_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:minknow_api.instance.StreamInstanceActivityResponse.device_info)
  if (_internal_has_device_info()) {
    clear_has_stream_value();
    ::minknow_api::instance::DeviceInfo* temp = stream_value_.device_info_;
    stream_value_.device_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamInstanceActivityResponse::unsafe_arena_set_allocated_device_info(::minknow_api::instance::DeviceInfo* device_info) {
  clear_stream_value();
  if (device_info) {
    set_has_device_info();
    stream_value_.device_info_ = device_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minknow_api.instance.StreamInstanceActivityResponse.device_info)
}
inline ::minknow_api::instance::DeviceInfo* StreamInstanceActivityResponse::_internal_mutable_device_info() {
  if (!_internal_has_device_info()) {
    clear_stream_value();
    set_has_device_info();
    stream_value_.device_info_ = CreateMaybeMessage< ::minknow_api::instance::DeviceInfo >(GetArenaForAllocation());
  }
  return stream_value_.device_info_;
}
inline ::minknow_api::instance::DeviceInfo* StreamInstanceActivityResponse::mutable_device_info() {
  ::minknow_api::instance::DeviceInfo* _msg = _internal_mutable_device_info();
  // @@protoc_insertion_point(field_mutable:minknow_api.instance.StreamInstanceActivityResponse.device_info)
  return _msg;
}

// .minknow_api.device.GetFlowCellInfoResponse flow_cell_info = 2;
inline bool StreamInstanceActivityResponse::_internal_has_flow_cell_info() const {
  return stream_value_case() == kFlowCellInfo;
}
inline bool StreamInstanceActivityResponse::has_flow_cell_info() const {
  return _internal_has_flow_cell_info();
}
inline void StreamInstanceActivityResponse::set_has_flow_cell_info() {
  _oneof_case_[0] = kFlowCellInfo;
}
inline ::minknow_api::device::GetFlowCellInfoResponse* StreamInstanceActivityResponse::release_flow_cell_info() {
  // @@protoc_insertion_point(field_release:minknow_api.instance.StreamInstanceActivityResponse.flow_cell_info)
  if (_internal_has_flow_cell_info()) {
    clear_has_stream_value();
      ::minknow_api::device::GetFlowCellInfoResponse* temp = stream_value_.flow_cell_info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    stream_value_.flow_cell_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::minknow_api::device::GetFlowCellInfoResponse& StreamInstanceActivityResponse::_internal_flow_cell_info() const {
  return _internal_has_flow_cell_info()
      ? *stream_value_.flow_cell_info_
      : reinterpret_cast< ::minknow_api::device::GetFlowCellInfoResponse&>(::minknow_api::device::_GetFlowCellInfoResponse_default_instance_);
}
inline const ::minknow_api::device::GetFlowCellInfoResponse& StreamInstanceActivityResponse::flow_cell_info() const {
  // @@protoc_insertion_point(field_get:minknow_api.instance.StreamInstanceActivityResponse.flow_cell_info)
  return _internal_flow_cell_info();
}
inline ::minknow_api::device::GetFlowCellInfoResponse* StreamInstanceActivityResponse::unsafe_arena_release_flow_cell_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:minknow_api.instance.StreamInstanceActivityResponse.flow_cell_info)
  if (_internal_has_flow_cell_info()) {
    clear_has_stream_value();
    ::minknow_api::device::GetFlowCellInfoResponse* temp = stream_value_.flow_cell_info_;
    stream_value_.flow_cell_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamInstanceActivityResponse::unsafe_arena_set_allocated_flow_cell_info(::minknow_api::device::GetFlowCellInfoResponse* flow_cell_info) {
  clear_stream_value();
  if (flow_cell_info) {
    set_has_flow_cell_info();
    stream_value_.flow_cell_info_ = flow_cell_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minknow_api.instance.StreamInstanceActivityResponse.flow_cell_info)
}
inline ::minknow_api::device::GetFlowCellInfoResponse* StreamInstanceActivityResponse::_internal_mutable_flow_cell_info() {
  if (!_internal_has_flow_cell_info()) {
    clear_stream_value();
    set_has_flow_cell_info();
    stream_value_.flow_cell_info_ = CreateMaybeMessage< ::minknow_api::device::GetFlowCellInfoResponse >(GetArenaForAllocation());
  }
  return stream_value_.flow_cell_info_;
}
inline ::minknow_api::device::GetFlowCellInfoResponse* StreamInstanceActivityResponse::mutable_flow_cell_info() {
  ::minknow_api::device::GetFlowCellInfoResponse* _msg = _internal_mutable_flow_cell_info();
  // @@protoc_insertion_point(field_mutable:minknow_api.instance.StreamInstanceActivityResponse.flow_cell_info)
  return _msg;
}

// .minknow_api.protocol.ProtocolRunInfo protocol_run_info = 3;
inline bool StreamInstanceActivityResponse::_internal_has_protocol_run_info() const {
  return stream_value_case() == kProtocolRunInfo;
}
inline bool StreamInstanceActivityResponse::has_protocol_run_info() const {
  return _internal_has_protocol_run_info();
}
inline void StreamInstanceActivityResponse::set_has_protocol_run_info() {
  _oneof_case_[0] = kProtocolRunInfo;
}
inline ::minknow_api::protocol::ProtocolRunInfo* StreamInstanceActivityResponse::release_protocol_run_info() {
  // @@protoc_insertion_point(field_release:minknow_api.instance.StreamInstanceActivityResponse.protocol_run_info)
  if (_internal_has_protocol_run_info()) {
    clear_has_stream_value();
      ::minknow_api::protocol::ProtocolRunInfo* temp = stream_value_.protocol_run_info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    stream_value_.protocol_run_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::minknow_api::protocol::ProtocolRunInfo& StreamInstanceActivityResponse::_internal_protocol_run_info() const {
  return _internal_has_protocol_run_info()
      ? *stream_value_.protocol_run_info_
      : reinterpret_cast< ::minknow_api::protocol::ProtocolRunInfo&>(::minknow_api::protocol::_ProtocolRunInfo_default_instance_);
}
inline const ::minknow_api::protocol::ProtocolRunInfo& StreamInstanceActivityResponse::protocol_run_info() const {
  // @@protoc_insertion_point(field_get:minknow_api.instance.StreamInstanceActivityResponse.protocol_run_info)
  return _internal_protocol_run_info();
}
inline ::minknow_api::protocol::ProtocolRunInfo* StreamInstanceActivityResponse::unsafe_arena_release_protocol_run_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:minknow_api.instance.StreamInstanceActivityResponse.protocol_run_info)
  if (_internal_has_protocol_run_info()) {
    clear_has_stream_value();
    ::minknow_api::protocol::ProtocolRunInfo* temp = stream_value_.protocol_run_info_;
    stream_value_.protocol_run_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamInstanceActivityResponse::unsafe_arena_set_allocated_protocol_run_info(::minknow_api::protocol::ProtocolRunInfo* protocol_run_info) {
  clear_stream_value();
  if (protocol_run_info) {
    set_has_protocol_run_info();
    stream_value_.protocol_run_info_ = protocol_run_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minknow_api.instance.StreamInstanceActivityResponse.protocol_run_info)
}
inline ::minknow_api::protocol::ProtocolRunInfo* StreamInstanceActivityResponse::_internal_mutable_protocol_run_info() {
  if (!_internal_has_protocol_run_info()) {
    clear_stream_value();
    set_has_protocol_run_info();
    stream_value_.protocol_run_info_ = CreateMaybeMessage< ::minknow_api::protocol::ProtocolRunInfo >(GetArenaForAllocation());
  }
  return stream_value_.protocol_run_info_;
}
inline ::minknow_api::protocol::ProtocolRunInfo* StreamInstanceActivityResponse::mutable_protocol_run_info() {
  ::minknow_api::protocol::ProtocolRunInfo* _msg = _internal_mutable_protocol_run_info();
  // @@protoc_insertion_point(field_mutable:minknow_api.instance.StreamInstanceActivityResponse.protocol_run_info)
  return _msg;
}

// .minknow_api.acquisition.AcquisitionRunInfo acquisition_run_info = 4;
inline bool StreamInstanceActivityResponse::_internal_has_acquisition_run_info() const {
  return stream_value_case() == kAcquisitionRunInfo;
}
inline bool StreamInstanceActivityResponse::has_acquisition_run_info() const {
  return _internal_has_acquisition_run_info();
}
inline void StreamInstanceActivityResponse::set_has_acquisition_run_info() {
  _oneof_case_[0] = kAcquisitionRunInfo;
}
inline ::minknow_api::acquisition::AcquisitionRunInfo* StreamInstanceActivityResponse::release_acquisition_run_info() {
  // @@protoc_insertion_point(field_release:minknow_api.instance.StreamInstanceActivityResponse.acquisition_run_info)
  if (_internal_has_acquisition_run_info()) {
    clear_has_stream_value();
      ::minknow_api::acquisition::AcquisitionRunInfo* temp = stream_value_.acquisition_run_info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    stream_value_.acquisition_run_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::minknow_api::acquisition::AcquisitionRunInfo& StreamInstanceActivityResponse::_internal_acquisition_run_info() const {
  return _internal_has_acquisition_run_info()
      ? *stream_value_.acquisition_run_info_
      : reinterpret_cast< ::minknow_api::acquisition::AcquisitionRunInfo&>(::minknow_api::acquisition::_AcquisitionRunInfo_default_instance_);
}
inline const ::minknow_api::acquisition::AcquisitionRunInfo& StreamInstanceActivityResponse::acquisition_run_info() const {
  // @@protoc_insertion_point(field_get:minknow_api.instance.StreamInstanceActivityResponse.acquisition_run_info)
  return _internal_acquisition_run_info();
}
inline ::minknow_api::acquisition::AcquisitionRunInfo* StreamInstanceActivityResponse::unsafe_arena_release_acquisition_run_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:minknow_api.instance.StreamInstanceActivityResponse.acquisition_run_info)
  if (_internal_has_acquisition_run_info()) {
    clear_has_stream_value();
    ::minknow_api::acquisition::AcquisitionRunInfo* temp = stream_value_.acquisition_run_info_;
    stream_value_.acquisition_run_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamInstanceActivityResponse::unsafe_arena_set_allocated_acquisition_run_info(::minknow_api::acquisition::AcquisitionRunInfo* acquisition_run_info) {
  clear_stream_value();
  if (acquisition_run_info) {
    set_has_acquisition_run_info();
    stream_value_.acquisition_run_info_ = acquisition_run_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minknow_api.instance.StreamInstanceActivityResponse.acquisition_run_info)
}
inline ::minknow_api::acquisition::AcquisitionRunInfo* StreamInstanceActivityResponse::_internal_mutable_acquisition_run_info() {
  if (!_internal_has_acquisition_run_info()) {
    clear_stream_value();
    set_has_acquisition_run_info();
    stream_value_.acquisition_run_info_ = CreateMaybeMessage< ::minknow_api::acquisition::AcquisitionRunInfo >(GetArenaForAllocation());
  }
  return stream_value_.acquisition_run_info_;
}
inline ::minknow_api::acquisition::AcquisitionRunInfo* StreamInstanceActivityResponse::mutable_acquisition_run_info() {
  ::minknow_api::acquisition::AcquisitionRunInfo* _msg = _internal_mutable_acquisition_run_info();
  // @@protoc_insertion_point(field_mutable:minknow_api.instance.StreamInstanceActivityResponse.acquisition_run_info)
  return _msg;
}

// .minknow_api.instance.StreamInstanceActivityResponse.FlowCellHealth flow_cell_health = 5;
inline bool StreamInstanceActivityResponse::_internal_has_flow_cell_health() const {
  return stream_value_case() == kFlowCellHealth;
}
inline bool StreamInstanceActivityResponse::has_flow_cell_health() const {
  return _internal_has_flow_cell_health();
}
inline void StreamInstanceActivityResponse::set_has_flow_cell_health() {
  _oneof_case_[0] = kFlowCellHealth;
}
inline void StreamInstanceActivityResponse::clear_flow_cell_health() {
  if (_internal_has_flow_cell_health()) {
    if (GetArenaForAllocation() == nullptr) {
      delete stream_value_.flow_cell_health_;
    }
    clear_has_stream_value();
  }
}
inline ::minknow_api::instance::StreamInstanceActivityResponse_FlowCellHealth* StreamInstanceActivityResponse::release_flow_cell_health() {
  // @@protoc_insertion_point(field_release:minknow_api.instance.StreamInstanceActivityResponse.flow_cell_health)
  if (_internal_has_flow_cell_health()) {
    clear_has_stream_value();
      ::minknow_api::instance::StreamInstanceActivityResponse_FlowCellHealth* temp = stream_value_.flow_cell_health_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    stream_value_.flow_cell_health_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::minknow_api::instance::StreamInstanceActivityResponse_FlowCellHealth& StreamInstanceActivityResponse::_internal_flow_cell_health() const {
  return _internal_has_flow_cell_health()
      ? *stream_value_.flow_cell_health_
      : reinterpret_cast< ::minknow_api::instance::StreamInstanceActivityResponse_FlowCellHealth&>(::minknow_api::instance::_StreamInstanceActivityResponse_FlowCellHealth_default_instance_);
}
inline const ::minknow_api::instance::StreamInstanceActivityResponse_FlowCellHealth& StreamInstanceActivityResponse::flow_cell_health() const {
  // @@protoc_insertion_point(field_get:minknow_api.instance.StreamInstanceActivityResponse.flow_cell_health)
  return _internal_flow_cell_health();
}
inline ::minknow_api::instance::StreamInstanceActivityResponse_FlowCellHealth* StreamInstanceActivityResponse::unsafe_arena_release_flow_cell_health() {
  // @@protoc_insertion_point(field_unsafe_arena_release:minknow_api.instance.StreamInstanceActivityResponse.flow_cell_health)
  if (_internal_has_flow_cell_health()) {
    clear_has_stream_value();
    ::minknow_api::instance::StreamInstanceActivityResponse_FlowCellHealth* temp = stream_value_.flow_cell_health_;
    stream_value_.flow_cell_health_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamInstanceActivityResponse::unsafe_arena_set_allocated_flow_cell_health(::minknow_api::instance::StreamInstanceActivityResponse_FlowCellHealth* flow_cell_health) {
  clear_stream_value();
  if (flow_cell_health) {
    set_has_flow_cell_health();
    stream_value_.flow_cell_health_ = flow_cell_health;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minknow_api.instance.StreamInstanceActivityResponse.flow_cell_health)
}
inline ::minknow_api::instance::StreamInstanceActivityResponse_FlowCellHealth* StreamInstanceActivityResponse::_internal_mutable_flow_cell_health() {
  if (!_internal_has_flow_cell_health()) {
    clear_stream_value();
    set_has_flow_cell_health();
    stream_value_.flow_cell_health_ = CreateMaybeMessage< ::minknow_api::instance::StreamInstanceActivityResponse_FlowCellHealth >(GetArenaForAllocation());
  }
  return stream_value_.flow_cell_health_;
}
inline ::minknow_api::instance::StreamInstanceActivityResponse_FlowCellHealth* StreamInstanceActivityResponse::mutable_flow_cell_health() {
  ::minknow_api::instance::StreamInstanceActivityResponse_FlowCellHealth* _msg = _internal_mutable_flow_cell_health();
  // @@protoc_insertion_point(field_mutable:minknow_api.instance.StreamInstanceActivityResponse.flow_cell_health)
  return _msg;
}

// .minknow_api.acquisition.AcquisitionYieldSummary yield_summary = 6;
inline bool StreamInstanceActivityResponse::_internal_has_yield_summary() const {
  return stream_value_case() == kYieldSummary;
}
inline bool StreamInstanceActivityResponse::has_yield_summary() const {
  return _internal_has_yield_summary();
}
inline void StreamInstanceActivityResponse::set_has_yield_summary() {
  _oneof_case_[0] = kYieldSummary;
}
inline ::minknow_api::acquisition::AcquisitionYieldSummary* StreamInstanceActivityResponse::release_yield_summary() {
  // @@protoc_insertion_point(field_release:minknow_api.instance.StreamInstanceActivityResponse.yield_summary)
  if (_internal_has_yield_summary()) {
    clear_has_stream_value();
      ::minknow_api::acquisition::AcquisitionYieldSummary* temp = stream_value_.yield_summary_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    stream_value_.yield_summary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::minknow_api::acquisition::AcquisitionYieldSummary& StreamInstanceActivityResponse::_internal_yield_summary() const {
  return _internal_has_yield_summary()
      ? *stream_value_.yield_summary_
      : reinterpret_cast< ::minknow_api::acquisition::AcquisitionYieldSummary&>(::minknow_api::acquisition::_AcquisitionYieldSummary_default_instance_);
}
inline const ::minknow_api::acquisition::AcquisitionYieldSummary& StreamInstanceActivityResponse::yield_summary() const {
  // @@protoc_insertion_point(field_get:minknow_api.instance.StreamInstanceActivityResponse.yield_summary)
  return _internal_yield_summary();
}
inline ::minknow_api::acquisition::AcquisitionYieldSummary* StreamInstanceActivityResponse::unsafe_arena_release_yield_summary() {
  // @@protoc_insertion_point(field_unsafe_arena_release:minknow_api.instance.StreamInstanceActivityResponse.yield_summary)
  if (_internal_has_yield_summary()) {
    clear_has_stream_value();
    ::minknow_api::acquisition::AcquisitionYieldSummary* temp = stream_value_.yield_summary_;
    stream_value_.yield_summary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamInstanceActivityResponse::unsafe_arena_set_allocated_yield_summary(::minknow_api::acquisition::AcquisitionYieldSummary* yield_summary) {
  clear_stream_value();
  if (yield_summary) {
    set_has_yield_summary();
    stream_value_.yield_summary_ = yield_summary;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minknow_api.instance.StreamInstanceActivityResponse.yield_summary)
}
inline ::minknow_api::acquisition::AcquisitionYieldSummary* StreamInstanceActivityResponse::_internal_mutable_yield_summary() {
  if (!_internal_has_yield_summary()) {
    clear_stream_value();
    set_has_yield_summary();
    stream_value_.yield_summary_ = CreateMaybeMessage< ::minknow_api::acquisition::AcquisitionYieldSummary >(GetArenaForAllocation());
  }
  return stream_value_.yield_summary_;
}
inline ::minknow_api::acquisition::AcquisitionYieldSummary* StreamInstanceActivityResponse::mutable_yield_summary() {
  ::minknow_api::acquisition::AcquisitionYieldSummary* _msg = _internal_mutable_yield_summary();
  // @@protoc_insertion_point(field_mutable:minknow_api.instance.StreamInstanceActivityResponse.yield_summary)
  return _msg;
}

// .minknow_api.instance.BasecallSpeed basecall_speed = 7;
inline bool StreamInstanceActivityResponse::_internal_has_basecall_speed() const {
  return stream_value_case() == kBasecallSpeed;
}
inline bool StreamInstanceActivityResponse::has_basecall_speed() const {
  return _internal_has_basecall_speed();
}
inline void StreamInstanceActivityResponse::set_has_basecall_speed() {
  _oneof_case_[0] = kBasecallSpeed;
}
inline void StreamInstanceActivityResponse::clear_basecall_speed() {
  if (_internal_has_basecall_speed()) {
    if (GetArenaForAllocation() == nullptr) {
      delete stream_value_.basecall_speed_;
    }
    clear_has_stream_value();
  }
}
inline ::minknow_api::instance::BasecallSpeed* StreamInstanceActivityResponse::release_basecall_speed() {
  // @@protoc_insertion_point(field_release:minknow_api.instance.StreamInstanceActivityResponse.basecall_speed)
  if (_internal_has_basecall_speed()) {
    clear_has_stream_value();
      ::minknow_api::instance::BasecallSpeed* temp = stream_value_.basecall_speed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    stream_value_.basecall_speed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::minknow_api::instance::BasecallSpeed& StreamInstanceActivityResponse::_internal_basecall_speed() const {
  return _internal_has_basecall_speed()
      ? *stream_value_.basecall_speed_
      : reinterpret_cast< ::minknow_api::instance::BasecallSpeed&>(::minknow_api::instance::_BasecallSpeed_default_instance_);
}
inline const ::minknow_api::instance::BasecallSpeed& StreamInstanceActivityResponse::basecall_speed() const {
  // @@protoc_insertion_point(field_get:minknow_api.instance.StreamInstanceActivityResponse.basecall_speed)
  return _internal_basecall_speed();
}
inline ::minknow_api::instance::BasecallSpeed* StreamInstanceActivityResponse::unsafe_arena_release_basecall_speed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:minknow_api.instance.StreamInstanceActivityResponse.basecall_speed)
  if (_internal_has_basecall_speed()) {
    clear_has_stream_value();
    ::minknow_api::instance::BasecallSpeed* temp = stream_value_.basecall_speed_;
    stream_value_.basecall_speed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamInstanceActivityResponse::unsafe_arena_set_allocated_basecall_speed(::minknow_api::instance::BasecallSpeed* basecall_speed) {
  clear_stream_value();
  if (basecall_speed) {
    set_has_basecall_speed();
    stream_value_.basecall_speed_ = basecall_speed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minknow_api.instance.StreamInstanceActivityResponse.basecall_speed)
}
inline ::minknow_api::instance::BasecallSpeed* StreamInstanceActivityResponse::_internal_mutable_basecall_speed() {
  if (!_internal_has_basecall_speed()) {
    clear_stream_value();
    set_has_basecall_speed();
    stream_value_.basecall_speed_ = CreateMaybeMessage< ::minknow_api::instance::BasecallSpeed >(GetArenaForAllocation());
  }
  return stream_value_.basecall_speed_;
}
inline ::minknow_api::instance::BasecallSpeed* StreamInstanceActivityResponse::mutable_basecall_speed() {
  ::minknow_api::instance::BasecallSpeed* _msg = _internal_mutable_basecall_speed();
  // @@protoc_insertion_point(field_mutable:minknow_api.instance.StreamInstanceActivityResponse.basecall_speed)
  return _msg;
}

// .minknow_api.instance.N50 n50 = 8;
inline bool StreamInstanceActivityResponse::_internal_has_n50() const {
  return stream_value_case() == kN50;
}
inline bool StreamInstanceActivityResponse::has_n50() const {
  return _internal_has_n50();
}
inline void StreamInstanceActivityResponse::set_has_n50() {
  _oneof_case_[0] = kN50;
}
inline void StreamInstanceActivityResponse::clear_n50() {
  if (_internal_has_n50()) {
    if (GetArenaForAllocation() == nullptr) {
      delete stream_value_.n50_;
    }
    clear_has_stream_value();
  }
}
inline ::minknow_api::instance::N50* StreamInstanceActivityResponse::release_n50() {
  // @@protoc_insertion_point(field_release:minknow_api.instance.StreamInstanceActivityResponse.n50)
  if (_internal_has_n50()) {
    clear_has_stream_value();
      ::minknow_api::instance::N50* temp = stream_value_.n50_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    stream_value_.n50_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::minknow_api::instance::N50& StreamInstanceActivityResponse::_internal_n50() const {
  return _internal_has_n50()
      ? *stream_value_.n50_
      : reinterpret_cast< ::minknow_api::instance::N50&>(::minknow_api::instance::_N50_default_instance_);
}
inline const ::minknow_api::instance::N50& StreamInstanceActivityResponse::n50() const {
  // @@protoc_insertion_point(field_get:minknow_api.instance.StreamInstanceActivityResponse.n50)
  return _internal_n50();
}
inline ::minknow_api::instance::N50* StreamInstanceActivityResponse::unsafe_arena_release_n50() {
  // @@protoc_insertion_point(field_unsafe_arena_release:minknow_api.instance.StreamInstanceActivityResponse.n50)
  if (_internal_has_n50()) {
    clear_has_stream_value();
    ::minknow_api::instance::N50* temp = stream_value_.n50_;
    stream_value_.n50_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamInstanceActivityResponse::unsafe_arena_set_allocated_n50(::minknow_api::instance::N50* n50) {
  clear_stream_value();
  if (n50) {
    set_has_n50();
    stream_value_.n50_ = n50;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minknow_api.instance.StreamInstanceActivityResponse.n50)
}
inline ::minknow_api::instance::N50* StreamInstanceActivityResponse::_internal_mutable_n50() {
  if (!_internal_has_n50()) {
    clear_stream_value();
    set_has_n50();
    stream_value_.n50_ = CreateMaybeMessage< ::minknow_api::instance::N50 >(GetArenaForAllocation());
  }
  return stream_value_.n50_;
}
inline ::minknow_api::instance::N50* StreamInstanceActivityResponse::mutable_n50() {
  ::minknow_api::instance::N50* _msg = _internal_mutable_n50();
  // @@protoc_insertion_point(field_mutable:minknow_api.instance.StreamInstanceActivityResponse.n50)
  return _msg;
}

inline bool StreamInstanceActivityResponse::has_stream_value() const {
  return stream_value_case() != STREAM_VALUE_NOT_SET;
}
inline void StreamInstanceActivityResponse::clear_has_stream_value() {
  _oneof_case_[0] = STREAM_VALUE_NOT_SET;
}
inline StreamInstanceActivityResponse::StreamValueCase StreamInstanceActivityResponse::stream_value_case() const {
  return StreamInstanceActivityResponse::StreamValueCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace instance
}  // namespace minknow_api

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::minknow_api::instance::GetVersionInfoResponse_DistributionStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::minknow_api::instance::GetVersionInfoResponse_DistributionStatus>() {
  return ::minknow_api::instance::GetVersionInfoResponse_DistributionStatus_descriptor();
}
template <> struct is_proto_enum< ::minknow_api::instance::GetVersionInfoResponse_InstallationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::minknow_api::instance::GetVersionInfoResponse_InstallationType>() {
  return ::minknow_api::instance::GetVersionInfoResponse_InstallationType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_minknow_5fapi_2finstance_2eproto
