// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: minknow_api/manager.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_minknow_5fapi_2fmanager_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_minknow_5fapi_2fmanager_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "minknow_api/rpc_options.pb.h"
#include "minknow_api/device.pb.h"
#include "minknow_api/instance.pb.h"
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_minknow_5fapi_2fmanager_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_minknow_5fapi_2fmanager_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[64]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_minknow_5fapi_2fmanager_2eproto;
namespace minknow_api {
namespace manager {
class AddSimulatedDeviceRequest;
struct AddSimulatedDeviceRequestDefaultTypeInternal;
extern AddSimulatedDeviceRequestDefaultTypeInternal _AddSimulatedDeviceRequest_default_instance_;
class AddSimulatedDeviceResponse;
struct AddSimulatedDeviceResponseDefaultTypeInternal;
extern AddSimulatedDeviceResponseDefaultTypeInternal _AddSimulatedDeviceResponse_default_instance_;
class ApplyOfflineAssociationUnlockCodeRequest;
struct ApplyOfflineAssociationUnlockCodeRequestDefaultTypeInternal;
extern ApplyOfflineAssociationUnlockCodeRequestDefaultTypeInternal _ApplyOfflineAssociationUnlockCodeRequest_default_instance_;
class ApplyOfflineAssociationUnlockCodeResponse;
struct ApplyOfflineAssociationUnlockCodeResponseDefaultTypeInternal;
extern ApplyOfflineAssociationUnlockCodeResponseDefaultTypeInternal _ApplyOfflineAssociationUnlockCodeResponse_default_instance_;
class AssociationDeviceCodeRequest;
struct AssociationDeviceCodeRequestDefaultTypeInternal;
extern AssociationDeviceCodeRequestDefaultTypeInternal _AssociationDeviceCodeRequest_default_instance_;
class AssociationDeviceCodeResponse;
struct AssociationDeviceCodeResponseDefaultTypeInternal;
extern AssociationDeviceCodeResponseDefaultTypeInternal _AssociationDeviceCodeResponse_default_instance_;
class BasecallerApiRequest;
struct BasecallerApiRequestDefaultTypeInternal;
extern BasecallerApiRequestDefaultTypeInternal _BasecallerApiRequest_default_instance_;
class BasecallerApiResponse;
struct BasecallerApiResponseDefaultTypeInternal;
extern BasecallerApiResponseDefaultTypeInternal _BasecallerApiResponse_default_instance_;
class CreateDeveloperApiTokenRequest;
struct CreateDeveloperApiTokenRequestDefaultTypeInternal;
extern CreateDeveloperApiTokenRequestDefaultTypeInternal _CreateDeveloperApiTokenRequest_default_instance_;
class CreateDeveloperApiTokenResponse;
struct CreateDeveloperApiTokenResponseDefaultTypeInternal;
extern CreateDeveloperApiTokenResponseDefaultTypeInternal _CreateDeveloperApiTokenResponse_default_instance_;
class CreateDirectoryRequest;
struct CreateDirectoryRequestDefaultTypeInternal;
extern CreateDirectoryRequestDefaultTypeInternal _CreateDirectoryRequest_default_instance_;
class CreateDirectoryResponse;
struct CreateDirectoryResponseDefaultTypeInternal;
extern CreateDirectoryResponseDefaultTypeInternal _CreateDirectoryResponse_default_instance_;
class DescribeHostRequest;
struct DescribeHostRequestDefaultTypeInternal;
extern DescribeHostRequestDefaultTypeInternal _DescribeHostRequest_default_instance_;
class DescribeHostResponse;
struct DescribeHostResponseDefaultTypeInternal;
extern DescribeHostResponseDefaultTypeInternal _DescribeHostResponse_default_instance_;
class FilesystemDiskSpaceInfo;
struct FilesystemDiskSpaceInfoDefaultTypeInternal;
extern FilesystemDiskSpaceInfoDefaultTypeInternal _FilesystemDiskSpaceInfo_default_instance_;
class FindProtocolsRequest;
struct FindProtocolsRequestDefaultTypeInternal;
extern FindProtocolsRequestDefaultTypeInternal _FindProtocolsRequest_default_instance_;
class FindProtocolsResponse;
struct FindProtocolsResponseDefaultTypeInternal;
extern FindProtocolsResponseDefaultTypeInternal _FindProtocolsResponse_default_instance_;
class FindProtocolsResponse_Protocol;
struct FindProtocolsResponse_ProtocolDefaultTypeInternal;
extern FindProtocolsResponse_ProtocolDefaultTypeInternal _FindProtocolsResponse_Protocol_default_instance_;
class FlowCellPosition;
struct FlowCellPositionDefaultTypeInternal;
extern FlowCellPositionDefaultTypeInternal _FlowCellPosition_default_instance_;
class FlowCellPosition_Location;
struct FlowCellPosition_LocationDefaultTypeInternal;
extern FlowCellPosition_LocationDefaultTypeInternal _FlowCellPosition_Location_default_instance_;
class FlowCellPosition_RpcPorts;
struct FlowCellPosition_RpcPortsDefaultTypeInternal;
extern FlowCellPosition_RpcPortsDefaultTypeInternal _FlowCellPosition_RpcPorts_default_instance_;
class FlowCellPosition_SharedHardwareGroup;
struct FlowCellPosition_SharedHardwareGroupDefaultTypeInternal;
extern FlowCellPosition_SharedHardwareGroupDefaultTypeInternal _FlowCellPosition_SharedHardwareGroup_default_instance_;
class FlowCellPositionsRequest;
struct FlowCellPositionsRequestDefaultTypeInternal;
extern FlowCellPositionsRequestDefaultTypeInternal _FlowCellPositionsRequest_default_instance_;
class FlowCellPositionsResponse;
struct FlowCellPositionsResponseDefaultTypeInternal;
extern FlowCellPositionsResponseDefaultTypeInternal _FlowCellPositionsResponse_default_instance_;
class GetAlignmentReferenceInformationRequest;
struct GetAlignmentReferenceInformationRequestDefaultTypeInternal;
extern GetAlignmentReferenceInformationRequestDefaultTypeInternal _GetAlignmentReferenceInformationRequest_default_instance_;
class GetAlignmentReferenceInformationResponse;
struct GetAlignmentReferenceInformationResponseDefaultTypeInternal;
extern GetAlignmentReferenceInformationResponseDefaultTypeInternal _GetAlignmentReferenceInformationResponse_default_instance_;
class GetBarcodeKeysRequest;
struct GetBarcodeKeysRequestDefaultTypeInternal;
extern GetBarcodeKeysRequestDefaultTypeInternal _GetBarcodeKeysRequest_default_instance_;
class GetBarcodeKeysResponse;
struct GetBarcodeKeysResponseDefaultTypeInternal;
extern GetBarcodeKeysResponseDefaultTypeInternal _GetBarcodeKeysResponse_default_instance_;
class GetBarcodeKitInfoRequest;
struct GetBarcodeKitInfoRequestDefaultTypeInternal;
extern GetBarcodeKitInfoRequestDefaultTypeInternal _GetBarcodeKitInfoRequest_default_instance_;
class GetBarcodeKitInfoResponse;
struct GetBarcodeKitInfoResponseDefaultTypeInternal;
extern GetBarcodeKitInfoResponseDefaultTypeInternal _GetBarcodeKitInfoResponse_default_instance_;
class GetBarcodeKitInfoResponse_BarcodeKitInfo;
struct GetBarcodeKitInfoResponse_BarcodeKitInfoDefaultTypeInternal;
extern GetBarcodeKitInfoResponse_BarcodeKitInfoDefaultTypeInternal _GetBarcodeKitInfoResponse_BarcodeKitInfo_default_instance_;
class GetBarcodeKitInfoResponse_BarcodeKitInfoEntry_DoNotUse;
struct GetBarcodeKitInfoResponse_BarcodeKitInfoEntry_DoNotUseDefaultTypeInternal;
extern GetBarcodeKitInfoResponse_BarcodeKitInfoEntry_DoNotUseDefaultTypeInternal _GetBarcodeKitInfoResponse_BarcodeKitInfoEntry_DoNotUse_default_instance_;
class GetDiskSpaceInfoRequest;
struct GetDiskSpaceInfoRequestDefaultTypeInternal;
extern GetDiskSpaceInfoRequestDefaultTypeInternal _GetDiskSpaceInfoRequest_default_instance_;
class GetDiskSpaceInfoResponse;
struct GetDiskSpaceInfoResponseDefaultTypeInternal;
extern GetDiskSpaceInfoResponseDefaultTypeInternal _GetDiskSpaceInfoResponse_default_instance_;
class GetFlowCellTypesRequest;
struct GetFlowCellTypesRequestDefaultTypeInternal;
extern GetFlowCellTypesRequestDefaultTypeInternal _GetFlowCellTypesRequest_default_instance_;
class GetFlowCellTypesResponse;
struct GetFlowCellTypesResponseDefaultTypeInternal;
extern GetFlowCellTypesResponseDefaultTypeInternal _GetFlowCellTypesResponse_default_instance_;
class GetFlowCellTypesResponse_Info;
struct GetFlowCellTypesResponse_InfoDefaultTypeInternal;
extern GetFlowCellTypesResponse_InfoDefaultTypeInternal _GetFlowCellTypesResponse_Info_default_instance_;
class GetGuppyInfoRequest;
struct GetGuppyInfoRequestDefaultTypeInternal;
extern GetGuppyInfoRequestDefaultTypeInternal _GetGuppyInfoRequest_default_instance_;
class GetGuppyInfoResponse;
struct GetGuppyInfoResponseDefaultTypeInternal;
extern GetGuppyInfoResponseDefaultTypeInternal _GetGuppyInfoResponse_default_instance_;
class GetLampKitInfoRequest;
struct GetLampKitInfoRequestDefaultTypeInternal;
extern GetLampKitInfoRequestDefaultTypeInternal _GetLampKitInfoRequest_default_instance_;
class GetLampKitInfoResponse;
struct GetLampKitInfoResponseDefaultTypeInternal;
extern GetLampKitInfoResponseDefaultTypeInternal _GetLampKitInfoResponse_default_instance_;
class GetSequencingKitsRequest;
struct GetSequencingKitsRequestDefaultTypeInternal;
extern GetSequencingKitsRequestDefaultTypeInternal _GetSequencingKitsRequest_default_instance_;
class GetSequencingKitsResponse;
struct GetSequencingKitsResponseDefaultTypeInternal;
extern GetSequencingKitsResponseDefaultTypeInternal _GetSequencingKitsResponse_default_instance_;
class GetSequencingKitsResponse_BarcodingExpansionKit;
struct GetSequencingKitsResponse_BarcodingExpansionKitDefaultTypeInternal;
extern GetSequencingKitsResponse_BarcodingExpansionKitDefaultTypeInternal _GetSequencingKitsResponse_BarcodingExpansionKit_default_instance_;
class GetSequencingKitsResponse_Kit;
struct GetSequencingKitsResponse_KitDefaultTypeInternal;
extern GetSequencingKitsResponse_KitDefaultTypeInternal _GetSequencingKitsResponse_Kit_default_instance_;
class GetVersionInfoRequest;
struct GetVersionInfoRequestDefaultTypeInternal;
extern GetVersionInfoRequestDefaultTypeInternal _GetVersionInfoRequest_default_instance_;
class GetVersionInfoResponse;
struct GetVersionInfoResponseDefaultTypeInternal;
extern GetVersionInfoResponseDefaultTypeInternal _GetVersionInfoResponse_default_instance_;
class ListDeveloperApiTokensRequest;
struct ListDeveloperApiTokensRequestDefaultTypeInternal;
extern ListDeveloperApiTokensRequestDefaultTypeInternal _ListDeveloperApiTokensRequest_default_instance_;
class ListDeveloperApiTokensResponse;
struct ListDeveloperApiTokensResponseDefaultTypeInternal;
extern ListDeveloperApiTokensResponseDefaultTypeInternal _ListDeveloperApiTokensResponse_default_instance_;
class ListDeveloperApiTokensResponse_DeveloperApiToken;
struct ListDeveloperApiTokensResponse_DeveloperApiTokenDefaultTypeInternal;
extern ListDeveloperApiTokensResponse_DeveloperApiTokenDefaultTypeInternal _ListDeveloperApiTokensResponse_DeveloperApiToken_default_instance_;
class ListProtocolOutputDirFilesRequest;
struct ListProtocolOutputDirFilesRequestDefaultTypeInternal;
extern ListProtocolOutputDirFilesRequestDefaultTypeInternal _ListProtocolOutputDirFilesRequest_default_instance_;
class ListProtocolOutputDirFilesResponse;
struct ListProtocolOutputDirFilesResponseDefaultTypeInternal;
extern ListProtocolOutputDirFilesResponseDefaultTypeInternal _ListProtocolOutputDirFilesResponse_default_instance_;
class ListProtocolOutputDirFilesResponse_DirectoryInfo;
struct ListProtocolOutputDirFilesResponse_DirectoryInfoDefaultTypeInternal;
extern ListProtocolOutputDirFilesResponse_DirectoryInfoDefaultTypeInternal _ListProtocolOutputDirFilesResponse_DirectoryInfo_default_instance_;
class LocalAuthenticationTokenPathRequest;
struct LocalAuthenticationTokenPathRequestDefaultTypeInternal;
extern LocalAuthenticationTokenPathRequestDefaultTypeInternal _LocalAuthenticationTokenPathRequest_default_instance_;
class LocalAuthenticationTokenPathResponse;
struct LocalAuthenticationTokenPathResponseDefaultTypeInternal;
extern LocalAuthenticationTokenPathResponseDefaultTypeInternal _LocalAuthenticationTokenPathResponse_default_instance_;
class RemoveSimulatedDeviceRequest;
struct RemoveSimulatedDeviceRequestDefaultTypeInternal;
extern RemoveSimulatedDeviceRequestDefaultTypeInternal _RemoveSimulatedDeviceRequest_default_instance_;
class RemoveSimulatedDeviceResponse;
struct RemoveSimulatedDeviceResponseDefaultTypeInternal;
extern RemoveSimulatedDeviceResponseDefaultTypeInternal _RemoveSimulatedDeviceResponse_default_instance_;
class ResetPositionRequest;
struct ResetPositionRequestDefaultTypeInternal;
extern ResetPositionRequestDefaultTypeInternal _ResetPositionRequest_default_instance_;
class ResetPositionResponse;
struct ResetPositionResponseDefaultTypeInternal;
extern ResetPositionResponseDefaultTypeInternal _ResetPositionResponse_default_instance_;
class RevokeDeveloperApiTokenRequest;
struct RevokeDeveloperApiTokenRequestDefaultTypeInternal;
extern RevokeDeveloperApiTokenRequestDefaultTypeInternal _RevokeDeveloperApiTokenRequest_default_instance_;
class RevokeDeveloperApiTokensResponse;
struct RevokeDeveloperApiTokensResponseDefaultTypeInternal;
extern RevokeDeveloperApiTokensResponseDefaultTypeInternal _RevokeDeveloperApiTokensResponse_default_instance_;
class StreamDiskSpaceInfoRequest;
struct StreamDiskSpaceInfoRequestDefaultTypeInternal;
extern StreamDiskSpaceInfoRequestDefaultTypeInternal _StreamDiskSpaceInfoRequest_default_instance_;
class WatchFlowCellPositionsRequest;
struct WatchFlowCellPositionsRequestDefaultTypeInternal;
extern WatchFlowCellPositionsRequestDefaultTypeInternal _WatchFlowCellPositionsRequest_default_instance_;
class WatchFlowCellPositionsResponse;
struct WatchFlowCellPositionsResponseDefaultTypeInternal;
extern WatchFlowCellPositionsResponseDefaultTypeInternal _WatchFlowCellPositionsResponse_default_instance_;
}  // namespace manager
}  // namespace minknow_api
PROTOBUF_NAMESPACE_OPEN
template<> ::minknow_api::manager::AddSimulatedDeviceRequest* Arena::CreateMaybeMessage<::minknow_api::manager::AddSimulatedDeviceRequest>(Arena*);
template<> ::minknow_api::manager::AddSimulatedDeviceResponse* Arena::CreateMaybeMessage<::minknow_api::manager::AddSimulatedDeviceResponse>(Arena*);
template<> ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeRequest* Arena::CreateMaybeMessage<::minknow_api::manager::ApplyOfflineAssociationUnlockCodeRequest>(Arena*);
template<> ::minknow_api::manager::ApplyOfflineAssociationUnlockCodeResponse* Arena::CreateMaybeMessage<::minknow_api::manager::ApplyOfflineAssociationUnlockCodeResponse>(Arena*);
template<> ::minknow_api::manager::AssociationDeviceCodeRequest* Arena::CreateMaybeMessage<::minknow_api::manager::AssociationDeviceCodeRequest>(Arena*);
template<> ::minknow_api::manager::AssociationDeviceCodeResponse* Arena::CreateMaybeMessage<::minknow_api::manager::AssociationDeviceCodeResponse>(Arena*);
template<> ::minknow_api::manager::BasecallerApiRequest* Arena::CreateMaybeMessage<::minknow_api::manager::BasecallerApiRequest>(Arena*);
template<> ::minknow_api::manager::BasecallerApiResponse* Arena::CreateMaybeMessage<::minknow_api::manager::BasecallerApiResponse>(Arena*);
template<> ::minknow_api::manager::CreateDeveloperApiTokenRequest* Arena::CreateMaybeMessage<::minknow_api::manager::CreateDeveloperApiTokenRequest>(Arena*);
template<> ::minknow_api::manager::CreateDeveloperApiTokenResponse* Arena::CreateMaybeMessage<::minknow_api::manager::CreateDeveloperApiTokenResponse>(Arena*);
template<> ::minknow_api::manager::CreateDirectoryRequest* Arena::CreateMaybeMessage<::minknow_api::manager::CreateDirectoryRequest>(Arena*);
template<> ::minknow_api::manager::CreateDirectoryResponse* Arena::CreateMaybeMessage<::minknow_api::manager::CreateDirectoryResponse>(Arena*);
template<> ::minknow_api::manager::DescribeHostRequest* Arena::CreateMaybeMessage<::minknow_api::manager::DescribeHostRequest>(Arena*);
template<> ::minknow_api::manager::DescribeHostResponse* Arena::CreateMaybeMessage<::minknow_api::manager::DescribeHostResponse>(Arena*);
template<> ::minknow_api::manager::FilesystemDiskSpaceInfo* Arena::CreateMaybeMessage<::minknow_api::manager::FilesystemDiskSpaceInfo>(Arena*);
template<> ::minknow_api::manager::FindProtocolsRequest* Arena::CreateMaybeMessage<::minknow_api::manager::FindProtocolsRequest>(Arena*);
template<> ::minknow_api::manager::FindProtocolsResponse* Arena::CreateMaybeMessage<::minknow_api::manager::FindProtocolsResponse>(Arena*);
template<> ::minknow_api::manager::FindProtocolsResponse_Protocol* Arena::CreateMaybeMessage<::minknow_api::manager::FindProtocolsResponse_Protocol>(Arena*);
template<> ::minknow_api::manager::FlowCellPosition* Arena::CreateMaybeMessage<::minknow_api::manager::FlowCellPosition>(Arena*);
template<> ::minknow_api::manager::FlowCellPosition_Location* Arena::CreateMaybeMessage<::minknow_api::manager::FlowCellPosition_Location>(Arena*);
template<> ::minknow_api::manager::FlowCellPosition_RpcPorts* Arena::CreateMaybeMessage<::minknow_api::manager::FlowCellPosition_RpcPorts>(Arena*);
template<> ::minknow_api::manager::FlowCellPosition_SharedHardwareGroup* Arena::CreateMaybeMessage<::minknow_api::manager::FlowCellPosition_SharedHardwareGroup>(Arena*);
template<> ::minknow_api::manager::FlowCellPositionsRequest* Arena::CreateMaybeMessage<::minknow_api::manager::FlowCellPositionsRequest>(Arena*);
template<> ::minknow_api::manager::FlowCellPositionsResponse* Arena::CreateMaybeMessage<::minknow_api::manager::FlowCellPositionsResponse>(Arena*);
template<> ::minknow_api::manager::GetAlignmentReferenceInformationRequest* Arena::CreateMaybeMessage<::minknow_api::manager::GetAlignmentReferenceInformationRequest>(Arena*);
template<> ::minknow_api::manager::GetAlignmentReferenceInformationResponse* Arena::CreateMaybeMessage<::minknow_api::manager::GetAlignmentReferenceInformationResponse>(Arena*);
template<> ::minknow_api::manager::GetBarcodeKeysRequest* Arena::CreateMaybeMessage<::minknow_api::manager::GetBarcodeKeysRequest>(Arena*);
template<> ::minknow_api::manager::GetBarcodeKeysResponse* Arena::CreateMaybeMessage<::minknow_api::manager::GetBarcodeKeysResponse>(Arena*);
template<> ::minknow_api::manager::GetBarcodeKitInfoRequest* Arena::CreateMaybeMessage<::minknow_api::manager::GetBarcodeKitInfoRequest>(Arena*);
template<> ::minknow_api::manager::GetBarcodeKitInfoResponse* Arena::CreateMaybeMessage<::minknow_api::manager::GetBarcodeKitInfoResponse>(Arena*);
template<> ::minknow_api::manager::GetBarcodeKitInfoResponse_BarcodeKitInfo* Arena::CreateMaybeMessage<::minknow_api::manager::GetBarcodeKitInfoResponse_BarcodeKitInfo>(Arena*);
template<> ::minknow_api::manager::GetBarcodeKitInfoResponse_BarcodeKitInfoEntry_DoNotUse* Arena::CreateMaybeMessage<::minknow_api::manager::GetBarcodeKitInfoResponse_BarcodeKitInfoEntry_DoNotUse>(Arena*);
template<> ::minknow_api::manager::GetDiskSpaceInfoRequest* Arena::CreateMaybeMessage<::minknow_api::manager::GetDiskSpaceInfoRequest>(Arena*);
template<> ::minknow_api::manager::GetDiskSpaceInfoResponse* Arena::CreateMaybeMessage<::minknow_api::manager::GetDiskSpaceInfoResponse>(Arena*);
template<> ::minknow_api::manager::GetFlowCellTypesRequest* Arena::CreateMaybeMessage<::minknow_api::manager::GetFlowCellTypesRequest>(Arena*);
template<> ::minknow_api::manager::GetFlowCellTypesResponse* Arena::CreateMaybeMessage<::minknow_api::manager::GetFlowCellTypesResponse>(Arena*);
template<> ::minknow_api::manager::GetFlowCellTypesResponse_Info* Arena::CreateMaybeMessage<::minknow_api::manager::GetFlowCellTypesResponse_Info>(Arena*);
template<> ::minknow_api::manager::GetGuppyInfoRequest* Arena::CreateMaybeMessage<::minknow_api::manager::GetGuppyInfoRequest>(Arena*);
template<> ::minknow_api::manager::GetGuppyInfoResponse* Arena::CreateMaybeMessage<::minknow_api::manager::GetGuppyInfoResponse>(Arena*);
template<> ::minknow_api::manager::GetLampKitInfoRequest* Arena::CreateMaybeMessage<::minknow_api::manager::GetLampKitInfoRequest>(Arena*);
template<> ::minknow_api::manager::GetLampKitInfoResponse* Arena::CreateMaybeMessage<::minknow_api::manager::GetLampKitInfoResponse>(Arena*);
template<> ::minknow_api::manager::GetSequencingKitsRequest* Arena::CreateMaybeMessage<::minknow_api::manager::GetSequencingKitsRequest>(Arena*);
template<> ::minknow_api::manager::GetSequencingKitsResponse* Arena::CreateMaybeMessage<::minknow_api::manager::GetSequencingKitsResponse>(Arena*);
template<> ::minknow_api::manager::GetSequencingKitsResponse_BarcodingExpansionKit* Arena::CreateMaybeMessage<::minknow_api::manager::GetSequencingKitsResponse_BarcodingExpansionKit>(Arena*);
template<> ::minknow_api::manager::GetSequencingKitsResponse_Kit* Arena::CreateMaybeMessage<::minknow_api::manager::GetSequencingKitsResponse_Kit>(Arena*);
template<> ::minknow_api::manager::GetVersionInfoRequest* Arena::CreateMaybeMessage<::minknow_api::manager::GetVersionInfoRequest>(Arena*);
template<> ::minknow_api::manager::GetVersionInfoResponse* Arena::CreateMaybeMessage<::minknow_api::manager::GetVersionInfoResponse>(Arena*);
template<> ::minknow_api::manager::ListDeveloperApiTokensRequest* Arena::CreateMaybeMessage<::minknow_api::manager::ListDeveloperApiTokensRequest>(Arena*);
template<> ::minknow_api::manager::ListDeveloperApiTokensResponse* Arena::CreateMaybeMessage<::minknow_api::manager::ListDeveloperApiTokensResponse>(Arena*);
template<> ::minknow_api::manager::ListDeveloperApiTokensResponse_DeveloperApiToken* Arena::CreateMaybeMessage<::minknow_api::manager::ListDeveloperApiTokensResponse_DeveloperApiToken>(Arena*);
template<> ::minknow_api::manager::ListProtocolOutputDirFilesRequest* Arena::CreateMaybeMessage<::minknow_api::manager::ListProtocolOutputDirFilesRequest>(Arena*);
template<> ::minknow_api::manager::ListProtocolOutputDirFilesResponse* Arena::CreateMaybeMessage<::minknow_api::manager::ListProtocolOutputDirFilesResponse>(Arena*);
template<> ::minknow_api::manager::ListProtocolOutputDirFilesResponse_DirectoryInfo* Arena::CreateMaybeMessage<::minknow_api::manager::ListProtocolOutputDirFilesResponse_DirectoryInfo>(Arena*);
template<> ::minknow_api::manager::LocalAuthenticationTokenPathRequest* Arena::CreateMaybeMessage<::minknow_api::manager::LocalAuthenticationTokenPathRequest>(Arena*);
template<> ::minknow_api::manager::LocalAuthenticationTokenPathResponse* Arena::CreateMaybeMessage<::minknow_api::manager::LocalAuthenticationTokenPathResponse>(Arena*);
template<> ::minknow_api::manager::RemoveSimulatedDeviceRequest* Arena::CreateMaybeMessage<::minknow_api::manager::RemoveSimulatedDeviceRequest>(Arena*);
template<> ::minknow_api::manager::RemoveSimulatedDeviceResponse* Arena::CreateMaybeMessage<::minknow_api::manager::RemoveSimulatedDeviceResponse>(Arena*);
template<> ::minknow_api::manager::ResetPositionRequest* Arena::CreateMaybeMessage<::minknow_api::manager::ResetPositionRequest>(Arena*);
template<> ::minknow_api::manager::ResetPositionResponse* Arena::CreateMaybeMessage<::minknow_api::manager::ResetPositionResponse>(Arena*);
template<> ::minknow_api::manager::RevokeDeveloperApiTokenRequest* Arena::CreateMaybeMessage<::minknow_api::manager::RevokeDeveloperApiTokenRequest>(Arena*);
template<> ::minknow_api::manager::RevokeDeveloperApiTokensResponse* Arena::CreateMaybeMessage<::minknow_api::manager::RevokeDeveloperApiTokensResponse>(Arena*);
template<> ::minknow_api::manager::StreamDiskSpaceInfoRequest* Arena::CreateMaybeMessage<::minknow_api::manager::StreamDiskSpaceInfoRequest>(Arena*);
template<> ::minknow_api::manager::WatchFlowCellPositionsRequest* Arena::CreateMaybeMessage<::minknow_api::manager::WatchFlowCellPositionsRequest>(Arena*);
template<> ::minknow_api::manager::WatchFlowCellPositionsResponse* Arena::CreateMaybeMessage<::minknow_api::manager::WatchFlowCellPositionsResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace minknow_api {
namespace manager {

enum FlowCellPosition_State : int {
  FlowCellPosition_State_STATE_INITIALISING = 0,
  FlowCellPosition_State_STATE_RUNNING = 1,
  FlowCellPosition_State_STATE_RESETTING = 2,
  FlowCellPosition_State_STATE_HARDWARE_REMOVED = 3,
  FlowCellPosition_State_STATE_HARDWARE_ERROR = 4,
  FlowCellPosition_State_STATE_SOFTWARE_ERROR = 5,
  FlowCellPosition_State_STATE_NEEDS_ASSOCIATION = 6,
  FlowCellPosition_State_FlowCellPosition_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  FlowCellPosition_State_FlowCellPosition_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool FlowCellPosition_State_IsValid(int value);
constexpr FlowCellPosition_State FlowCellPosition_State_State_MIN = FlowCellPosition_State_STATE_INITIALISING;
constexpr FlowCellPosition_State FlowCellPosition_State_State_MAX = FlowCellPosition_State_STATE_NEEDS_ASSOCIATION;
constexpr int FlowCellPosition_State_State_ARRAYSIZE = FlowCellPosition_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FlowCellPosition_State_descriptor();
template<typename T>
inline const std::string& FlowCellPosition_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FlowCellPosition_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FlowCellPosition_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FlowCellPosition_State_descriptor(), enum_t_value);
}
inline bool FlowCellPosition_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FlowCellPosition_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FlowCellPosition_State>(
    FlowCellPosition_State_descriptor(), name, value);
}
enum GetVersionInfoResponse_InstallationType : int {
  GetVersionInfoResponse_InstallationType_ONT = 0,
  GetVersionInfoResponse_InstallationType_NC = 1,
  GetVersionInfoResponse_InstallationType_PROD = 2,
  GetVersionInfoResponse_InstallationType_Q_RELEASE = 3,
  GetVersionInfoResponse_InstallationType_OND_RELEASE = 4,
  GetVersionInfoResponse_InstallationType_GetVersionInfoResponse_InstallationType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  GetVersionInfoResponse_InstallationType_GetVersionInfoResponse_InstallationType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool GetVersionInfoResponse_InstallationType_IsValid(int value);
constexpr GetVersionInfoResponse_InstallationType GetVersionInfoResponse_InstallationType_InstallationType_MIN = GetVersionInfoResponse_InstallationType_ONT;
constexpr GetVersionInfoResponse_InstallationType GetVersionInfoResponse_InstallationType_InstallationType_MAX = GetVersionInfoResponse_InstallationType_OND_RELEASE;
constexpr int GetVersionInfoResponse_InstallationType_InstallationType_ARRAYSIZE = GetVersionInfoResponse_InstallationType_InstallationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GetVersionInfoResponse_InstallationType_descriptor();
template<typename T>
inline const std::string& GetVersionInfoResponse_InstallationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GetVersionInfoResponse_InstallationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GetVersionInfoResponse_InstallationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GetVersionInfoResponse_InstallationType_descriptor(), enum_t_value);
}
inline bool GetVersionInfoResponse_InstallationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GetVersionInfoResponse_InstallationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GetVersionInfoResponse_InstallationType>(
    GetVersionInfoResponse_InstallationType_descriptor(), name, value);
}
enum ExperimentType : int {
  SEQUENCING = 0,
  CONTROL = 1,
  CUSTOM = 2,
  ALL_EXCEPT_HIDDEN = 3,
  ALL_INCLUDING_HIDDEN = 4,
  ExperimentType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ExperimentType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ExperimentType_IsValid(int value);
constexpr ExperimentType ExperimentType_MIN = SEQUENCING;
constexpr ExperimentType ExperimentType_MAX = ALL_INCLUDING_HIDDEN;
constexpr int ExperimentType_ARRAYSIZE = ExperimentType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ExperimentType_descriptor();
template<typename T>
inline const std::string& ExperimentType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExperimentType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExperimentType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ExperimentType_descriptor(), enum_t_value);
}
inline bool ExperimentType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExperimentType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ExperimentType>(
    ExperimentType_descriptor(), name, value);
}
// ===================================================================

class DescribeHostRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:minknow_api.manager.DescribeHostRequest) */ {
 public:
  inline DescribeHostRequest() : DescribeHostRequest(nullptr) {}
  explicit constexpr DescribeHostRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DescribeHostRequest(const DescribeHostRequest& from);
  DescribeHostRequest(DescribeHostRequest&& from) noexcept
    : DescribeHostRequest() {
    *this = ::std::move(from);
  }

  inline DescribeHostRequest& operator=(const DescribeHostRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DescribeHostRequest& operator=(DescribeHostRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DescribeHostRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DescribeHostRequest* internal_default_instance() {
    return reinterpret_cast<const DescribeHostRequest*>(
               &_DescribeHostRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DescribeHostRequest& a, DescribeHostRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DescribeHostRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DescribeHostRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DescribeHostRequest* New() const final {
    return new DescribeHostRequest();
  }

  DescribeHostRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DescribeHostRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DescribeHostRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DescribeHostRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.DescribeHostRequest";
  }
  protected:
  explicit DescribeHostRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:minknow_api.manager.DescribeHostRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class DescribeHostResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.DescribeHostResponse) */ {
 public:
  inline DescribeHostResponse() : DescribeHostResponse(nullptr) {}
  ~DescribeHostResponse() override;
  explicit constexpr DescribeHostResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DescribeHostResponse(const DescribeHostResponse& from);
  DescribeHostResponse(DescribeHostResponse&& from) noexcept
    : DescribeHostResponse() {
    *this = ::std::move(from);
  }

  inline DescribeHostResponse& operator=(const DescribeHostResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DescribeHostResponse& operator=(DescribeHostResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DescribeHostResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DescribeHostResponse* internal_default_instance() {
    return reinterpret_cast<const DescribeHostResponse*>(
               &_DescribeHostResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DescribeHostResponse& a, DescribeHostResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DescribeHostResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DescribeHostResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DescribeHostResponse* New() const final {
    return new DescribeHostResponse();
  }

  DescribeHostResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DescribeHostResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DescribeHostResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DescribeHostResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DescribeHostResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.DescribeHostResponse";
  }
  protected:
  explicit DescribeHostResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProductCodeFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kSerialFieldNumber = 3,
    kNetworkNameFieldNumber = 4,
    kNeedsAssociationFieldNumber = 16,
    kCanSequenceOfflineFieldNumber = 5,
  };
  // string product_code = 1;
  void clear_product_code();
  const std::string& product_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_product_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_product_code();
  PROTOBUF_MUST_USE_RESULT std::string* release_product_code();
  void set_allocated_product_code(std::string* product_code);
  private:
  const std::string& _internal_product_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_product_code(const std::string& value);
  std::string* _internal_mutable_product_code();
  public:

  // string description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_MUST_USE_RESULT std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string serial = 3;
  void clear_serial();
  const std::string& serial() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serial(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serial();
  PROTOBUF_MUST_USE_RESULT std::string* release_serial();
  void set_allocated_serial(std::string* serial);
  private:
  const std::string& _internal_serial() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serial(const std::string& value);
  std::string* _internal_mutable_serial();
  public:

  // string network_name = 4;
  void clear_network_name();
  const std::string& network_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_network_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_network_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_network_name();
  void set_allocated_network_name(std::string* network_name);
  private:
  const std::string& _internal_network_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_network_name(const std::string& value);
  std::string* _internal_mutable_network_name();
  public:

  // bool needs_association = 16;
  void clear_needs_association();
  bool needs_association() const;
  void set_needs_association(bool value);
  private:
  bool _internal_needs_association() const;
  void _internal_set_needs_association(bool value);
  public:

  // bool can_sequence_offline = 5;
  void clear_can_sequence_offline();
  bool can_sequence_offline() const;
  void set_can_sequence_offline(bool value);
  private:
  bool _internal_can_sequence_offline() const;
  void _internal_set_can_sequence_offline(bool value);
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.manager.DescribeHostResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr product_code_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serial_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr network_name_;
  bool needs_association_;
  bool can_sequence_offline_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class FlowCellPosition_Location final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.FlowCellPosition.Location) */ {
 public:
  inline FlowCellPosition_Location() : FlowCellPosition_Location(nullptr) {}
  ~FlowCellPosition_Location() override;
  explicit constexpr FlowCellPosition_Location(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlowCellPosition_Location(const FlowCellPosition_Location& from);
  FlowCellPosition_Location(FlowCellPosition_Location&& from) noexcept
    : FlowCellPosition_Location() {
    *this = ::std::move(from);
  }

  inline FlowCellPosition_Location& operator=(const FlowCellPosition_Location& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowCellPosition_Location& operator=(FlowCellPosition_Location&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowCellPosition_Location& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowCellPosition_Location* internal_default_instance() {
    return reinterpret_cast<const FlowCellPosition_Location*>(
               &_FlowCellPosition_Location_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FlowCellPosition_Location& a, FlowCellPosition_Location& b) {
    a.Swap(&b);
  }
  inline void Swap(FlowCellPosition_Location* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowCellPosition_Location* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FlowCellPosition_Location* New() const final {
    return new FlowCellPosition_Location();
  }

  FlowCellPosition_Location* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FlowCellPosition_Location>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlowCellPosition_Location& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FlowCellPosition_Location& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowCellPosition_Location* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.FlowCellPosition.Location";
  }
  protected:
  explicit FlowCellPosition_Location(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // int32 x = 1;
  void clear_x();
  ::PROTOBUF_NAMESPACE_ID::int32 x() const;
  void set_x(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_x() const;
  void _internal_set_x(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 y = 2;
  void clear_y();
  ::PROTOBUF_NAMESPACE_ID::int32 y() const;
  void set_y(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_y() const;
  void _internal_set_y(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.manager.FlowCellPosition.Location)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 x_;
  ::PROTOBUF_NAMESPACE_ID::int32 y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class FlowCellPosition_RpcPorts final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.FlowCellPosition.RpcPorts) */ {
 public:
  inline FlowCellPosition_RpcPorts() : FlowCellPosition_RpcPorts(nullptr) {}
  ~FlowCellPosition_RpcPorts() override;
  explicit constexpr FlowCellPosition_RpcPorts(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlowCellPosition_RpcPorts(const FlowCellPosition_RpcPorts& from);
  FlowCellPosition_RpcPorts(FlowCellPosition_RpcPorts&& from) noexcept
    : FlowCellPosition_RpcPorts() {
    *this = ::std::move(from);
  }

  inline FlowCellPosition_RpcPorts& operator=(const FlowCellPosition_RpcPorts& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowCellPosition_RpcPorts& operator=(FlowCellPosition_RpcPorts&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowCellPosition_RpcPorts& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowCellPosition_RpcPorts* internal_default_instance() {
    return reinterpret_cast<const FlowCellPosition_RpcPorts*>(
               &_FlowCellPosition_RpcPorts_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(FlowCellPosition_RpcPorts& a, FlowCellPosition_RpcPorts& b) {
    a.Swap(&b);
  }
  inline void Swap(FlowCellPosition_RpcPorts* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowCellPosition_RpcPorts* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FlowCellPosition_RpcPorts* New() const final {
    return new FlowCellPosition_RpcPorts();
  }

  FlowCellPosition_RpcPorts* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FlowCellPosition_RpcPorts>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlowCellPosition_RpcPorts& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FlowCellPosition_RpcPorts& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowCellPosition_RpcPorts* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.FlowCellPosition.RpcPorts";
  }
  protected:
  explicit FlowCellPosition_RpcPorts(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecureFieldNumber = 1,
    kInsecureFieldNumber = 2,
    kSecureGrpcWebFieldNumber = 3,
    kInsecureGrpcWebFieldNumber = 4,
  };
  // uint32 secure = 1;
  void clear_secure();
  ::PROTOBUF_NAMESPACE_ID::uint32 secure() const;
  void set_secure(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_secure() const;
  void _internal_set_secure(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 insecure = 2;
  void clear_insecure();
  ::PROTOBUF_NAMESPACE_ID::uint32 insecure() const;
  void set_insecure(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_insecure() const;
  void _internal_set_insecure(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 secure_grpc_web = 3;
  void clear_secure_grpc_web();
  ::PROTOBUF_NAMESPACE_ID::uint32 secure_grpc_web() const;
  void set_secure_grpc_web(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_secure_grpc_web() const;
  void _internal_set_secure_grpc_web(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 insecure_grpc_web = 4;
  void clear_insecure_grpc_web();
  ::PROTOBUF_NAMESPACE_ID::uint32 insecure_grpc_web() const;
  void set_insecure_grpc_web(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_insecure_grpc_web() const;
  void _internal_set_insecure_grpc_web(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.manager.FlowCellPosition.RpcPorts)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 secure_;
  ::PROTOBUF_NAMESPACE_ID::uint32 insecure_;
  ::PROTOBUF_NAMESPACE_ID::uint32 secure_grpc_web_;
  ::PROTOBUF_NAMESPACE_ID::uint32 insecure_grpc_web_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class FlowCellPosition_SharedHardwareGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.FlowCellPosition.SharedHardwareGroup) */ {
 public:
  inline FlowCellPosition_SharedHardwareGroup() : FlowCellPosition_SharedHardwareGroup(nullptr) {}
  ~FlowCellPosition_SharedHardwareGroup() override;
  explicit constexpr FlowCellPosition_SharedHardwareGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlowCellPosition_SharedHardwareGroup(const FlowCellPosition_SharedHardwareGroup& from);
  FlowCellPosition_SharedHardwareGroup(FlowCellPosition_SharedHardwareGroup&& from) noexcept
    : FlowCellPosition_SharedHardwareGroup() {
    *this = ::std::move(from);
  }

  inline FlowCellPosition_SharedHardwareGroup& operator=(const FlowCellPosition_SharedHardwareGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowCellPosition_SharedHardwareGroup& operator=(FlowCellPosition_SharedHardwareGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowCellPosition_SharedHardwareGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowCellPosition_SharedHardwareGroup* internal_default_instance() {
    return reinterpret_cast<const FlowCellPosition_SharedHardwareGroup*>(
               &_FlowCellPosition_SharedHardwareGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FlowCellPosition_SharedHardwareGroup& a, FlowCellPosition_SharedHardwareGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(FlowCellPosition_SharedHardwareGroup* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowCellPosition_SharedHardwareGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FlowCellPosition_SharedHardwareGroup* New() const final {
    return new FlowCellPosition_SharedHardwareGroup();
  }

  FlowCellPosition_SharedHardwareGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FlowCellPosition_SharedHardwareGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlowCellPosition_SharedHardwareGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FlowCellPosition_SharedHardwareGroup& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowCellPosition_SharedHardwareGroup* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.FlowCellPosition.SharedHardwareGroup";
  }
  protected:
  explicit FlowCellPosition_SharedHardwareGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupIdFieldNumber = 1,
  };
  // uint32 group_id = 1;
  void clear_group_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 group_id() const;
  void set_group_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_group_id() const;
  void _internal_set_group_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.manager.FlowCellPosition.SharedHardwareGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 group_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class FlowCellPosition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.FlowCellPosition) */ {
 public:
  inline FlowCellPosition() : FlowCellPosition(nullptr) {}
  ~FlowCellPosition() override;
  explicit constexpr FlowCellPosition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlowCellPosition(const FlowCellPosition& from);
  FlowCellPosition(FlowCellPosition&& from) noexcept
    : FlowCellPosition() {
    *this = ::std::move(from);
  }

  inline FlowCellPosition& operator=(const FlowCellPosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowCellPosition& operator=(FlowCellPosition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowCellPosition& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowCellPosition* internal_default_instance() {
    return reinterpret_cast<const FlowCellPosition*>(
               &_FlowCellPosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(FlowCellPosition& a, FlowCellPosition& b) {
    a.Swap(&b);
  }
  inline void Swap(FlowCellPosition* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowCellPosition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FlowCellPosition* New() const final {
    return new FlowCellPosition();
  }

  FlowCellPosition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FlowCellPosition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlowCellPosition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FlowCellPosition& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowCellPosition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.FlowCellPosition";
  }
  protected:
  explicit FlowCellPosition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FlowCellPosition_Location Location;
  typedef FlowCellPosition_RpcPorts RpcPorts;
  typedef FlowCellPosition_SharedHardwareGroup SharedHardwareGroup;

  typedef FlowCellPosition_State State;
  static constexpr State STATE_INITIALISING =
    FlowCellPosition_State_STATE_INITIALISING;
  static constexpr State STATE_RUNNING =
    FlowCellPosition_State_STATE_RUNNING;
  static constexpr State STATE_RESETTING =
    FlowCellPosition_State_STATE_RESETTING;
  static constexpr State STATE_HARDWARE_REMOVED =
    FlowCellPosition_State_STATE_HARDWARE_REMOVED;
  static constexpr State STATE_HARDWARE_ERROR =
    FlowCellPosition_State_STATE_HARDWARE_ERROR;
  static constexpr State STATE_SOFTWARE_ERROR =
    FlowCellPosition_State_STATE_SOFTWARE_ERROR;
  static constexpr State STATE_NEEDS_ASSOCIATION =
    FlowCellPosition_State_STATE_NEEDS_ASSOCIATION;
  static inline bool State_IsValid(int value) {
    return FlowCellPosition_State_IsValid(value);
  }
  static constexpr State State_MIN =
    FlowCellPosition_State_State_MIN;
  static constexpr State State_MAX =
    FlowCellPosition_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    FlowCellPosition_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return FlowCellPosition_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return FlowCellPosition_State_Name(enum_t_value);
  }
  static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      State* value) {
    return FlowCellPosition_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kErrorInfoFieldNumber = 5,
    kLocationFieldNumber = 2,
    kRpcPortsFieldNumber = 4,
    kSharedHardwareGroupFieldNumber = 6,
    kStateFieldNumber = 3,
    kIsIntegratedFieldNumber = 7,
    kCanSequenceOfflineFieldNumber = 8,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string error_info = 5;
  void clear_error_info();
  const std::string& error_info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_info();
  PROTOBUF_MUST_USE_RESULT std::string* release_error_info();
  void set_allocated_error_info(std::string* error_info);
  private:
  const std::string& _internal_error_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_info(const std::string& value);
  std::string* _internal_mutable_error_info();
  public:

  // .minknow_api.manager.FlowCellPosition.Location location = 2;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::minknow_api::manager::FlowCellPosition_Location& location() const;
  PROTOBUF_MUST_USE_RESULT ::minknow_api::manager::FlowCellPosition_Location* release_location();
  ::minknow_api::manager::FlowCellPosition_Location* mutable_location();
  void set_allocated_location(::minknow_api::manager::FlowCellPosition_Location* location);
  private:
  const ::minknow_api::manager::FlowCellPosition_Location& _internal_location() const;
  ::minknow_api::manager::FlowCellPosition_Location* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::minknow_api::manager::FlowCellPosition_Location* location);
  ::minknow_api::manager::FlowCellPosition_Location* unsafe_arena_release_location();

  // .minknow_api.manager.FlowCellPosition.RpcPorts rpc_ports = 4;
  bool has_rpc_ports() const;
  private:
  bool _internal_has_rpc_ports() const;
  public:
  void clear_rpc_ports();
  const ::minknow_api::manager::FlowCellPosition_RpcPorts& rpc_ports() const;
  PROTOBUF_MUST_USE_RESULT ::minknow_api::manager::FlowCellPosition_RpcPorts* release_rpc_ports();
  ::minknow_api::manager::FlowCellPosition_RpcPorts* mutable_rpc_ports();
  void set_allocated_rpc_ports(::minknow_api::manager::FlowCellPosition_RpcPorts* rpc_ports);
  private:
  const ::minknow_api::manager::FlowCellPosition_RpcPorts& _internal_rpc_ports() const;
  ::minknow_api::manager::FlowCellPosition_RpcPorts* _internal_mutable_rpc_ports();
  public:
  void unsafe_arena_set_allocated_rpc_ports(
      ::minknow_api::manager::FlowCellPosition_RpcPorts* rpc_ports);
  ::minknow_api::manager::FlowCellPosition_RpcPorts* unsafe_arena_release_rpc_ports();

  // .minknow_api.manager.FlowCellPosition.SharedHardwareGroup shared_hardware_group = 6;
  bool has_shared_hardware_group() const;
  private:
  bool _internal_has_shared_hardware_group() const;
  public:
  void clear_shared_hardware_group();
  const ::minknow_api::manager::FlowCellPosition_SharedHardwareGroup& shared_hardware_group() const;
  PROTOBUF_MUST_USE_RESULT ::minknow_api::manager::FlowCellPosition_SharedHardwareGroup* release_shared_hardware_group();
  ::minknow_api::manager::FlowCellPosition_SharedHardwareGroup* mutable_shared_hardware_group();
  void set_allocated_shared_hardware_group(::minknow_api::manager::FlowCellPosition_SharedHardwareGroup* shared_hardware_group);
  private:
  const ::minknow_api::manager::FlowCellPosition_SharedHardwareGroup& _internal_shared_hardware_group() const;
  ::minknow_api::manager::FlowCellPosition_SharedHardwareGroup* _internal_mutable_shared_hardware_group();
  public:
  void unsafe_arena_set_allocated_shared_hardware_group(
      ::minknow_api::manager::FlowCellPosition_SharedHardwareGroup* shared_hardware_group);
  ::minknow_api::manager::FlowCellPosition_SharedHardwareGroup* unsafe_arena_release_shared_hardware_group();

  // .minknow_api.manager.FlowCellPosition.State state = 3;
  void clear_state();
  ::minknow_api::manager::FlowCellPosition_State state() const;
  void set_state(::minknow_api::manager::FlowCellPosition_State value);
  private:
  ::minknow_api::manager::FlowCellPosition_State _internal_state() const;
  void _internal_set_state(::minknow_api::manager::FlowCellPosition_State value);
  public:

  // bool is_integrated = 7;
  void clear_is_integrated();
  bool is_integrated() const;
  void set_is_integrated(bool value);
  private:
  bool _internal_is_integrated() const;
  void _internal_set_is_integrated(bool value);
  public:

  // bool can_sequence_offline = 8;
  void clear_can_sequence_offline();
  bool can_sequence_offline() const;
  void set_can_sequence_offline(bool value);
  private:
  bool _internal_can_sequence_offline() const;
  void _internal_set_can_sequence_offline(bool value);
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.manager.FlowCellPosition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_info_;
  ::minknow_api::manager::FlowCellPosition_Location* location_;
  ::minknow_api::manager::FlowCellPosition_RpcPorts* rpc_ports_;
  ::minknow_api::manager::FlowCellPosition_SharedHardwareGroup* shared_hardware_group_;
  int state_;
  bool is_integrated_;
  bool can_sequence_offline_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class FlowCellPositionsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:minknow_api.manager.FlowCellPositionsRequest) */ {
 public:
  inline FlowCellPositionsRequest() : FlowCellPositionsRequest(nullptr) {}
  explicit constexpr FlowCellPositionsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlowCellPositionsRequest(const FlowCellPositionsRequest& from);
  FlowCellPositionsRequest(FlowCellPositionsRequest&& from) noexcept
    : FlowCellPositionsRequest() {
    *this = ::std::move(from);
  }

  inline FlowCellPositionsRequest& operator=(const FlowCellPositionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowCellPositionsRequest& operator=(FlowCellPositionsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowCellPositionsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowCellPositionsRequest* internal_default_instance() {
    return reinterpret_cast<const FlowCellPositionsRequest*>(
               &_FlowCellPositionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(FlowCellPositionsRequest& a, FlowCellPositionsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FlowCellPositionsRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowCellPositionsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FlowCellPositionsRequest* New() const final {
    return new FlowCellPositionsRequest();
  }

  FlowCellPositionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FlowCellPositionsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const FlowCellPositionsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const FlowCellPositionsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.FlowCellPositionsRequest";
  }
  protected:
  explicit FlowCellPositionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:minknow_api.manager.FlowCellPositionsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class FlowCellPositionsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.FlowCellPositionsResponse) */ {
 public:
  inline FlowCellPositionsResponse() : FlowCellPositionsResponse(nullptr) {}
  ~FlowCellPositionsResponse() override;
  explicit constexpr FlowCellPositionsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlowCellPositionsResponse(const FlowCellPositionsResponse& from);
  FlowCellPositionsResponse(FlowCellPositionsResponse&& from) noexcept
    : FlowCellPositionsResponse() {
    *this = ::std::move(from);
  }

  inline FlowCellPositionsResponse& operator=(const FlowCellPositionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowCellPositionsResponse& operator=(FlowCellPositionsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowCellPositionsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowCellPositionsResponse* internal_default_instance() {
    return reinterpret_cast<const FlowCellPositionsResponse*>(
               &_FlowCellPositionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(FlowCellPositionsResponse& a, FlowCellPositionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FlowCellPositionsResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowCellPositionsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FlowCellPositionsResponse* New() const final {
    return new FlowCellPositionsResponse();
  }

  FlowCellPositionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FlowCellPositionsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlowCellPositionsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FlowCellPositionsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowCellPositionsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.FlowCellPositionsResponse";
  }
  protected:
  explicit FlowCellPositionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionsFieldNumber = 2,
    kTotalCountFieldNumber = 1,
  };
  // repeated .minknow_api.manager.FlowCellPosition positions = 2;
  int positions_size() const;
  private:
  int _internal_positions_size() const;
  public:
  void clear_positions();
  ::minknow_api::manager::FlowCellPosition* mutable_positions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::FlowCellPosition >*
      mutable_positions();
  private:
  const ::minknow_api::manager::FlowCellPosition& _internal_positions(int index) const;
  ::minknow_api::manager::FlowCellPosition* _internal_add_positions();
  public:
  const ::minknow_api::manager::FlowCellPosition& positions(int index) const;
  ::minknow_api::manager::FlowCellPosition* add_positions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::FlowCellPosition >&
      positions() const;

  // int32 total_count = 1;
  void clear_total_count();
  ::PROTOBUF_NAMESPACE_ID::int32 total_count() const;
  void set_total_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_total_count() const;
  void _internal_set_total_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.manager.FlowCellPositionsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::FlowCellPosition > positions_;
  ::PROTOBUF_NAMESPACE_ID::int32 total_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class WatchFlowCellPositionsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:minknow_api.manager.WatchFlowCellPositionsRequest) */ {
 public:
  inline WatchFlowCellPositionsRequest() : WatchFlowCellPositionsRequest(nullptr) {}
  explicit constexpr WatchFlowCellPositionsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WatchFlowCellPositionsRequest(const WatchFlowCellPositionsRequest& from);
  WatchFlowCellPositionsRequest(WatchFlowCellPositionsRequest&& from) noexcept
    : WatchFlowCellPositionsRequest() {
    *this = ::std::move(from);
  }

  inline WatchFlowCellPositionsRequest& operator=(const WatchFlowCellPositionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WatchFlowCellPositionsRequest& operator=(WatchFlowCellPositionsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WatchFlowCellPositionsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WatchFlowCellPositionsRequest* internal_default_instance() {
    return reinterpret_cast<const WatchFlowCellPositionsRequest*>(
               &_WatchFlowCellPositionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(WatchFlowCellPositionsRequest& a, WatchFlowCellPositionsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WatchFlowCellPositionsRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WatchFlowCellPositionsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WatchFlowCellPositionsRequest* New() const final {
    return new WatchFlowCellPositionsRequest();
  }

  WatchFlowCellPositionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WatchFlowCellPositionsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const WatchFlowCellPositionsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const WatchFlowCellPositionsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.WatchFlowCellPositionsRequest";
  }
  protected:
  explicit WatchFlowCellPositionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:minknow_api.manager.WatchFlowCellPositionsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class WatchFlowCellPositionsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.WatchFlowCellPositionsResponse) */ {
 public:
  inline WatchFlowCellPositionsResponse() : WatchFlowCellPositionsResponse(nullptr) {}
  ~WatchFlowCellPositionsResponse() override;
  explicit constexpr WatchFlowCellPositionsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WatchFlowCellPositionsResponse(const WatchFlowCellPositionsResponse& from);
  WatchFlowCellPositionsResponse(WatchFlowCellPositionsResponse&& from) noexcept
    : WatchFlowCellPositionsResponse() {
    *this = ::std::move(from);
  }

  inline WatchFlowCellPositionsResponse& operator=(const WatchFlowCellPositionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WatchFlowCellPositionsResponse& operator=(WatchFlowCellPositionsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WatchFlowCellPositionsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const WatchFlowCellPositionsResponse* internal_default_instance() {
    return reinterpret_cast<const WatchFlowCellPositionsResponse*>(
               &_WatchFlowCellPositionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(WatchFlowCellPositionsResponse& a, WatchFlowCellPositionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(WatchFlowCellPositionsResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WatchFlowCellPositionsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WatchFlowCellPositionsResponse* New() const final {
    return new WatchFlowCellPositionsResponse();
  }

  WatchFlowCellPositionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WatchFlowCellPositionsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WatchFlowCellPositionsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WatchFlowCellPositionsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WatchFlowCellPositionsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.WatchFlowCellPositionsResponse";
  }
  protected:
  explicit WatchFlowCellPositionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionsFieldNumber = 1,
    kChangesFieldNumber = 2,
    kRemovalsFieldNumber = 3,
  };
  // repeated .minknow_api.manager.FlowCellPosition additions = 1;
  int additions_size() const;
  private:
  int _internal_additions_size() const;
  public:
  void clear_additions();
  ::minknow_api::manager::FlowCellPosition* mutable_additions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::FlowCellPosition >*
      mutable_additions();
  private:
  const ::minknow_api::manager::FlowCellPosition& _internal_additions(int index) const;
  ::minknow_api::manager::FlowCellPosition* _internal_add_additions();
  public:
  const ::minknow_api::manager::FlowCellPosition& additions(int index) const;
  ::minknow_api::manager::FlowCellPosition* add_additions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::FlowCellPosition >&
      additions() const;

  // repeated .minknow_api.manager.FlowCellPosition changes = 2;
  int changes_size() const;
  private:
  int _internal_changes_size() const;
  public:
  void clear_changes();
  ::minknow_api::manager::FlowCellPosition* mutable_changes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::FlowCellPosition >*
      mutable_changes();
  private:
  const ::minknow_api::manager::FlowCellPosition& _internal_changes(int index) const;
  ::minknow_api::manager::FlowCellPosition* _internal_add_changes();
  public:
  const ::minknow_api::manager::FlowCellPosition& changes(int index) const;
  ::minknow_api::manager::FlowCellPosition* add_changes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::FlowCellPosition >&
      changes() const;

  // repeated string removals = 3;
  int removals_size() const;
  private:
  int _internal_removals_size() const;
  public:
  void clear_removals();
  const std::string& removals(int index) const;
  std::string* mutable_removals(int index);
  void set_removals(int index, const std::string& value);
  void set_removals(int index, std::string&& value);
  void set_removals(int index, const char* value);
  void set_removals(int index, const char* value, size_t size);
  std::string* add_removals();
  void add_removals(const std::string& value);
  void add_removals(std::string&& value);
  void add_removals(const char* value);
  void add_removals(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& removals() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_removals();
  private:
  const std::string& _internal_removals(int index) const;
  std::string* _internal_add_removals();
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.manager.WatchFlowCellPositionsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::FlowCellPosition > additions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::FlowCellPosition > changes_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> removals_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class ResetPositionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.ResetPositionRequest) */ {
 public:
  inline ResetPositionRequest() : ResetPositionRequest(nullptr) {}
  ~ResetPositionRequest() override;
  explicit constexpr ResetPositionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResetPositionRequest(const ResetPositionRequest& from);
  ResetPositionRequest(ResetPositionRequest&& from) noexcept
    : ResetPositionRequest() {
    *this = ::std::move(from);
  }

  inline ResetPositionRequest& operator=(const ResetPositionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetPositionRequest& operator=(ResetPositionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResetPositionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResetPositionRequest* internal_default_instance() {
    return reinterpret_cast<const ResetPositionRequest*>(
               &_ResetPositionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ResetPositionRequest& a, ResetPositionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ResetPositionRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetPositionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResetPositionRequest* New() const final {
    return new ResetPositionRequest();
  }

  ResetPositionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResetPositionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResetPositionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResetPositionRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResetPositionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.ResetPositionRequest";
  }
  protected:
  explicit ResetPositionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionsFieldNumber = 3,
    kForceFieldNumber = 2,
  };
  // repeated string positions = 3;
  int positions_size() const;
  private:
  int _internal_positions_size() const;
  public:
  void clear_positions();
  const std::string& positions(int index) const;
  std::string* mutable_positions(int index);
  void set_positions(int index, const std::string& value);
  void set_positions(int index, std::string&& value);
  void set_positions(int index, const char* value);
  void set_positions(int index, const char* value, size_t size);
  std::string* add_positions();
  void add_positions(const std::string& value);
  void add_positions(std::string&& value);
  void add_positions(const char* value);
  void add_positions(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& positions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_positions();
  private:
  const std::string& _internal_positions(int index) const;
  std::string* _internal_add_positions();
  public:

  // bool force = 2;
  void clear_force();
  bool force() const;
  void set_force(bool value);
  private:
  bool _internal_force() const;
  void _internal_set_force(bool value);
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.manager.ResetPositionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> positions_;
  bool force_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class ResetPositionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:minknow_api.manager.ResetPositionResponse) */ {
 public:
  inline ResetPositionResponse() : ResetPositionResponse(nullptr) {}
  explicit constexpr ResetPositionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResetPositionResponse(const ResetPositionResponse& from);
  ResetPositionResponse(ResetPositionResponse&& from) noexcept
    : ResetPositionResponse() {
    *this = ::std::move(from);
  }

  inline ResetPositionResponse& operator=(const ResetPositionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetPositionResponse& operator=(ResetPositionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResetPositionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResetPositionResponse* internal_default_instance() {
    return reinterpret_cast<const ResetPositionResponse*>(
               &_ResetPositionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ResetPositionResponse& a, ResetPositionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ResetPositionResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetPositionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResetPositionResponse* New() const final {
    return new ResetPositionResponse();
  }

  ResetPositionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResetPositionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ResetPositionResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ResetPositionResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.ResetPositionResponse";
  }
  protected:
  explicit ResetPositionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:minknow_api.manager.ResetPositionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class BasecallerApiRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:minknow_api.manager.BasecallerApiRequest) */ {
 public:
  inline BasecallerApiRequest() : BasecallerApiRequest(nullptr) {}
  explicit constexpr BasecallerApiRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BasecallerApiRequest(const BasecallerApiRequest& from);
  BasecallerApiRequest(BasecallerApiRequest&& from) noexcept
    : BasecallerApiRequest() {
    *this = ::std::move(from);
  }

  inline BasecallerApiRequest& operator=(const BasecallerApiRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BasecallerApiRequest& operator=(BasecallerApiRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BasecallerApiRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BasecallerApiRequest* internal_default_instance() {
    return reinterpret_cast<const BasecallerApiRequest*>(
               &_BasecallerApiRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(BasecallerApiRequest& a, BasecallerApiRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BasecallerApiRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BasecallerApiRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BasecallerApiRequest* New() const final {
    return new BasecallerApiRequest();
  }

  BasecallerApiRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BasecallerApiRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const BasecallerApiRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const BasecallerApiRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.BasecallerApiRequest";
  }
  protected:
  explicit BasecallerApiRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:minknow_api.manager.BasecallerApiRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class BasecallerApiResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.BasecallerApiResponse) */ {
 public:
  inline BasecallerApiResponse() : BasecallerApiResponse(nullptr) {}
  ~BasecallerApiResponse() override;
  explicit constexpr BasecallerApiResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BasecallerApiResponse(const BasecallerApiResponse& from);
  BasecallerApiResponse(BasecallerApiResponse&& from) noexcept
    : BasecallerApiResponse() {
    *this = ::std::move(from);
  }

  inline BasecallerApiResponse& operator=(const BasecallerApiResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BasecallerApiResponse& operator=(BasecallerApiResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BasecallerApiResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BasecallerApiResponse* internal_default_instance() {
    return reinterpret_cast<const BasecallerApiResponse*>(
               &_BasecallerApiResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(BasecallerApiResponse& a, BasecallerApiResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BasecallerApiResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BasecallerApiResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BasecallerApiResponse* New() const final {
    return new BasecallerApiResponse();
  }

  BasecallerApiResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BasecallerApiResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BasecallerApiResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BasecallerApiResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BasecallerApiResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.BasecallerApiResponse";
  }
  protected:
  explicit BasecallerApiResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecureFieldNumber = 1,
    kInsecureFieldNumber = 2,
    kSecureGrpcWebFieldNumber = 3,
    kInsecureGrpcWebFieldNumber = 4,
  };
  // uint32 secure = 1;
  void clear_secure();
  ::PROTOBUF_NAMESPACE_ID::uint32 secure() const;
  void set_secure(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_secure() const;
  void _internal_set_secure(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 insecure = 2;
  void clear_insecure();
  ::PROTOBUF_NAMESPACE_ID::uint32 insecure() const;
  void set_insecure(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_insecure() const;
  void _internal_set_insecure(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 secure_grpc_web = 3;
  void clear_secure_grpc_web();
  ::PROTOBUF_NAMESPACE_ID::uint32 secure_grpc_web() const;
  void set_secure_grpc_web(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_secure_grpc_web() const;
  void _internal_set_secure_grpc_web(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 insecure_grpc_web = 4;
  void clear_insecure_grpc_web();
  ::PROTOBUF_NAMESPACE_ID::uint32 insecure_grpc_web() const;
  void set_insecure_grpc_web(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_insecure_grpc_web() const;
  void _internal_set_insecure_grpc_web(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.manager.BasecallerApiResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 secure_;
  ::PROTOBUF_NAMESPACE_ID::uint32 insecure_;
  ::PROTOBUF_NAMESPACE_ID::uint32 secure_grpc_web_;
  ::PROTOBUF_NAMESPACE_ID::uint32 insecure_grpc_web_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class GetGuppyInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:minknow_api.manager.GetGuppyInfoRequest) */ {
 public:
  inline GetGuppyInfoRequest() : GetGuppyInfoRequest(nullptr) {}
  explicit constexpr GetGuppyInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetGuppyInfoRequest(const GetGuppyInfoRequest& from);
  GetGuppyInfoRequest(GetGuppyInfoRequest&& from) noexcept
    : GetGuppyInfoRequest() {
    *this = ::std::move(from);
  }

  inline GetGuppyInfoRequest& operator=(const GetGuppyInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetGuppyInfoRequest& operator=(GetGuppyInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetGuppyInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetGuppyInfoRequest* internal_default_instance() {
    return reinterpret_cast<const GetGuppyInfoRequest*>(
               &_GetGuppyInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetGuppyInfoRequest& a, GetGuppyInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetGuppyInfoRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetGuppyInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetGuppyInfoRequest* New() const final {
    return new GetGuppyInfoRequest();
  }

  GetGuppyInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetGuppyInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetGuppyInfoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetGuppyInfoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.GetGuppyInfoRequest";
  }
  protected:
  explicit GetGuppyInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:minknow_api.manager.GetGuppyInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class GetGuppyInfoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.GetGuppyInfoResponse) */ {
 public:
  inline GetGuppyInfoResponse() : GetGuppyInfoResponse(nullptr) {}
  ~GetGuppyInfoResponse() override;
  explicit constexpr GetGuppyInfoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetGuppyInfoResponse(const GetGuppyInfoResponse& from);
  GetGuppyInfoResponse(GetGuppyInfoResponse&& from) noexcept
    : GetGuppyInfoResponse() {
    *this = ::std::move(from);
  }

  inline GetGuppyInfoResponse& operator=(const GetGuppyInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetGuppyInfoResponse& operator=(GetGuppyInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetGuppyInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetGuppyInfoResponse* internal_default_instance() {
    return reinterpret_cast<const GetGuppyInfoResponse*>(
               &_GetGuppyInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetGuppyInfoResponse& a, GetGuppyInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetGuppyInfoResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetGuppyInfoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetGuppyInfoResponse* New() const final {
    return new GetGuppyInfoResponse();
  }

  GetGuppyInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetGuppyInfoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetGuppyInfoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetGuppyInfoResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetGuppyInfoResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.GetGuppyInfoResponse";
  }
  protected:
  explicit GetGuppyInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 2,
    kPortFieldNumber = 1,
  };
  // string version = 2;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_MUST_USE_RESULT std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // uint32 port = 1;
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::uint32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.manager.GetGuppyInfoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::uint32 port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class GetVersionInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:minknow_api.manager.GetVersionInfoRequest) */ {
 public:
  inline GetVersionInfoRequest() : GetVersionInfoRequest(nullptr) {}
  explicit constexpr GetVersionInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetVersionInfoRequest(const GetVersionInfoRequest& from);
  GetVersionInfoRequest(GetVersionInfoRequest&& from) noexcept
    : GetVersionInfoRequest() {
    *this = ::std::move(from);
  }

  inline GetVersionInfoRequest& operator=(const GetVersionInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetVersionInfoRequest& operator=(GetVersionInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetVersionInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetVersionInfoRequest* internal_default_instance() {
    return reinterpret_cast<const GetVersionInfoRequest*>(
               &_GetVersionInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GetVersionInfoRequest& a, GetVersionInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetVersionInfoRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetVersionInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetVersionInfoRequest* New() const final {
    return new GetVersionInfoRequest();
  }

  GetVersionInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetVersionInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetVersionInfoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetVersionInfoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.GetVersionInfoRequest";
  }
  protected:
  explicit GetVersionInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:minknow_api.manager.GetVersionInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class GetVersionInfoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.GetVersionInfoResponse) */ {
 public:
  inline GetVersionInfoResponse() : GetVersionInfoResponse(nullptr) {}
  ~GetVersionInfoResponse() override;
  explicit constexpr GetVersionInfoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetVersionInfoResponse(const GetVersionInfoResponse& from);
  GetVersionInfoResponse(GetVersionInfoResponse&& from) noexcept
    : GetVersionInfoResponse() {
    *this = ::std::move(from);
  }

  inline GetVersionInfoResponse& operator=(const GetVersionInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetVersionInfoResponse& operator=(GetVersionInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetVersionInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetVersionInfoResponse* internal_default_instance() {
    return reinterpret_cast<const GetVersionInfoResponse*>(
               &_GetVersionInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(GetVersionInfoResponse& a, GetVersionInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetVersionInfoResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetVersionInfoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetVersionInfoResponse* New() const final {
    return new GetVersionInfoResponse();
  }

  GetVersionInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetVersionInfoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetVersionInfoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetVersionInfoResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetVersionInfoResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.GetVersionInfoResponse";
  }
  protected:
  explicit GetVersionInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GetVersionInfoResponse_InstallationType InstallationType;
  static constexpr InstallationType ONT =
    GetVersionInfoResponse_InstallationType_ONT;
  static constexpr InstallationType NC =
    GetVersionInfoResponse_InstallationType_NC;
  static constexpr InstallationType PROD =
    GetVersionInfoResponse_InstallationType_PROD;
  static constexpr InstallationType Q_RELEASE =
    GetVersionInfoResponse_InstallationType_Q_RELEASE;
  static constexpr InstallationType OND_RELEASE =
    GetVersionInfoResponse_InstallationType_OND_RELEASE;
  static inline bool InstallationType_IsValid(int value) {
    return GetVersionInfoResponse_InstallationType_IsValid(value);
  }
  static constexpr InstallationType InstallationType_MIN =
    GetVersionInfoResponse_InstallationType_InstallationType_MIN;
  static constexpr InstallationType InstallationType_MAX =
    GetVersionInfoResponse_InstallationType_InstallationType_MAX;
  static constexpr int InstallationType_ARRAYSIZE =
    GetVersionInfoResponse_InstallationType_InstallationType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  InstallationType_descriptor() {
    return GetVersionInfoResponse_InstallationType_descriptor();
  }
  template<typename T>
  static inline const std::string& InstallationType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, InstallationType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function InstallationType_Name.");
    return GetVersionInfoResponse_InstallationType_Name(enum_t_value);
  }
  static inline bool InstallationType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      InstallationType* value) {
    return GetVersionInfoResponse_InstallationType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kProtocolsFieldNumber = 2,
    kDistributionVersionFieldNumber = 3,
    kGuppyBuildVersionFieldNumber = 5,
    kGuppyConnectedVersionFieldNumber = 6,
    kConfigurationFieldNumber = 7,
    kMinknowFieldNumber = 1,
    kDistributionStatusFieldNumber = 4,
    kInstallationTypeFieldNumber = 8,
  };
  // string protocols = 2;
  void clear_protocols();
  const std::string& protocols() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_protocols(ArgT0&& arg0, ArgT... args);
  std::string* mutable_protocols();
  PROTOBUF_MUST_USE_RESULT std::string* release_protocols();
  void set_allocated_protocols(std::string* protocols);
  private:
  const std::string& _internal_protocols() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_protocols(const std::string& value);
  std::string* _internal_mutable_protocols();
  public:

  // string distribution_version = 3;
  void clear_distribution_version();
  const std::string& distribution_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_distribution_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_distribution_version();
  PROTOBUF_MUST_USE_RESULT std::string* release_distribution_version();
  void set_allocated_distribution_version(std::string* distribution_version);
  private:
  const std::string& _internal_distribution_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_distribution_version(const std::string& value);
  std::string* _internal_mutable_distribution_version();
  public:

  // string guppy_build_version = 5;
  void clear_guppy_build_version();
  const std::string& guppy_build_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_guppy_build_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_guppy_build_version();
  PROTOBUF_MUST_USE_RESULT std::string* release_guppy_build_version();
  void set_allocated_guppy_build_version(std::string* guppy_build_version);
  private:
  const std::string& _internal_guppy_build_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_guppy_build_version(const std::string& value);
  std::string* _internal_mutable_guppy_build_version();
  public:

  // string guppy_connected_version = 6;
  void clear_guppy_connected_version();
  const std::string& guppy_connected_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_guppy_connected_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_guppy_connected_version();
  PROTOBUF_MUST_USE_RESULT std::string* release_guppy_connected_version();
  void set_allocated_guppy_connected_version(std::string* guppy_connected_version);
  private:
  const std::string& _internal_guppy_connected_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_guppy_connected_version(const std::string& value);
  std::string* _internal_mutable_guppy_connected_version();
  public:

  // string configuration = 7;
  void clear_configuration();
  const std::string& configuration() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_configuration(ArgT0&& arg0, ArgT... args);
  std::string* mutable_configuration();
  PROTOBUF_MUST_USE_RESULT std::string* release_configuration();
  void set_allocated_configuration(std::string* configuration);
  private:
  const std::string& _internal_configuration() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_configuration(const std::string& value);
  std::string* _internal_mutable_configuration();
  public:

  // .minknow_api.instance.GetVersionInfoResponse.MinknowVersion minknow = 1;
  bool has_minknow() const;
  private:
  bool _internal_has_minknow() const;
  public:
  void clear_minknow();
  const ::minknow_api::instance::GetVersionInfoResponse_MinknowVersion& minknow() const;
  PROTOBUF_MUST_USE_RESULT ::minknow_api::instance::GetVersionInfoResponse_MinknowVersion* release_minknow();
  ::minknow_api::instance::GetVersionInfoResponse_MinknowVersion* mutable_minknow();
  void set_allocated_minknow(::minknow_api::instance::GetVersionInfoResponse_MinknowVersion* minknow);
  private:
  const ::minknow_api::instance::GetVersionInfoResponse_MinknowVersion& _internal_minknow() const;
  ::minknow_api::instance::GetVersionInfoResponse_MinknowVersion* _internal_mutable_minknow();
  public:
  void unsafe_arena_set_allocated_minknow(
      ::minknow_api::instance::GetVersionInfoResponse_MinknowVersion* minknow);
  ::minknow_api::instance::GetVersionInfoResponse_MinknowVersion* unsafe_arena_release_minknow();

  // .minknow_api.instance.GetVersionInfoResponse.DistributionStatus distribution_status = 4;
  void clear_distribution_status();
  ::minknow_api::instance::GetVersionInfoResponse_DistributionStatus distribution_status() const;
  void set_distribution_status(::minknow_api::instance::GetVersionInfoResponse_DistributionStatus value);
  private:
  ::minknow_api::instance::GetVersionInfoResponse_DistributionStatus _internal_distribution_status() const;
  void _internal_set_distribution_status(::minknow_api::instance::GetVersionInfoResponse_DistributionStatus value);
  public:

  // .minknow_api.manager.GetVersionInfoResponse.InstallationType installation_type = 8;
  void clear_installation_type();
  ::minknow_api::manager::GetVersionInfoResponse_InstallationType installation_type() const;
  void set_installation_type(::minknow_api::manager::GetVersionInfoResponse_InstallationType value);
  private:
  ::minknow_api::manager::GetVersionInfoResponse_InstallationType _internal_installation_type() const;
  void _internal_set_installation_type(::minknow_api::manager::GetVersionInfoResponse_InstallationType value);
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.manager.GetVersionInfoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr protocols_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr distribution_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr guppy_build_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr guppy_connected_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr configuration_;
  ::minknow_api::instance::GetVersionInfoResponse_MinknowVersion* minknow_;
  int distribution_status_;
  int installation_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class ListProtocolOutputDirFilesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.ListProtocolOutputDirFilesRequest) */ {
 public:
  inline ListProtocolOutputDirFilesRequest() : ListProtocolOutputDirFilesRequest(nullptr) {}
  ~ListProtocolOutputDirFilesRequest() override;
  explicit constexpr ListProtocolOutputDirFilesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListProtocolOutputDirFilesRequest(const ListProtocolOutputDirFilesRequest& from);
  ListProtocolOutputDirFilesRequest(ListProtocolOutputDirFilesRequest&& from) noexcept
    : ListProtocolOutputDirFilesRequest() {
    *this = ::std::move(from);
  }

  inline ListProtocolOutputDirFilesRequest& operator=(const ListProtocolOutputDirFilesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListProtocolOutputDirFilesRequest& operator=(ListProtocolOutputDirFilesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListProtocolOutputDirFilesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListProtocolOutputDirFilesRequest* internal_default_instance() {
    return reinterpret_cast<const ListProtocolOutputDirFilesRequest*>(
               &_ListProtocolOutputDirFilesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ListProtocolOutputDirFilesRequest& a, ListProtocolOutputDirFilesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListProtocolOutputDirFilesRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListProtocolOutputDirFilesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListProtocolOutputDirFilesRequest* New() const final {
    return new ListProtocolOutputDirFilesRequest();
  }

  ListProtocolOutputDirFilesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListProtocolOutputDirFilesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListProtocolOutputDirFilesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListProtocolOutputDirFilesRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListProtocolOutputDirFilesRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.ListProtocolOutputDirFilesRequest";
  }
  protected:
  explicit ListProtocolOutputDirFilesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
  };
  // string path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_MUST_USE_RESULT std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.manager.ListProtocolOutputDirFilesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class ListProtocolOutputDirFilesResponse_DirectoryInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.ListProtocolOutputDirFilesResponse.DirectoryInfo) */ {
 public:
  inline ListProtocolOutputDirFilesResponse_DirectoryInfo() : ListProtocolOutputDirFilesResponse_DirectoryInfo(nullptr) {}
  ~ListProtocolOutputDirFilesResponse_DirectoryInfo() override;
  explicit constexpr ListProtocolOutputDirFilesResponse_DirectoryInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListProtocolOutputDirFilesResponse_DirectoryInfo(const ListProtocolOutputDirFilesResponse_DirectoryInfo& from);
  ListProtocolOutputDirFilesResponse_DirectoryInfo(ListProtocolOutputDirFilesResponse_DirectoryInfo&& from) noexcept
    : ListProtocolOutputDirFilesResponse_DirectoryInfo() {
    *this = ::std::move(from);
  }

  inline ListProtocolOutputDirFilesResponse_DirectoryInfo& operator=(const ListProtocolOutputDirFilesResponse_DirectoryInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListProtocolOutputDirFilesResponse_DirectoryInfo& operator=(ListProtocolOutputDirFilesResponse_DirectoryInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListProtocolOutputDirFilesResponse_DirectoryInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListProtocolOutputDirFilesResponse_DirectoryInfo* internal_default_instance() {
    return reinterpret_cast<const ListProtocolOutputDirFilesResponse_DirectoryInfo*>(
               &_ListProtocolOutputDirFilesResponse_DirectoryInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ListProtocolOutputDirFilesResponse_DirectoryInfo& a, ListProtocolOutputDirFilesResponse_DirectoryInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ListProtocolOutputDirFilesResponse_DirectoryInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListProtocolOutputDirFilesResponse_DirectoryInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListProtocolOutputDirFilesResponse_DirectoryInfo* New() const final {
    return new ListProtocolOutputDirFilesResponse_DirectoryInfo();
  }

  ListProtocolOutputDirFilesResponse_DirectoryInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListProtocolOutputDirFilesResponse_DirectoryInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListProtocolOutputDirFilesResponse_DirectoryInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListProtocolOutputDirFilesResponse_DirectoryInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListProtocolOutputDirFilesResponse_DirectoryInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.ListProtocolOutputDirFilesResponse.DirectoryInfo";
  }
  protected:
  explicit ListProtocolOutputDirFilesResponse_DirectoryInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDirectoryCountFieldNumber = 2,
    kFileCountFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 directory_count = 2;
  void clear_directory_count();
  ::PROTOBUF_NAMESPACE_ID::int32 directory_count() const;
  void set_directory_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_directory_count() const;
  void _internal_set_directory_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 file_count = 3;
  void clear_file_count();
  ::PROTOBUF_NAMESPACE_ID::int32 file_count() const;
  void set_file_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_file_count() const;
  void _internal_set_file_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.manager.ListProtocolOutputDirFilesResponse.DirectoryInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int32 directory_count_;
  ::PROTOBUF_NAMESPACE_ID::int32 file_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class ListProtocolOutputDirFilesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.ListProtocolOutputDirFilesResponse) */ {
 public:
  inline ListProtocolOutputDirFilesResponse() : ListProtocolOutputDirFilesResponse(nullptr) {}
  ~ListProtocolOutputDirFilesResponse() override;
  explicit constexpr ListProtocolOutputDirFilesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListProtocolOutputDirFilesResponse(const ListProtocolOutputDirFilesResponse& from);
  ListProtocolOutputDirFilesResponse(ListProtocolOutputDirFilesResponse&& from) noexcept
    : ListProtocolOutputDirFilesResponse() {
    *this = ::std::move(from);
  }

  inline ListProtocolOutputDirFilesResponse& operator=(const ListProtocolOutputDirFilesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListProtocolOutputDirFilesResponse& operator=(ListProtocolOutputDirFilesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListProtocolOutputDirFilesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListProtocolOutputDirFilesResponse* internal_default_instance() {
    return reinterpret_cast<const ListProtocolOutputDirFilesResponse*>(
               &_ListProtocolOutputDirFilesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ListProtocolOutputDirFilesResponse& a, ListProtocolOutputDirFilesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListProtocolOutputDirFilesResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListProtocolOutputDirFilesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListProtocolOutputDirFilesResponse* New() const final {
    return new ListProtocolOutputDirFilesResponse();
  }

  ListProtocolOutputDirFilesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListProtocolOutputDirFilesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListProtocolOutputDirFilesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListProtocolOutputDirFilesResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListProtocolOutputDirFilesResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.ListProtocolOutputDirFilesResponse";
  }
  protected:
  explicit ListProtocolOutputDirFilesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ListProtocolOutputDirFilesResponse_DirectoryInfo DirectoryInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kDirectoriesFieldNumber = 1,
    kFilesFieldNumber = 2,
    kCurrentListedPathFieldNumber = 3,
  };
  // repeated .minknow_api.manager.ListProtocolOutputDirFilesResponse.DirectoryInfo directories = 1;
  int directories_size() const;
  private:
  int _internal_directories_size() const;
  public:
  void clear_directories();
  ::minknow_api::manager::ListProtocolOutputDirFilesResponse_DirectoryInfo* mutable_directories(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::ListProtocolOutputDirFilesResponse_DirectoryInfo >*
      mutable_directories();
  private:
  const ::minknow_api::manager::ListProtocolOutputDirFilesResponse_DirectoryInfo& _internal_directories(int index) const;
  ::minknow_api::manager::ListProtocolOutputDirFilesResponse_DirectoryInfo* _internal_add_directories();
  public:
  const ::minknow_api::manager::ListProtocolOutputDirFilesResponse_DirectoryInfo& directories(int index) const;
  ::minknow_api::manager::ListProtocolOutputDirFilesResponse_DirectoryInfo* add_directories();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::ListProtocolOutputDirFilesResponse_DirectoryInfo >&
      directories() const;

  // repeated string files = 2;
  int files_size() const;
  private:
  int _internal_files_size() const;
  public:
  void clear_files();
  const std::string& files(int index) const;
  std::string* mutable_files(int index);
  void set_files(int index, const std::string& value);
  void set_files(int index, std::string&& value);
  void set_files(int index, const char* value);
  void set_files(int index, const char* value, size_t size);
  std::string* add_files();
  void add_files(const std::string& value);
  void add_files(std::string&& value);
  void add_files(const char* value);
  void add_files(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& files() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_files();
  private:
  const std::string& _internal_files(int index) const;
  std::string* _internal_add_files();
  public:

  // string current_listed_path = 3;
  void clear_current_listed_path();
  const std::string& current_listed_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_current_listed_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_current_listed_path();
  PROTOBUF_MUST_USE_RESULT std::string* release_current_listed_path();
  void set_allocated_current_listed_path(std::string* current_listed_path);
  private:
  const std::string& _internal_current_listed_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_current_listed_path(const std::string& value);
  std::string* _internal_mutable_current_listed_path();
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.manager.ListProtocolOutputDirFilesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::ListProtocolOutputDirFilesResponse_DirectoryInfo > directories_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> files_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr current_listed_path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class CreateDirectoryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.CreateDirectoryRequest) */ {
 public:
  inline CreateDirectoryRequest() : CreateDirectoryRequest(nullptr) {}
  ~CreateDirectoryRequest() override;
  explicit constexpr CreateDirectoryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateDirectoryRequest(const CreateDirectoryRequest& from);
  CreateDirectoryRequest(CreateDirectoryRequest&& from) noexcept
    : CreateDirectoryRequest() {
    *this = ::std::move(from);
  }

  inline CreateDirectoryRequest& operator=(const CreateDirectoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateDirectoryRequest& operator=(CreateDirectoryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateDirectoryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateDirectoryRequest* internal_default_instance() {
    return reinterpret_cast<const CreateDirectoryRequest*>(
               &_CreateDirectoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(CreateDirectoryRequest& a, CreateDirectoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateDirectoryRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateDirectoryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateDirectoryRequest* New() const final {
    return new CreateDirectoryRequest();
  }

  CreateDirectoryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateDirectoryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateDirectoryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateDirectoryRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateDirectoryRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.CreateDirectoryRequest";
  }
  protected:
  explicit CreateDirectoryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentPathFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // string parent_path = 1;
  void clear_parent_path();
  const std::string& parent_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent_path();
  PROTOBUF_MUST_USE_RESULT std::string* release_parent_path();
  void set_allocated_parent_path(std::string* parent_path);
  private:
  const std::string& _internal_parent_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_path(const std::string& value);
  std::string* _internal_mutable_parent_path();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.manager.CreateDirectoryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class CreateDirectoryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.CreateDirectoryResponse) */ {
 public:
  inline CreateDirectoryResponse() : CreateDirectoryResponse(nullptr) {}
  ~CreateDirectoryResponse() override;
  explicit constexpr CreateDirectoryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateDirectoryResponse(const CreateDirectoryResponse& from);
  CreateDirectoryResponse(CreateDirectoryResponse&& from) noexcept
    : CreateDirectoryResponse() {
    *this = ::std::move(from);
  }

  inline CreateDirectoryResponse& operator=(const CreateDirectoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateDirectoryResponse& operator=(CreateDirectoryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateDirectoryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateDirectoryResponse* internal_default_instance() {
    return reinterpret_cast<const CreateDirectoryResponse*>(
               &_CreateDirectoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(CreateDirectoryResponse& a, CreateDirectoryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateDirectoryResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateDirectoryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateDirectoryResponse* New() const final {
    return new CreateDirectoryResponse();
  }

  CreateDirectoryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateDirectoryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateDirectoryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateDirectoryResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateDirectoryResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.CreateDirectoryResponse";
  }
  protected:
  explicit CreateDirectoryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
  };
  // string path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_MUST_USE_RESULT std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.manager.CreateDirectoryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class FilesystemDiskSpaceInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.FilesystemDiskSpaceInfo) */ {
 public:
  inline FilesystemDiskSpaceInfo() : FilesystemDiskSpaceInfo(nullptr) {}
  ~FilesystemDiskSpaceInfo() override;
  explicit constexpr FilesystemDiskSpaceInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FilesystemDiskSpaceInfo(const FilesystemDiskSpaceInfo& from);
  FilesystemDiskSpaceInfo(FilesystemDiskSpaceInfo&& from) noexcept
    : FilesystemDiskSpaceInfo() {
    *this = ::std::move(from);
  }

  inline FilesystemDiskSpaceInfo& operator=(const FilesystemDiskSpaceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FilesystemDiskSpaceInfo& operator=(FilesystemDiskSpaceInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FilesystemDiskSpaceInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const FilesystemDiskSpaceInfo* internal_default_instance() {
    return reinterpret_cast<const FilesystemDiskSpaceInfo*>(
               &_FilesystemDiskSpaceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(FilesystemDiskSpaceInfo& a, FilesystemDiskSpaceInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(FilesystemDiskSpaceInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FilesystemDiskSpaceInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FilesystemDiskSpaceInfo* New() const final {
    return new FilesystemDiskSpaceInfo();
  }

  FilesystemDiskSpaceInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FilesystemDiskSpaceInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FilesystemDiskSpaceInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FilesystemDiskSpaceInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FilesystemDiskSpaceInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.FilesystemDiskSpaceInfo";
  }
  protected:
  explicit FilesystemDiskSpaceInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileTypesStoredFieldNumber = 4,
    kFilesystemIdFieldNumber = 1,
    kBytesAvailableFieldNumber = 2,
    kBytesCapacityFieldNumber = 3,
    kBytesToStopCleanlyFieldNumber = 5,
    kBytesWhenAlertIssuedFieldNumber = 6,
    kBytesPerSecondFieldNumber = 9,
    kRecommendAlertFieldNumber = 7,
    kRecommendStopFieldNumber = 8,
  };
  // repeated string file_types_stored = 4;
  int file_types_stored_size() const;
  private:
  int _internal_file_types_stored_size() const;
  public:
  void clear_file_types_stored();
  const std::string& file_types_stored(int index) const;
  std::string* mutable_file_types_stored(int index);
  void set_file_types_stored(int index, const std::string& value);
  void set_file_types_stored(int index, std::string&& value);
  void set_file_types_stored(int index, const char* value);
  void set_file_types_stored(int index, const char* value, size_t size);
  std::string* add_file_types_stored();
  void add_file_types_stored(const std::string& value);
  void add_file_types_stored(std::string&& value);
  void add_file_types_stored(const char* value);
  void add_file_types_stored(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& file_types_stored() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_file_types_stored();
  private:
  const std::string& _internal_file_types_stored(int index) const;
  std::string* _internal_add_file_types_stored();
  public:

  // string filesystem_id = 1;
  void clear_filesystem_id();
  const std::string& filesystem_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filesystem_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filesystem_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_filesystem_id();
  void set_allocated_filesystem_id(std::string* filesystem_id);
  private:
  const std::string& _internal_filesystem_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filesystem_id(const std::string& value);
  std::string* _internal_mutable_filesystem_id();
  public:

  // uint64 bytes_available = 2;
  void clear_bytes_available();
  ::PROTOBUF_NAMESPACE_ID::uint64 bytes_available() const;
  void set_bytes_available(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_bytes_available() const;
  void _internal_set_bytes_available(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 bytes_capacity = 3;
  void clear_bytes_capacity();
  ::PROTOBUF_NAMESPACE_ID::uint64 bytes_capacity() const;
  void set_bytes_capacity(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_bytes_capacity() const;
  void _internal_set_bytes_capacity(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 bytes_to_stop_cleanly = 5;
  void clear_bytes_to_stop_cleanly();
  ::PROTOBUF_NAMESPACE_ID::uint64 bytes_to_stop_cleanly() const;
  void set_bytes_to_stop_cleanly(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_bytes_to_stop_cleanly() const;
  void _internal_set_bytes_to_stop_cleanly(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 bytes_when_alert_issued = 6;
  void clear_bytes_when_alert_issued();
  ::PROTOBUF_NAMESPACE_ID::uint64 bytes_when_alert_issued() const;
  void set_bytes_when_alert_issued(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_bytes_when_alert_issued() const;
  void _internal_set_bytes_when_alert_issued(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // int64 bytes_per_second = 9;
  void clear_bytes_per_second();
  ::PROTOBUF_NAMESPACE_ID::int64 bytes_per_second() const;
  void set_bytes_per_second(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_bytes_per_second() const;
  void _internal_set_bytes_per_second(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // bool recommend_alert = 7;
  void clear_recommend_alert();
  bool recommend_alert() const;
  void set_recommend_alert(bool value);
  private:
  bool _internal_recommend_alert() const;
  void _internal_set_recommend_alert(bool value);
  public:

  // bool recommend_stop = 8;
  void clear_recommend_stop();
  bool recommend_stop() const;
  void set_recommend_stop(bool value);
  private:
  bool _internal_recommend_stop() const;
  void _internal_set_recommend_stop(bool value);
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.manager.FilesystemDiskSpaceInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> file_types_stored_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filesystem_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 bytes_available_;
  ::PROTOBUF_NAMESPACE_ID::uint64 bytes_capacity_;
  ::PROTOBUF_NAMESPACE_ID::uint64 bytes_to_stop_cleanly_;
  ::PROTOBUF_NAMESPACE_ID::uint64 bytes_when_alert_issued_;
  ::PROTOBUF_NAMESPACE_ID::int64 bytes_per_second_;
  bool recommend_alert_;
  bool recommend_stop_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class GetDiskSpaceInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:minknow_api.manager.GetDiskSpaceInfoRequest) */ {
 public:
  inline GetDiskSpaceInfoRequest() : GetDiskSpaceInfoRequest(nullptr) {}
  explicit constexpr GetDiskSpaceInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetDiskSpaceInfoRequest(const GetDiskSpaceInfoRequest& from);
  GetDiskSpaceInfoRequest(GetDiskSpaceInfoRequest&& from) noexcept
    : GetDiskSpaceInfoRequest() {
    *this = ::std::move(from);
  }

  inline GetDiskSpaceInfoRequest& operator=(const GetDiskSpaceInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDiskSpaceInfoRequest& operator=(GetDiskSpaceInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDiskSpaceInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDiskSpaceInfoRequest* internal_default_instance() {
    return reinterpret_cast<const GetDiskSpaceInfoRequest*>(
               &_GetDiskSpaceInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(GetDiskSpaceInfoRequest& a, GetDiskSpaceInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDiskSpaceInfoRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDiskSpaceInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetDiskSpaceInfoRequest* New() const final {
    return new GetDiskSpaceInfoRequest();
  }

  GetDiskSpaceInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetDiskSpaceInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetDiskSpaceInfoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetDiskSpaceInfoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.GetDiskSpaceInfoRequest";
  }
  protected:
  explicit GetDiskSpaceInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:minknow_api.manager.GetDiskSpaceInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class StreamDiskSpaceInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.StreamDiskSpaceInfoRequest) */ {
 public:
  inline StreamDiskSpaceInfoRequest() : StreamDiskSpaceInfoRequest(nullptr) {}
  ~StreamDiskSpaceInfoRequest() override;
  explicit constexpr StreamDiskSpaceInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamDiskSpaceInfoRequest(const StreamDiskSpaceInfoRequest& from);
  StreamDiskSpaceInfoRequest(StreamDiskSpaceInfoRequest&& from) noexcept
    : StreamDiskSpaceInfoRequest() {
    *this = ::std::move(from);
  }

  inline StreamDiskSpaceInfoRequest& operator=(const StreamDiskSpaceInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamDiskSpaceInfoRequest& operator=(StreamDiskSpaceInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamDiskSpaceInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamDiskSpaceInfoRequest* internal_default_instance() {
    return reinterpret_cast<const StreamDiskSpaceInfoRequest*>(
               &_StreamDiskSpaceInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(StreamDiskSpaceInfoRequest& a, StreamDiskSpaceInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamDiskSpaceInfoRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamDiskSpaceInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StreamDiskSpaceInfoRequest* New() const final {
    return new StreamDiskSpaceInfoRequest();
  }

  StreamDiskSpaceInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StreamDiskSpaceInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamDiskSpaceInfoRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StreamDiskSpaceInfoRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamDiskSpaceInfoRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.StreamDiskSpaceInfoRequest";
  }
  protected:
  explicit StreamDiskSpaceInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeriodFieldNumber = 1,
  };
  // uint32 period = 1;
  void clear_period();
  ::PROTOBUF_NAMESPACE_ID::uint32 period() const;
  void set_period(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_period() const;
  void _internal_set_period(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.manager.StreamDiskSpaceInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 period_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class GetDiskSpaceInfoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.GetDiskSpaceInfoResponse) */ {
 public:
  inline GetDiskSpaceInfoResponse() : GetDiskSpaceInfoResponse(nullptr) {}
  ~GetDiskSpaceInfoResponse() override;
  explicit constexpr GetDiskSpaceInfoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetDiskSpaceInfoResponse(const GetDiskSpaceInfoResponse& from);
  GetDiskSpaceInfoResponse(GetDiskSpaceInfoResponse&& from) noexcept
    : GetDiskSpaceInfoResponse() {
    *this = ::std::move(from);
  }

  inline GetDiskSpaceInfoResponse& operator=(const GetDiskSpaceInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDiskSpaceInfoResponse& operator=(GetDiskSpaceInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDiskSpaceInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDiskSpaceInfoResponse* internal_default_instance() {
    return reinterpret_cast<const GetDiskSpaceInfoResponse*>(
               &_GetDiskSpaceInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(GetDiskSpaceInfoResponse& a, GetDiskSpaceInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDiskSpaceInfoResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDiskSpaceInfoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetDiskSpaceInfoResponse* New() const final {
    return new GetDiskSpaceInfoResponse();
  }

  GetDiskSpaceInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetDiskSpaceInfoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetDiskSpaceInfoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetDiskSpaceInfoResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDiskSpaceInfoResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.GetDiskSpaceInfoResponse";
  }
  protected:
  explicit GetDiskSpaceInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilesystemDiskSpaceInfoFieldNumber = 1,
  };
  // repeated .minknow_api.manager.FilesystemDiskSpaceInfo filesystem_disk_space_info = 1;
  int filesystem_disk_space_info_size() const;
  private:
  int _internal_filesystem_disk_space_info_size() const;
  public:
  void clear_filesystem_disk_space_info();
  ::minknow_api::manager::FilesystemDiskSpaceInfo* mutable_filesystem_disk_space_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::FilesystemDiskSpaceInfo >*
      mutable_filesystem_disk_space_info();
  private:
  const ::minknow_api::manager::FilesystemDiskSpaceInfo& _internal_filesystem_disk_space_info(int index) const;
  ::minknow_api::manager::FilesystemDiskSpaceInfo* _internal_add_filesystem_disk_space_info();
  public:
  const ::minknow_api::manager::FilesystemDiskSpaceInfo& filesystem_disk_space_info(int index) const;
  ::minknow_api::manager::FilesystemDiskSpaceInfo* add_filesystem_disk_space_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::FilesystemDiskSpaceInfo >&
      filesystem_disk_space_info() const;

  // @@protoc_insertion_point(class_scope:minknow_api.manager.GetDiskSpaceInfoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::FilesystemDiskSpaceInfo > filesystem_disk_space_info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class GetBarcodeKitInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:minknow_api.manager.GetBarcodeKitInfoRequest) */ {
 public:
  inline GetBarcodeKitInfoRequest() : GetBarcodeKitInfoRequest(nullptr) {}
  explicit constexpr GetBarcodeKitInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBarcodeKitInfoRequest(const GetBarcodeKitInfoRequest& from);
  GetBarcodeKitInfoRequest(GetBarcodeKitInfoRequest&& from) noexcept
    : GetBarcodeKitInfoRequest() {
    *this = ::std::move(from);
  }

  inline GetBarcodeKitInfoRequest& operator=(const GetBarcodeKitInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBarcodeKitInfoRequest& operator=(GetBarcodeKitInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBarcodeKitInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBarcodeKitInfoRequest* internal_default_instance() {
    return reinterpret_cast<const GetBarcodeKitInfoRequest*>(
               &_GetBarcodeKitInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(GetBarcodeKitInfoRequest& a, GetBarcodeKitInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBarcodeKitInfoRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBarcodeKitInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetBarcodeKitInfoRequest* New() const final {
    return new GetBarcodeKitInfoRequest();
  }

  GetBarcodeKitInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetBarcodeKitInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetBarcodeKitInfoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetBarcodeKitInfoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.GetBarcodeKitInfoRequest";
  }
  protected:
  explicit GetBarcodeKitInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:minknow_api.manager.GetBarcodeKitInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class GetBarcodeKitInfoResponse_BarcodeKitInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.GetBarcodeKitInfoResponse.BarcodeKitInfo) */ {
 public:
  inline GetBarcodeKitInfoResponse_BarcodeKitInfo() : GetBarcodeKitInfoResponse_BarcodeKitInfo(nullptr) {}
  ~GetBarcodeKitInfoResponse_BarcodeKitInfo() override;
  explicit constexpr GetBarcodeKitInfoResponse_BarcodeKitInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBarcodeKitInfoResponse_BarcodeKitInfo(const GetBarcodeKitInfoResponse_BarcodeKitInfo& from);
  GetBarcodeKitInfoResponse_BarcodeKitInfo(GetBarcodeKitInfoResponse_BarcodeKitInfo&& from) noexcept
    : GetBarcodeKitInfoResponse_BarcodeKitInfo() {
    *this = ::std::move(from);
  }

  inline GetBarcodeKitInfoResponse_BarcodeKitInfo& operator=(const GetBarcodeKitInfoResponse_BarcodeKitInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBarcodeKitInfoResponse_BarcodeKitInfo& operator=(GetBarcodeKitInfoResponse_BarcodeKitInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBarcodeKitInfoResponse_BarcodeKitInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBarcodeKitInfoResponse_BarcodeKitInfo* internal_default_instance() {
    return reinterpret_cast<const GetBarcodeKitInfoResponse_BarcodeKitInfo*>(
               &_GetBarcodeKitInfoResponse_BarcodeKitInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(GetBarcodeKitInfoResponse_BarcodeKitInfo& a, GetBarcodeKitInfoResponse_BarcodeKitInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBarcodeKitInfoResponse_BarcodeKitInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBarcodeKitInfoResponse_BarcodeKitInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetBarcodeKitInfoResponse_BarcodeKitInfo* New() const final {
    return new GetBarcodeKitInfoResponse_BarcodeKitInfo();
  }

  GetBarcodeKitInfoResponse_BarcodeKitInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetBarcodeKitInfoResponse_BarcodeKitInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBarcodeKitInfoResponse_BarcodeKitInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetBarcodeKitInfoResponse_BarcodeKitInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBarcodeKitInfoResponse_BarcodeKitInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.GetBarcodeKitInfoResponse.BarcodeKitInfo";
  }
  protected:
  explicit GetBarcodeKitInfoResponse_BarcodeKitInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsDualFieldNumber = 2,
    kIsBothEndsFieldNumber = 3,
  };
  // bool is_dual = 2;
  void clear_is_dual();
  bool is_dual() const;
  void set_is_dual(bool value);
  private:
  bool _internal_is_dual() const;
  void _internal_set_is_dual(bool value);
  public:

  // bool is_both_ends = 3;
  void clear_is_both_ends();
  bool is_both_ends() const;
  void set_is_both_ends(bool value);
  private:
  bool _internal_is_both_ends() const;
  void _internal_set_is_both_ends(bool value);
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.manager.GetBarcodeKitInfoResponse.BarcodeKitInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool is_dual_;
  bool is_both_ends_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class GetBarcodeKitInfoResponse_BarcodeKitInfoEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetBarcodeKitInfoResponse_BarcodeKitInfoEntry_DoNotUse, 
    std::string, ::minknow_api::manager::GetBarcodeKitInfoResponse_BarcodeKitInfo,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetBarcodeKitInfoResponse_BarcodeKitInfoEntry_DoNotUse, 
    std::string, ::minknow_api::manager::GetBarcodeKitInfoResponse_BarcodeKitInfo,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  GetBarcodeKitInfoResponse_BarcodeKitInfoEntry_DoNotUse();
  explicit constexpr GetBarcodeKitInfoResponse_BarcodeKitInfoEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit GetBarcodeKitInfoResponse_BarcodeKitInfoEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetBarcodeKitInfoResponse_BarcodeKitInfoEntry_DoNotUse& other);
  static const GetBarcodeKitInfoResponse_BarcodeKitInfoEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetBarcodeKitInfoResponse_BarcodeKitInfoEntry_DoNotUse*>(&_GetBarcodeKitInfoResponse_BarcodeKitInfoEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "minknow_api.manager.GetBarcodeKitInfoResponse.BarcodeKitInfoEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class GetBarcodeKitInfoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.GetBarcodeKitInfoResponse) */ {
 public:
  inline GetBarcodeKitInfoResponse() : GetBarcodeKitInfoResponse(nullptr) {}
  ~GetBarcodeKitInfoResponse() override;
  explicit constexpr GetBarcodeKitInfoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBarcodeKitInfoResponse(const GetBarcodeKitInfoResponse& from);
  GetBarcodeKitInfoResponse(GetBarcodeKitInfoResponse&& from) noexcept
    : GetBarcodeKitInfoResponse() {
    *this = ::std::move(from);
  }

  inline GetBarcodeKitInfoResponse& operator=(const GetBarcodeKitInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBarcodeKitInfoResponse& operator=(GetBarcodeKitInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBarcodeKitInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBarcodeKitInfoResponse* internal_default_instance() {
    return reinterpret_cast<const GetBarcodeKitInfoResponse*>(
               &_GetBarcodeKitInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(GetBarcodeKitInfoResponse& a, GetBarcodeKitInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBarcodeKitInfoResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBarcodeKitInfoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetBarcodeKitInfoResponse* New() const final {
    return new GetBarcodeKitInfoResponse();
  }

  GetBarcodeKitInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetBarcodeKitInfoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBarcodeKitInfoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetBarcodeKitInfoResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBarcodeKitInfoResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.GetBarcodeKitInfoResponse";
  }
  protected:
  explicit GetBarcodeKitInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GetBarcodeKitInfoResponse_BarcodeKitInfo BarcodeKitInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kBarcodeKitInfoFieldNumber = 1,
  };
  // map<string, .minknow_api.manager.GetBarcodeKitInfoResponse.BarcodeKitInfo> barcode_kit_info = 1;
  int barcode_kit_info_size() const;
  private:
  int _internal_barcode_kit_info_size() const;
  public:
  void clear_barcode_kit_info();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::minknow_api::manager::GetBarcodeKitInfoResponse_BarcodeKitInfo >&
      _internal_barcode_kit_info() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::minknow_api::manager::GetBarcodeKitInfoResponse_BarcodeKitInfo >*
      _internal_mutable_barcode_kit_info();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::minknow_api::manager::GetBarcodeKitInfoResponse_BarcodeKitInfo >&
      barcode_kit_info() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::minknow_api::manager::GetBarcodeKitInfoResponse_BarcodeKitInfo >*
      mutable_barcode_kit_info();

  // @@protoc_insertion_point(class_scope:minknow_api.manager.GetBarcodeKitInfoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      GetBarcodeKitInfoResponse_BarcodeKitInfoEntry_DoNotUse,
      std::string, ::minknow_api::manager::GetBarcodeKitInfoResponse_BarcodeKitInfo,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> barcode_kit_info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class GetLampKitInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:minknow_api.manager.GetLampKitInfoRequest) */ {
 public:
  inline GetLampKitInfoRequest() : GetLampKitInfoRequest(nullptr) {}
  explicit constexpr GetLampKitInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLampKitInfoRequest(const GetLampKitInfoRequest& from);
  GetLampKitInfoRequest(GetLampKitInfoRequest&& from) noexcept
    : GetLampKitInfoRequest() {
    *this = ::std::move(from);
  }

  inline GetLampKitInfoRequest& operator=(const GetLampKitInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLampKitInfoRequest& operator=(GetLampKitInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLampKitInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLampKitInfoRequest* internal_default_instance() {
    return reinterpret_cast<const GetLampKitInfoRequest*>(
               &_GetLampKitInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(GetLampKitInfoRequest& a, GetLampKitInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLampKitInfoRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLampKitInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetLampKitInfoRequest* New() const final {
    return new GetLampKitInfoRequest();
  }

  GetLampKitInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetLampKitInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetLampKitInfoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetLampKitInfoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.GetLampKitInfoRequest";
  }
  protected:
  explicit GetLampKitInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:minknow_api.manager.GetLampKitInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class GetLampKitInfoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.GetLampKitInfoResponse) */ {
 public:
  inline GetLampKitInfoResponse() : GetLampKitInfoResponse(nullptr) {}
  ~GetLampKitInfoResponse() override;
  explicit constexpr GetLampKitInfoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLampKitInfoResponse(const GetLampKitInfoResponse& from);
  GetLampKitInfoResponse(GetLampKitInfoResponse&& from) noexcept
    : GetLampKitInfoResponse() {
    *this = ::std::move(from);
  }

  inline GetLampKitInfoResponse& operator=(const GetLampKitInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLampKitInfoResponse& operator=(GetLampKitInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLampKitInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLampKitInfoResponse* internal_default_instance() {
    return reinterpret_cast<const GetLampKitInfoResponse*>(
               &_GetLampKitInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(GetLampKitInfoResponse& a, GetLampKitInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLampKitInfoResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLampKitInfoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetLampKitInfoResponse* New() const final {
    return new GetLampKitInfoResponse();
  }

  GetLampKitInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetLampKitInfoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetLampKitInfoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetLampKitInfoResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLampKitInfoResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.GetLampKitInfoResponse";
  }
  protected:
  explicit GetLampKitInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLampKitsFieldNumber = 2,
  };
  // repeated string lamp_kits = 2;
  int lamp_kits_size() const;
  private:
  int _internal_lamp_kits_size() const;
  public:
  void clear_lamp_kits();
  const std::string& lamp_kits(int index) const;
  std::string* mutable_lamp_kits(int index);
  void set_lamp_kits(int index, const std::string& value);
  void set_lamp_kits(int index, std::string&& value);
  void set_lamp_kits(int index, const char* value);
  void set_lamp_kits(int index, const char* value, size_t size);
  std::string* add_lamp_kits();
  void add_lamp_kits(const std::string& value);
  void add_lamp_kits(std::string&& value);
  void add_lamp_kits(const char* value);
  void add_lamp_kits(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& lamp_kits() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_lamp_kits();
  private:
  const std::string& _internal_lamp_kits(int index) const;
  std::string* _internal_add_lamp_kits();
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.manager.GetLampKitInfoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> lamp_kits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class GetBarcodeKeysRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.GetBarcodeKeysRequest) */ {
 public:
  inline GetBarcodeKeysRequest() : GetBarcodeKeysRequest(nullptr) {}
  ~GetBarcodeKeysRequest() override;
  explicit constexpr GetBarcodeKeysRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBarcodeKeysRequest(const GetBarcodeKeysRequest& from);
  GetBarcodeKeysRequest(GetBarcodeKeysRequest&& from) noexcept
    : GetBarcodeKeysRequest() {
    *this = ::std::move(from);
  }

  inline GetBarcodeKeysRequest& operator=(const GetBarcodeKeysRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBarcodeKeysRequest& operator=(GetBarcodeKeysRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBarcodeKeysRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBarcodeKeysRequest* internal_default_instance() {
    return reinterpret_cast<const GetBarcodeKeysRequest*>(
               &_GetBarcodeKeysRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(GetBarcodeKeysRequest& a, GetBarcodeKeysRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBarcodeKeysRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBarcodeKeysRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetBarcodeKeysRequest* New() const final {
    return new GetBarcodeKeysRequest();
  }

  GetBarcodeKeysRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetBarcodeKeysRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBarcodeKeysRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetBarcodeKeysRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBarcodeKeysRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.GetBarcodeKeysRequest";
  }
  protected:
  explicit GetBarcodeKeysRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBarcodeKitNamesFieldNumber = 1,
    kLampKitNameFieldNumber = 2,
  };
  // repeated string barcode_kit_names = 1;
  int barcode_kit_names_size() const;
  private:
  int _internal_barcode_kit_names_size() const;
  public:
  void clear_barcode_kit_names();
  const std::string& barcode_kit_names(int index) const;
  std::string* mutable_barcode_kit_names(int index);
  void set_barcode_kit_names(int index, const std::string& value);
  void set_barcode_kit_names(int index, std::string&& value);
  void set_barcode_kit_names(int index, const char* value);
  void set_barcode_kit_names(int index, const char* value, size_t size);
  std::string* add_barcode_kit_names();
  void add_barcode_kit_names(const std::string& value);
  void add_barcode_kit_names(std::string&& value);
  void add_barcode_kit_names(const char* value);
  void add_barcode_kit_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& barcode_kit_names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_barcode_kit_names();
  private:
  const std::string& _internal_barcode_kit_names(int index) const;
  std::string* _internal_add_barcode_kit_names();
  public:

  // string lamp_kit_name = 2;
  void clear_lamp_kit_name();
  const std::string& lamp_kit_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lamp_kit_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lamp_kit_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_lamp_kit_name();
  void set_allocated_lamp_kit_name(std::string* lamp_kit_name);
  private:
  const std::string& _internal_lamp_kit_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lamp_kit_name(const std::string& value);
  std::string* _internal_mutable_lamp_kit_name();
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.manager.GetBarcodeKeysRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> barcode_kit_names_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lamp_kit_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class GetBarcodeKeysResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.GetBarcodeKeysResponse) */ {
 public:
  inline GetBarcodeKeysResponse() : GetBarcodeKeysResponse(nullptr) {}
  ~GetBarcodeKeysResponse() override;
  explicit constexpr GetBarcodeKeysResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBarcodeKeysResponse(const GetBarcodeKeysResponse& from);
  GetBarcodeKeysResponse(GetBarcodeKeysResponse&& from) noexcept
    : GetBarcodeKeysResponse() {
    *this = ::std::move(from);
  }

  inline GetBarcodeKeysResponse& operator=(const GetBarcodeKeysResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBarcodeKeysResponse& operator=(GetBarcodeKeysResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBarcodeKeysResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBarcodeKeysResponse* internal_default_instance() {
    return reinterpret_cast<const GetBarcodeKeysResponse*>(
               &_GetBarcodeKeysResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(GetBarcodeKeysResponse& a, GetBarcodeKeysResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBarcodeKeysResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBarcodeKeysResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetBarcodeKeysResponse* New() const final {
    return new GetBarcodeKeysResponse();
  }

  GetBarcodeKeysResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetBarcodeKeysResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBarcodeKeysResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetBarcodeKeysResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBarcodeKeysResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.GetBarcodeKeysResponse";
  }
  protected:
  explicit GetBarcodeKeysResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBarcodeKeysFieldNumber = 1,
    kLampKeysFieldNumber = 2,
    kCombinedKeysFieldNumber = 3,
  };
  // repeated string barcode_keys = 1;
  int barcode_keys_size() const;
  private:
  int _internal_barcode_keys_size() const;
  public:
  void clear_barcode_keys();
  const std::string& barcode_keys(int index) const;
  std::string* mutable_barcode_keys(int index);
  void set_barcode_keys(int index, const std::string& value);
  void set_barcode_keys(int index, std::string&& value);
  void set_barcode_keys(int index, const char* value);
  void set_barcode_keys(int index, const char* value, size_t size);
  std::string* add_barcode_keys();
  void add_barcode_keys(const std::string& value);
  void add_barcode_keys(std::string&& value);
  void add_barcode_keys(const char* value);
  void add_barcode_keys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& barcode_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_barcode_keys();
  private:
  const std::string& _internal_barcode_keys(int index) const;
  std::string* _internal_add_barcode_keys();
  public:

  // repeated string lamp_keys = 2;
  int lamp_keys_size() const;
  private:
  int _internal_lamp_keys_size() const;
  public:
  void clear_lamp_keys();
  const std::string& lamp_keys(int index) const;
  std::string* mutable_lamp_keys(int index);
  void set_lamp_keys(int index, const std::string& value);
  void set_lamp_keys(int index, std::string&& value);
  void set_lamp_keys(int index, const char* value);
  void set_lamp_keys(int index, const char* value, size_t size);
  std::string* add_lamp_keys();
  void add_lamp_keys(const std::string& value);
  void add_lamp_keys(std::string&& value);
  void add_lamp_keys(const char* value);
  void add_lamp_keys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& lamp_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_lamp_keys();
  private:
  const std::string& _internal_lamp_keys(int index) const;
  std::string* _internal_add_lamp_keys();
  public:

  // repeated string combined_keys = 3;
  int combined_keys_size() const;
  private:
  int _internal_combined_keys_size() const;
  public:
  void clear_combined_keys();
  const std::string& combined_keys(int index) const;
  std::string* mutable_combined_keys(int index);
  void set_combined_keys(int index, const std::string& value);
  void set_combined_keys(int index, std::string&& value);
  void set_combined_keys(int index, const char* value);
  void set_combined_keys(int index, const char* value, size_t size);
  std::string* add_combined_keys();
  void add_combined_keys(const std::string& value);
  void add_combined_keys(std::string&& value);
  void add_combined_keys(const char* value);
  void add_combined_keys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& combined_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_combined_keys();
  private:
  const std::string& _internal_combined_keys(int index) const;
  std::string* _internal_add_combined_keys();
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.manager.GetBarcodeKeysResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> barcode_keys_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> lamp_keys_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> combined_keys_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class GetFlowCellTypesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:minknow_api.manager.GetFlowCellTypesRequest) */ {
 public:
  inline GetFlowCellTypesRequest() : GetFlowCellTypesRequest(nullptr) {}
  explicit constexpr GetFlowCellTypesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFlowCellTypesRequest(const GetFlowCellTypesRequest& from);
  GetFlowCellTypesRequest(GetFlowCellTypesRequest&& from) noexcept
    : GetFlowCellTypesRequest() {
    *this = ::std::move(from);
  }

  inline GetFlowCellTypesRequest& operator=(const GetFlowCellTypesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFlowCellTypesRequest& operator=(GetFlowCellTypesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFlowCellTypesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFlowCellTypesRequest* internal_default_instance() {
    return reinterpret_cast<const GetFlowCellTypesRequest*>(
               &_GetFlowCellTypesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(GetFlowCellTypesRequest& a, GetFlowCellTypesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFlowCellTypesRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFlowCellTypesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetFlowCellTypesRequest* New() const final {
    return new GetFlowCellTypesRequest();
  }

  GetFlowCellTypesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetFlowCellTypesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetFlowCellTypesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetFlowCellTypesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.GetFlowCellTypesRequest";
  }
  protected:
  explicit GetFlowCellTypesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:minknow_api.manager.GetFlowCellTypesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class GetFlowCellTypesResponse_Info final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.GetFlowCellTypesResponse.Info) */ {
 public:
  inline GetFlowCellTypesResponse_Info() : GetFlowCellTypesResponse_Info(nullptr) {}
  ~GetFlowCellTypesResponse_Info() override;
  explicit constexpr GetFlowCellTypesResponse_Info(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFlowCellTypesResponse_Info(const GetFlowCellTypesResponse_Info& from);
  GetFlowCellTypesResponse_Info(GetFlowCellTypesResponse_Info&& from) noexcept
    : GetFlowCellTypesResponse_Info() {
    *this = ::std::move(from);
  }

  inline GetFlowCellTypesResponse_Info& operator=(const GetFlowCellTypesResponse_Info& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFlowCellTypesResponse_Info& operator=(GetFlowCellTypesResponse_Info&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFlowCellTypesResponse_Info& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFlowCellTypesResponse_Info* internal_default_instance() {
    return reinterpret_cast<const GetFlowCellTypesResponse_Info*>(
               &_GetFlowCellTypesResponse_Info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(GetFlowCellTypesResponse_Info& a, GetFlowCellTypesResponse_Info& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFlowCellTypesResponse_Info* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFlowCellTypesResponse_Info* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetFlowCellTypesResponse_Info* New() const final {
    return new GetFlowCellTypesResponse_Info();
  }

  GetFlowCellTypesResponse_Info* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetFlowCellTypesResponse_Info>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFlowCellTypesResponse_Info& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetFlowCellTypesResponse_Info& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFlowCellTypesResponse_Info* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.GetFlowCellTypesResponse.Info";
  }
  protected:
  explicit GetFlowCellTypesResponse_Info(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProductCodeFieldNumber = 1,
    kConnectorTypeFieldNumber = 2,
    kCannotLiveBasecallFieldNumber = 3,
  };
  // string product_code = 1;
  void clear_product_code();
  const std::string& product_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_product_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_product_code();
  PROTOBUF_MUST_USE_RESULT std::string* release_product_code();
  void set_allocated_product_code(std::string* product_code);
  private:
  const std::string& _internal_product_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_product_code(const std::string& value);
  std::string* _internal_mutable_product_code();
  public:

  // .minknow_api.device.FlowCellConnectorType connector_type = 2;
  void clear_connector_type();
  ::minknow_api::device::FlowCellConnectorType connector_type() const;
  void set_connector_type(::minknow_api::device::FlowCellConnectorType value);
  private:
  ::minknow_api::device::FlowCellConnectorType _internal_connector_type() const;
  void _internal_set_connector_type(::minknow_api::device::FlowCellConnectorType value);
  public:

  // bool cannot_live_basecall = 3;
  void clear_cannot_live_basecall();
  bool cannot_live_basecall() const;
  void set_cannot_live_basecall(bool value);
  private:
  bool _internal_cannot_live_basecall() const;
  void _internal_set_cannot_live_basecall(bool value);
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.manager.GetFlowCellTypesResponse.Info)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr product_code_;
  int connector_type_;
  bool cannot_live_basecall_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class GetFlowCellTypesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.GetFlowCellTypesResponse) */ {
 public:
  inline GetFlowCellTypesResponse() : GetFlowCellTypesResponse(nullptr) {}
  ~GetFlowCellTypesResponse() override;
  explicit constexpr GetFlowCellTypesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFlowCellTypesResponse(const GetFlowCellTypesResponse& from);
  GetFlowCellTypesResponse(GetFlowCellTypesResponse&& from) noexcept
    : GetFlowCellTypesResponse() {
    *this = ::std::move(from);
  }

  inline GetFlowCellTypesResponse& operator=(const GetFlowCellTypesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFlowCellTypesResponse& operator=(GetFlowCellTypesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFlowCellTypesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFlowCellTypesResponse* internal_default_instance() {
    return reinterpret_cast<const GetFlowCellTypesResponse*>(
               &_GetFlowCellTypesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(GetFlowCellTypesResponse& a, GetFlowCellTypesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFlowCellTypesResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFlowCellTypesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetFlowCellTypesResponse* New() const final {
    return new GetFlowCellTypesResponse();
  }

  GetFlowCellTypesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetFlowCellTypesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFlowCellTypesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetFlowCellTypesResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFlowCellTypesResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.GetFlowCellTypesResponse";
  }
  protected:
  explicit GetFlowCellTypesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GetFlowCellTypesResponse_Info Info;

  // accessors -------------------------------------------------------

  enum : int {
    kTypesFieldNumber = 1,
  };
  // repeated .minknow_api.manager.GetFlowCellTypesResponse.Info types = 1;
  int types_size() const;
  private:
  int _internal_types_size() const;
  public:
  void clear_types();
  ::minknow_api::manager::GetFlowCellTypesResponse_Info* mutable_types(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::GetFlowCellTypesResponse_Info >*
      mutable_types();
  private:
  const ::minknow_api::manager::GetFlowCellTypesResponse_Info& _internal_types(int index) const;
  ::minknow_api::manager::GetFlowCellTypesResponse_Info* _internal_add_types();
  public:
  const ::minknow_api::manager::GetFlowCellTypesResponse_Info& types(int index) const;
  ::minknow_api::manager::GetFlowCellTypesResponse_Info* add_types();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::GetFlowCellTypesResponse_Info >&
      types() const;

  // @@protoc_insertion_point(class_scope:minknow_api.manager.GetFlowCellTypesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::GetFlowCellTypesResponse_Info > types_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class GetSequencingKitsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.GetSequencingKitsRequest) */ {
 public:
  inline GetSequencingKitsRequest() : GetSequencingKitsRequest(nullptr) {}
  ~GetSequencingKitsRequest() override;
  explicit constexpr GetSequencingKitsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSequencingKitsRequest(const GetSequencingKitsRequest& from);
  GetSequencingKitsRequest(GetSequencingKitsRequest&& from) noexcept
    : GetSequencingKitsRequest() {
    *this = ::std::move(from);
  }

  inline GetSequencingKitsRequest& operator=(const GetSequencingKitsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSequencingKitsRequest& operator=(GetSequencingKitsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSequencingKitsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSequencingKitsRequest* internal_default_instance() {
    return reinterpret_cast<const GetSequencingKitsRequest*>(
               &_GetSequencingKitsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(GetSequencingKitsRequest& a, GetSequencingKitsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSequencingKitsRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSequencingKitsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetSequencingKitsRequest* New() const final {
    return new GetSequencingKitsRequest();
  }

  GetSequencingKitsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetSequencingKitsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSequencingKitsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetSequencingKitsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSequencingKitsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.GetSequencingKitsRequest";
  }
  protected:
  explicit GetSequencingKitsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlowCellProductCodeFieldNumber = 1,
  };
  // string flow_cell_product_code = 1;
  void clear_flow_cell_product_code();
  const std::string& flow_cell_product_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_flow_cell_product_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_flow_cell_product_code();
  PROTOBUF_MUST_USE_RESULT std::string* release_flow_cell_product_code();
  void set_allocated_flow_cell_product_code(std::string* flow_cell_product_code);
  private:
  const std::string& _internal_flow_cell_product_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_flow_cell_product_code(const std::string& value);
  std::string* _internal_mutable_flow_cell_product_code();
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.manager.GetSequencingKitsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr flow_cell_product_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class GetSequencingKitsResponse_Kit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.GetSequencingKitsResponse.Kit) */ {
 public:
  inline GetSequencingKitsResponse_Kit() : GetSequencingKitsResponse_Kit(nullptr) {}
  ~GetSequencingKitsResponse_Kit() override;
  explicit constexpr GetSequencingKitsResponse_Kit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSequencingKitsResponse_Kit(const GetSequencingKitsResponse_Kit& from);
  GetSequencingKitsResponse_Kit(GetSequencingKitsResponse_Kit&& from) noexcept
    : GetSequencingKitsResponse_Kit() {
    *this = ::std::move(from);
  }

  inline GetSequencingKitsResponse_Kit& operator=(const GetSequencingKitsResponse_Kit& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSequencingKitsResponse_Kit& operator=(GetSequencingKitsResponse_Kit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSequencingKitsResponse_Kit& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSequencingKitsResponse_Kit* internal_default_instance() {
    return reinterpret_cast<const GetSequencingKitsResponse_Kit*>(
               &_GetSequencingKitsResponse_Kit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(GetSequencingKitsResponse_Kit& a, GetSequencingKitsResponse_Kit& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSequencingKitsResponse_Kit* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSequencingKitsResponse_Kit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetSequencingKitsResponse_Kit* New() const final {
    return new GetSequencingKitsResponse_Kit();
  }

  GetSequencingKitsResponse_Kit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetSequencingKitsResponse_Kit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSequencingKitsResponse_Kit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetSequencingKitsResponse_Kit& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSequencingKitsResponse_Kit* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.GetSequencingKitsResponse.Kit";
  }
  protected:
  explicit GetSequencingKitsResponse_Kit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBarcodingExpansionKitsFieldNumber = 2,
    kProductCodeFieldNumber = 1,
    kPcrFreeFieldNumber = 8,
    kFrequentlyUsedFieldNumber = 18,
    kDnaFieldNumber = 5,
    kRnaFieldNumber = 6,
    kPcrFieldNumber = 7,
    kIncludesBarcodingFieldNumber = 3,
    kLampKitFieldNumber = 16,
    kHasControlProtocolFieldNumber = 4,
    kNoSequencingProtocolFieldNumber = 17,
  };
  // repeated int32 barcoding_expansion_kits = 2;
  int barcoding_expansion_kits_size() const;
  private:
  int _internal_barcoding_expansion_kits_size() const;
  public:
  void clear_barcoding_expansion_kits();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_barcoding_expansion_kits(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_barcoding_expansion_kits() const;
  void _internal_add_barcoding_expansion_kits(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_barcoding_expansion_kits();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 barcoding_expansion_kits(int index) const;
  void set_barcoding_expansion_kits(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_barcoding_expansion_kits(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      barcoding_expansion_kits() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_barcoding_expansion_kits();

  // string product_code = 1;
  void clear_product_code();
  const std::string& product_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_product_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_product_code();
  PROTOBUF_MUST_USE_RESULT std::string* release_product_code();
  void set_allocated_product_code(std::string* product_code);
  private:
  const std::string& _internal_product_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_product_code(const std::string& value);
  std::string* _internal_mutable_product_code();
  public:

  // bool pcr_free = 8;
  void clear_pcr_free();
  bool pcr_free() const;
  void set_pcr_free(bool value);
  private:
  bool _internal_pcr_free() const;
  void _internal_set_pcr_free(bool value);
  public:

  // bool frequently_used = 18;
  void clear_frequently_used();
  bool frequently_used() const;
  void set_frequently_used(bool value);
  private:
  bool _internal_frequently_used() const;
  void _internal_set_frequently_used(bool value);
  public:

  // bool dna = 5;
  void clear_dna();
  bool dna() const;
  void set_dna(bool value);
  private:
  bool _internal_dna() const;
  void _internal_set_dna(bool value);
  public:

  // bool rna = 6;
  void clear_rna();
  bool rna() const;
  void set_rna(bool value);
  private:
  bool _internal_rna() const;
  void _internal_set_rna(bool value);
  public:

  // bool pcr = 7;
  void clear_pcr();
  bool pcr() const;
  void set_pcr(bool value);
  private:
  bool _internal_pcr() const;
  void _internal_set_pcr(bool value);
  public:

  // bool includes_barcoding = 3;
  void clear_includes_barcoding();
  bool includes_barcoding() const;
  void set_includes_barcoding(bool value);
  private:
  bool _internal_includes_barcoding() const;
  void _internal_set_includes_barcoding(bool value);
  public:

  // bool lamp_kit = 16;
  void clear_lamp_kit();
  bool lamp_kit() const;
  void set_lamp_kit(bool value);
  private:
  bool _internal_lamp_kit() const;
  void _internal_set_lamp_kit(bool value);
  public:

  // bool has_control_protocol = 4;
  void clear_has_control_protocol();
  bool has_control_protocol() const;
  void set_has_control_protocol(bool value);
  private:
  bool _internal_has_control_protocol() const;
  void _internal_set_has_control_protocol(bool value);
  public:

  // bool no_sequencing_protocol = 17;
  void clear_no_sequencing_protocol();
  bool no_sequencing_protocol() const;
  void set_no_sequencing_protocol(bool value);
  private:
  bool _internal_no_sequencing_protocol() const;
  void _internal_set_no_sequencing_protocol(bool value);
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.manager.GetSequencingKitsResponse.Kit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > barcoding_expansion_kits_;
  mutable std::atomic<int> _barcoding_expansion_kits_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr product_code_;
  bool pcr_free_;
  bool frequently_used_;
  bool dna_;
  bool rna_;
  bool pcr_;
  bool includes_barcoding_;
  bool lamp_kit_;
  bool has_control_protocol_;
  bool no_sequencing_protocol_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class GetSequencingKitsResponse_BarcodingExpansionKit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.GetSequencingKitsResponse.BarcodingExpansionKit) */ {
 public:
  inline GetSequencingKitsResponse_BarcodingExpansionKit() : GetSequencingKitsResponse_BarcodingExpansionKit(nullptr) {}
  ~GetSequencingKitsResponse_BarcodingExpansionKit() override;
  explicit constexpr GetSequencingKitsResponse_BarcodingExpansionKit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSequencingKitsResponse_BarcodingExpansionKit(const GetSequencingKitsResponse_BarcodingExpansionKit& from);
  GetSequencingKitsResponse_BarcodingExpansionKit(GetSequencingKitsResponse_BarcodingExpansionKit&& from) noexcept
    : GetSequencingKitsResponse_BarcodingExpansionKit() {
    *this = ::std::move(from);
  }

  inline GetSequencingKitsResponse_BarcodingExpansionKit& operator=(const GetSequencingKitsResponse_BarcodingExpansionKit& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSequencingKitsResponse_BarcodingExpansionKit& operator=(GetSequencingKitsResponse_BarcodingExpansionKit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSequencingKitsResponse_BarcodingExpansionKit& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSequencingKitsResponse_BarcodingExpansionKit* internal_default_instance() {
    return reinterpret_cast<const GetSequencingKitsResponse_BarcodingExpansionKit*>(
               &_GetSequencingKitsResponse_BarcodingExpansionKit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(GetSequencingKitsResponse_BarcodingExpansionKit& a, GetSequencingKitsResponse_BarcodingExpansionKit& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSequencingKitsResponse_BarcodingExpansionKit* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSequencingKitsResponse_BarcodingExpansionKit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetSequencingKitsResponse_BarcodingExpansionKit* New() const final {
    return new GetSequencingKitsResponse_BarcodingExpansionKit();
  }

  GetSequencingKitsResponse_BarcodingExpansionKit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetSequencingKitsResponse_BarcodingExpansionKit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSequencingKitsResponse_BarcodingExpansionKit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetSequencingKitsResponse_BarcodingExpansionKit& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSequencingKitsResponse_BarcodingExpansionKit* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.GetSequencingKitsResponse.BarcodingExpansionKit";
  }
  protected:
  explicit GetSequencingKitsResponse_BarcodingExpansionKit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProductCodeFieldNumber = 1,
  };
  // string product_code = 1;
  void clear_product_code();
  const std::string& product_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_product_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_product_code();
  PROTOBUF_MUST_USE_RESULT std::string* release_product_code();
  void set_allocated_product_code(std::string* product_code);
  private:
  const std::string& _internal_product_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_product_code(const std::string& value);
  std::string* _internal_mutable_product_code();
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.manager.GetSequencingKitsResponse.BarcodingExpansionKit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr product_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class GetSequencingKitsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.GetSequencingKitsResponse) */ {
 public:
  inline GetSequencingKitsResponse() : GetSequencingKitsResponse(nullptr) {}
  ~GetSequencingKitsResponse() override;
  explicit constexpr GetSequencingKitsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSequencingKitsResponse(const GetSequencingKitsResponse& from);
  GetSequencingKitsResponse(GetSequencingKitsResponse&& from) noexcept
    : GetSequencingKitsResponse() {
    *this = ::std::move(from);
  }

  inline GetSequencingKitsResponse& operator=(const GetSequencingKitsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSequencingKitsResponse& operator=(GetSequencingKitsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSequencingKitsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSequencingKitsResponse* internal_default_instance() {
    return reinterpret_cast<const GetSequencingKitsResponse*>(
               &_GetSequencingKitsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(GetSequencingKitsResponse& a, GetSequencingKitsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSequencingKitsResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSequencingKitsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetSequencingKitsResponse* New() const final {
    return new GetSequencingKitsResponse();
  }

  GetSequencingKitsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetSequencingKitsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSequencingKitsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetSequencingKitsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSequencingKitsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.GetSequencingKitsResponse";
  }
  protected:
  explicit GetSequencingKitsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GetSequencingKitsResponse_Kit Kit;
  typedef GetSequencingKitsResponse_BarcodingExpansionKit BarcodingExpansionKit;

  // accessors -------------------------------------------------------

  enum : int {
    kKitsFieldNumber = 1,
    kBarcodingExpansionKitsFieldNumber = 2,
  };
  // repeated .minknow_api.manager.GetSequencingKitsResponse.Kit kits = 1;
  int kits_size() const;
  private:
  int _internal_kits_size() const;
  public:
  void clear_kits();
  ::minknow_api::manager::GetSequencingKitsResponse_Kit* mutable_kits(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::GetSequencingKitsResponse_Kit >*
      mutable_kits();
  private:
  const ::minknow_api::manager::GetSequencingKitsResponse_Kit& _internal_kits(int index) const;
  ::minknow_api::manager::GetSequencingKitsResponse_Kit* _internal_add_kits();
  public:
  const ::minknow_api::manager::GetSequencingKitsResponse_Kit& kits(int index) const;
  ::minknow_api::manager::GetSequencingKitsResponse_Kit* add_kits();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::GetSequencingKitsResponse_Kit >&
      kits() const;

  // repeated .minknow_api.manager.GetSequencingKitsResponse.BarcodingExpansionKit barcoding_expansion_kits = 2;
  int barcoding_expansion_kits_size() const;
  private:
  int _internal_barcoding_expansion_kits_size() const;
  public:
  void clear_barcoding_expansion_kits();
  ::minknow_api::manager::GetSequencingKitsResponse_BarcodingExpansionKit* mutable_barcoding_expansion_kits(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::GetSequencingKitsResponse_BarcodingExpansionKit >*
      mutable_barcoding_expansion_kits();
  private:
  const ::minknow_api::manager::GetSequencingKitsResponse_BarcodingExpansionKit& _internal_barcoding_expansion_kits(int index) const;
  ::minknow_api::manager::GetSequencingKitsResponse_BarcodingExpansionKit* _internal_add_barcoding_expansion_kits();
  public:
  const ::minknow_api::manager::GetSequencingKitsResponse_BarcodingExpansionKit& barcoding_expansion_kits(int index) const;
  ::minknow_api::manager::GetSequencingKitsResponse_BarcodingExpansionKit* add_barcoding_expansion_kits();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::GetSequencingKitsResponse_BarcodingExpansionKit >&
      barcoding_expansion_kits() const;

  // @@protoc_insertion_point(class_scope:minknow_api.manager.GetSequencingKitsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::GetSequencingKitsResponse_Kit > kits_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::GetSequencingKitsResponse_BarcodingExpansionKit > barcoding_expansion_kits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class AddSimulatedDeviceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.AddSimulatedDeviceRequest) */ {
 public:
  inline AddSimulatedDeviceRequest() : AddSimulatedDeviceRequest(nullptr) {}
  ~AddSimulatedDeviceRequest() override;
  explicit constexpr AddSimulatedDeviceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddSimulatedDeviceRequest(const AddSimulatedDeviceRequest& from);
  AddSimulatedDeviceRequest(AddSimulatedDeviceRequest&& from) noexcept
    : AddSimulatedDeviceRequest() {
    *this = ::std::move(from);
  }

  inline AddSimulatedDeviceRequest& operator=(const AddSimulatedDeviceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddSimulatedDeviceRequest& operator=(AddSimulatedDeviceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddSimulatedDeviceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddSimulatedDeviceRequest* internal_default_instance() {
    return reinterpret_cast<const AddSimulatedDeviceRequest*>(
               &_AddSimulatedDeviceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(AddSimulatedDeviceRequest& a, AddSimulatedDeviceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddSimulatedDeviceRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddSimulatedDeviceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AddSimulatedDeviceRequest* New() const final {
    return new AddSimulatedDeviceRequest();
  }

  AddSimulatedDeviceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AddSimulatedDeviceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddSimulatedDeviceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AddSimulatedDeviceRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddSimulatedDeviceRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.AddSimulatedDeviceRequest";
  }
  protected:
  explicit AddSimulatedDeviceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.minknow_api.rpc_required) = true];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.manager.AddSimulatedDeviceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class AddSimulatedDeviceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:minknow_api.manager.AddSimulatedDeviceResponse) */ {
 public:
  inline AddSimulatedDeviceResponse() : AddSimulatedDeviceResponse(nullptr) {}
  explicit constexpr AddSimulatedDeviceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddSimulatedDeviceResponse(const AddSimulatedDeviceResponse& from);
  AddSimulatedDeviceResponse(AddSimulatedDeviceResponse&& from) noexcept
    : AddSimulatedDeviceResponse() {
    *this = ::std::move(from);
  }

  inline AddSimulatedDeviceResponse& operator=(const AddSimulatedDeviceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddSimulatedDeviceResponse& operator=(AddSimulatedDeviceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddSimulatedDeviceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddSimulatedDeviceResponse* internal_default_instance() {
    return reinterpret_cast<const AddSimulatedDeviceResponse*>(
               &_AddSimulatedDeviceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(AddSimulatedDeviceResponse& a, AddSimulatedDeviceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AddSimulatedDeviceResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddSimulatedDeviceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AddSimulatedDeviceResponse* New() const final {
    return new AddSimulatedDeviceResponse();
  }

  AddSimulatedDeviceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AddSimulatedDeviceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AddSimulatedDeviceResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AddSimulatedDeviceResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.AddSimulatedDeviceResponse";
  }
  protected:
  explicit AddSimulatedDeviceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:minknow_api.manager.AddSimulatedDeviceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class RemoveSimulatedDeviceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.RemoveSimulatedDeviceRequest) */ {
 public:
  inline RemoveSimulatedDeviceRequest() : RemoveSimulatedDeviceRequest(nullptr) {}
  ~RemoveSimulatedDeviceRequest() override;
  explicit constexpr RemoveSimulatedDeviceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveSimulatedDeviceRequest(const RemoveSimulatedDeviceRequest& from);
  RemoveSimulatedDeviceRequest(RemoveSimulatedDeviceRequest&& from) noexcept
    : RemoveSimulatedDeviceRequest() {
    *this = ::std::move(from);
  }

  inline RemoveSimulatedDeviceRequest& operator=(const RemoveSimulatedDeviceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveSimulatedDeviceRequest& operator=(RemoveSimulatedDeviceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveSimulatedDeviceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveSimulatedDeviceRequest* internal_default_instance() {
    return reinterpret_cast<const RemoveSimulatedDeviceRequest*>(
               &_RemoveSimulatedDeviceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(RemoveSimulatedDeviceRequest& a, RemoveSimulatedDeviceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveSimulatedDeviceRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveSimulatedDeviceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RemoveSimulatedDeviceRequest* New() const final {
    return new RemoveSimulatedDeviceRequest();
  }

  RemoveSimulatedDeviceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RemoveSimulatedDeviceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoveSimulatedDeviceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RemoveSimulatedDeviceRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveSimulatedDeviceRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.RemoveSimulatedDeviceRequest";
  }
  protected:
  explicit RemoveSimulatedDeviceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.minknow_api.rpc_required) = true];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.manager.RemoveSimulatedDeviceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class RemoveSimulatedDeviceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:minknow_api.manager.RemoveSimulatedDeviceResponse) */ {
 public:
  inline RemoveSimulatedDeviceResponse() : RemoveSimulatedDeviceResponse(nullptr) {}
  explicit constexpr RemoveSimulatedDeviceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveSimulatedDeviceResponse(const RemoveSimulatedDeviceResponse& from);
  RemoveSimulatedDeviceResponse(RemoveSimulatedDeviceResponse&& from) noexcept
    : RemoveSimulatedDeviceResponse() {
    *this = ::std::move(from);
  }

  inline RemoveSimulatedDeviceResponse& operator=(const RemoveSimulatedDeviceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveSimulatedDeviceResponse& operator=(RemoveSimulatedDeviceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveSimulatedDeviceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveSimulatedDeviceResponse* internal_default_instance() {
    return reinterpret_cast<const RemoveSimulatedDeviceResponse*>(
               &_RemoveSimulatedDeviceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(RemoveSimulatedDeviceResponse& a, RemoveSimulatedDeviceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveSimulatedDeviceResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveSimulatedDeviceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RemoveSimulatedDeviceResponse* New() const final {
    return new RemoveSimulatedDeviceResponse();
  }

  RemoveSimulatedDeviceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RemoveSimulatedDeviceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RemoveSimulatedDeviceResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RemoveSimulatedDeviceResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.RemoveSimulatedDeviceResponse";
  }
  protected:
  explicit RemoveSimulatedDeviceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:minknow_api.manager.RemoveSimulatedDeviceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class LocalAuthenticationTokenPathRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:minknow_api.manager.LocalAuthenticationTokenPathRequest) */ {
 public:
  inline LocalAuthenticationTokenPathRequest() : LocalAuthenticationTokenPathRequest(nullptr) {}
  explicit constexpr LocalAuthenticationTokenPathRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocalAuthenticationTokenPathRequest(const LocalAuthenticationTokenPathRequest& from);
  LocalAuthenticationTokenPathRequest(LocalAuthenticationTokenPathRequest&& from) noexcept
    : LocalAuthenticationTokenPathRequest() {
    *this = ::std::move(from);
  }

  inline LocalAuthenticationTokenPathRequest& operator=(const LocalAuthenticationTokenPathRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocalAuthenticationTokenPathRequest& operator=(LocalAuthenticationTokenPathRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocalAuthenticationTokenPathRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocalAuthenticationTokenPathRequest* internal_default_instance() {
    return reinterpret_cast<const LocalAuthenticationTokenPathRequest*>(
               &_LocalAuthenticationTokenPathRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(LocalAuthenticationTokenPathRequest& a, LocalAuthenticationTokenPathRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LocalAuthenticationTokenPathRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocalAuthenticationTokenPathRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LocalAuthenticationTokenPathRequest* New() const final {
    return new LocalAuthenticationTokenPathRequest();
  }

  LocalAuthenticationTokenPathRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LocalAuthenticationTokenPathRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const LocalAuthenticationTokenPathRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const LocalAuthenticationTokenPathRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.LocalAuthenticationTokenPathRequest";
  }
  protected:
  explicit LocalAuthenticationTokenPathRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:minknow_api.manager.LocalAuthenticationTokenPathRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class LocalAuthenticationTokenPathResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.LocalAuthenticationTokenPathResponse) */ {
 public:
  inline LocalAuthenticationTokenPathResponse() : LocalAuthenticationTokenPathResponse(nullptr) {}
  ~LocalAuthenticationTokenPathResponse() override;
  explicit constexpr LocalAuthenticationTokenPathResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocalAuthenticationTokenPathResponse(const LocalAuthenticationTokenPathResponse& from);
  LocalAuthenticationTokenPathResponse(LocalAuthenticationTokenPathResponse&& from) noexcept
    : LocalAuthenticationTokenPathResponse() {
    *this = ::std::move(from);
  }

  inline LocalAuthenticationTokenPathResponse& operator=(const LocalAuthenticationTokenPathResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocalAuthenticationTokenPathResponse& operator=(LocalAuthenticationTokenPathResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocalAuthenticationTokenPathResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocalAuthenticationTokenPathResponse* internal_default_instance() {
    return reinterpret_cast<const LocalAuthenticationTokenPathResponse*>(
               &_LocalAuthenticationTokenPathResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(LocalAuthenticationTokenPathResponse& a, LocalAuthenticationTokenPathResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LocalAuthenticationTokenPathResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocalAuthenticationTokenPathResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LocalAuthenticationTokenPathResponse* New() const final {
    return new LocalAuthenticationTokenPathResponse();
  }

  LocalAuthenticationTokenPathResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LocalAuthenticationTokenPathResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocalAuthenticationTokenPathResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LocalAuthenticationTokenPathResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocalAuthenticationTokenPathResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.LocalAuthenticationTokenPathResponse";
  }
  protected:
  explicit LocalAuthenticationTokenPathResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
  };
  // string path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_MUST_USE_RESULT std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.manager.LocalAuthenticationTokenPathResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class GetAlignmentReferenceInformationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.GetAlignmentReferenceInformationRequest) */ {
 public:
  inline GetAlignmentReferenceInformationRequest() : GetAlignmentReferenceInformationRequest(nullptr) {}
  ~GetAlignmentReferenceInformationRequest() override;
  explicit constexpr GetAlignmentReferenceInformationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAlignmentReferenceInformationRequest(const GetAlignmentReferenceInformationRequest& from);
  GetAlignmentReferenceInformationRequest(GetAlignmentReferenceInformationRequest&& from) noexcept
    : GetAlignmentReferenceInformationRequest() {
    *this = ::std::move(from);
  }

  inline GetAlignmentReferenceInformationRequest& operator=(const GetAlignmentReferenceInformationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAlignmentReferenceInformationRequest& operator=(GetAlignmentReferenceInformationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAlignmentReferenceInformationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAlignmentReferenceInformationRequest* internal_default_instance() {
    return reinterpret_cast<const GetAlignmentReferenceInformationRequest*>(
               &_GetAlignmentReferenceInformationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(GetAlignmentReferenceInformationRequest& a, GetAlignmentReferenceInformationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAlignmentReferenceInformationRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAlignmentReferenceInformationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetAlignmentReferenceInformationRequest* New() const final {
    return new GetAlignmentReferenceInformationRequest();
  }

  GetAlignmentReferenceInformationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetAlignmentReferenceInformationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAlignmentReferenceInformationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetAlignmentReferenceInformationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAlignmentReferenceInformationRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.GetAlignmentReferenceInformationRequest";
  }
  protected:
  explicit GetAlignmentReferenceInformationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
  };
  // string path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_MUST_USE_RESULT std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.manager.GetAlignmentReferenceInformationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class GetAlignmentReferenceInformationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.GetAlignmentReferenceInformationResponse) */ {
 public:
  inline GetAlignmentReferenceInformationResponse() : GetAlignmentReferenceInformationResponse(nullptr) {}
  ~GetAlignmentReferenceInformationResponse() override;
  explicit constexpr GetAlignmentReferenceInformationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAlignmentReferenceInformationResponse(const GetAlignmentReferenceInformationResponse& from);
  GetAlignmentReferenceInformationResponse(GetAlignmentReferenceInformationResponse&& from) noexcept
    : GetAlignmentReferenceInformationResponse() {
    *this = ::std::move(from);
  }

  inline GetAlignmentReferenceInformationResponse& operator=(const GetAlignmentReferenceInformationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAlignmentReferenceInformationResponse& operator=(GetAlignmentReferenceInformationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAlignmentReferenceInformationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAlignmentReferenceInformationResponse* internal_default_instance() {
    return reinterpret_cast<const GetAlignmentReferenceInformationResponse*>(
               &_GetAlignmentReferenceInformationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(GetAlignmentReferenceInformationResponse& a, GetAlignmentReferenceInformationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAlignmentReferenceInformationResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAlignmentReferenceInformationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetAlignmentReferenceInformationResponse* New() const final {
    return new GetAlignmentReferenceInformationResponse();
  }

  GetAlignmentReferenceInformationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetAlignmentReferenceInformationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAlignmentReferenceInformationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetAlignmentReferenceInformationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAlignmentReferenceInformationResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.GetAlignmentReferenceInformationResponse";
  }
  protected:
  explicit GetAlignmentReferenceInformationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEstimatedReferenceSizeBasesFieldNumber = 2,
    kEstimatedLoadTimeSecondsFieldNumber = 1,
    kRecommendedLiveUsageFieldNumber = 3,
  };
  // uint64 estimated_reference_size_bases = 2;
  void clear_estimated_reference_size_bases();
  ::PROTOBUF_NAMESPACE_ID::uint64 estimated_reference_size_bases() const;
  void set_estimated_reference_size_bases(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_estimated_reference_size_bases() const;
  void _internal_set_estimated_reference_size_bases(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // float estimated_load_time_seconds = 1;
  void clear_estimated_load_time_seconds();
  float estimated_load_time_seconds() const;
  void set_estimated_load_time_seconds(float value);
  private:
  float _internal_estimated_load_time_seconds() const;
  void _internal_set_estimated_load_time_seconds(float value);
  public:

  // bool recommended_live_usage = 3;
  void clear_recommended_live_usage();
  bool recommended_live_usage() const;
  void set_recommended_live_usage(bool value);
  private:
  bool _internal_recommended_live_usage() const;
  void _internal_set_recommended_live_usage(bool value);
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.manager.GetAlignmentReferenceInformationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 estimated_reference_size_bases_;
  float estimated_load_time_seconds_;
  bool recommended_live_usage_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class AssociationDeviceCodeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.AssociationDeviceCodeRequest) */ {
 public:
  inline AssociationDeviceCodeRequest() : AssociationDeviceCodeRequest(nullptr) {}
  ~AssociationDeviceCodeRequest() override;
  explicit constexpr AssociationDeviceCodeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AssociationDeviceCodeRequest(const AssociationDeviceCodeRequest& from);
  AssociationDeviceCodeRequest(AssociationDeviceCodeRequest&& from) noexcept
    : AssociationDeviceCodeRequest() {
    *this = ::std::move(from);
  }

  inline AssociationDeviceCodeRequest& operator=(const AssociationDeviceCodeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssociationDeviceCodeRequest& operator=(AssociationDeviceCodeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AssociationDeviceCodeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssociationDeviceCodeRequest* internal_default_instance() {
    return reinterpret_cast<const AssociationDeviceCodeRequest*>(
               &_AssociationDeviceCodeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(AssociationDeviceCodeRequest& a, AssociationDeviceCodeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AssociationDeviceCodeRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssociationDeviceCodeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AssociationDeviceCodeRequest* New() const final {
    return new AssociationDeviceCodeRequest();
  }

  AssociationDeviceCodeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AssociationDeviceCodeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AssociationDeviceCodeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AssociationDeviceCodeRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AssociationDeviceCodeRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.AssociationDeviceCodeRequest";
  }
  protected:
  explicit AssociationDeviceCodeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionNameFieldNumber = 1,
    kOfflineFieldNumber = 2,
  };
  // string position_name = 1;
  void clear_position_name();
  const std::string& position_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_position_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_position_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_position_name();
  void set_allocated_position_name(std::string* position_name);
  private:
  const std::string& _internal_position_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_position_name(const std::string& value);
  std::string* _internal_mutable_position_name();
  public:

  // bool offline = 2;
  void clear_offline();
  bool offline() const;
  void set_offline(bool value);
  private:
  bool _internal_offline() const;
  void _internal_set_offline(bool value);
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.manager.AssociationDeviceCodeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr position_name_;
  bool offline_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class AssociationDeviceCodeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.AssociationDeviceCodeResponse) */ {
 public:
  inline AssociationDeviceCodeResponse() : AssociationDeviceCodeResponse(nullptr) {}
  ~AssociationDeviceCodeResponse() override;
  explicit constexpr AssociationDeviceCodeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AssociationDeviceCodeResponse(const AssociationDeviceCodeResponse& from);
  AssociationDeviceCodeResponse(AssociationDeviceCodeResponse&& from) noexcept
    : AssociationDeviceCodeResponse() {
    *this = ::std::move(from);
  }

  inline AssociationDeviceCodeResponse& operator=(const AssociationDeviceCodeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssociationDeviceCodeResponse& operator=(AssociationDeviceCodeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AssociationDeviceCodeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssociationDeviceCodeResponse* internal_default_instance() {
    return reinterpret_cast<const AssociationDeviceCodeResponse*>(
               &_AssociationDeviceCodeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(AssociationDeviceCodeResponse& a, AssociationDeviceCodeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AssociationDeviceCodeResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssociationDeviceCodeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AssociationDeviceCodeResponse* New() const final {
    return new AssociationDeviceCodeResponse();
  }

  AssociationDeviceCodeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AssociationDeviceCodeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AssociationDeviceCodeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AssociationDeviceCodeResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AssociationDeviceCodeResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.AssociationDeviceCodeResponse";
  }
  protected:
  explicit AssociationDeviceCodeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodeFieldNumber = 1,
  };
  // string code = 1;
  void clear_code();
  const std::string& code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code();
  PROTOBUF_MUST_USE_RESULT std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.manager.AssociationDeviceCodeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class ApplyOfflineAssociationUnlockCodeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.ApplyOfflineAssociationUnlockCodeRequest) */ {
 public:
  inline ApplyOfflineAssociationUnlockCodeRequest() : ApplyOfflineAssociationUnlockCodeRequest(nullptr) {}
  ~ApplyOfflineAssociationUnlockCodeRequest() override;
  explicit constexpr ApplyOfflineAssociationUnlockCodeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApplyOfflineAssociationUnlockCodeRequest(const ApplyOfflineAssociationUnlockCodeRequest& from);
  ApplyOfflineAssociationUnlockCodeRequest(ApplyOfflineAssociationUnlockCodeRequest&& from) noexcept
    : ApplyOfflineAssociationUnlockCodeRequest() {
    *this = ::std::move(from);
  }

  inline ApplyOfflineAssociationUnlockCodeRequest& operator=(const ApplyOfflineAssociationUnlockCodeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplyOfflineAssociationUnlockCodeRequest& operator=(ApplyOfflineAssociationUnlockCodeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApplyOfflineAssociationUnlockCodeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApplyOfflineAssociationUnlockCodeRequest* internal_default_instance() {
    return reinterpret_cast<const ApplyOfflineAssociationUnlockCodeRequest*>(
               &_ApplyOfflineAssociationUnlockCodeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(ApplyOfflineAssociationUnlockCodeRequest& a, ApplyOfflineAssociationUnlockCodeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ApplyOfflineAssociationUnlockCodeRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplyOfflineAssociationUnlockCodeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ApplyOfflineAssociationUnlockCodeRequest* New() const final {
    return new ApplyOfflineAssociationUnlockCodeRequest();
  }

  ApplyOfflineAssociationUnlockCodeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ApplyOfflineAssociationUnlockCodeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApplyOfflineAssociationUnlockCodeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ApplyOfflineAssociationUnlockCodeRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplyOfflineAssociationUnlockCodeRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.ApplyOfflineAssociationUnlockCodeRequest";
  }
  protected:
  explicit ApplyOfflineAssociationUnlockCodeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionNameFieldNumber = 1,
    kUnlockCodeFieldNumber = 2,
  };
  // string position_name = 1;
  void clear_position_name();
  const std::string& position_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_position_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_position_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_position_name();
  void set_allocated_position_name(std::string* position_name);
  private:
  const std::string& _internal_position_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_position_name(const std::string& value);
  std::string* _internal_mutable_position_name();
  public:

  // string unlock_code = 2;
  void clear_unlock_code();
  const std::string& unlock_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_unlock_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_unlock_code();
  PROTOBUF_MUST_USE_RESULT std::string* release_unlock_code();
  void set_allocated_unlock_code(std::string* unlock_code);
  private:
  const std::string& _internal_unlock_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unlock_code(const std::string& value);
  std::string* _internal_mutable_unlock_code();
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.manager.ApplyOfflineAssociationUnlockCodeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr position_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unlock_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class ApplyOfflineAssociationUnlockCodeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.ApplyOfflineAssociationUnlockCodeResponse) */ {
 public:
  inline ApplyOfflineAssociationUnlockCodeResponse() : ApplyOfflineAssociationUnlockCodeResponse(nullptr) {}
  ~ApplyOfflineAssociationUnlockCodeResponse() override;
  explicit constexpr ApplyOfflineAssociationUnlockCodeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApplyOfflineAssociationUnlockCodeResponse(const ApplyOfflineAssociationUnlockCodeResponse& from);
  ApplyOfflineAssociationUnlockCodeResponse(ApplyOfflineAssociationUnlockCodeResponse&& from) noexcept
    : ApplyOfflineAssociationUnlockCodeResponse() {
    *this = ::std::move(from);
  }

  inline ApplyOfflineAssociationUnlockCodeResponse& operator=(const ApplyOfflineAssociationUnlockCodeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplyOfflineAssociationUnlockCodeResponse& operator=(ApplyOfflineAssociationUnlockCodeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApplyOfflineAssociationUnlockCodeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApplyOfflineAssociationUnlockCodeResponse* internal_default_instance() {
    return reinterpret_cast<const ApplyOfflineAssociationUnlockCodeResponse*>(
               &_ApplyOfflineAssociationUnlockCodeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(ApplyOfflineAssociationUnlockCodeResponse& a, ApplyOfflineAssociationUnlockCodeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ApplyOfflineAssociationUnlockCodeResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplyOfflineAssociationUnlockCodeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ApplyOfflineAssociationUnlockCodeResponse* New() const final {
    return new ApplyOfflineAssociationUnlockCodeResponse();
  }

  ApplyOfflineAssociationUnlockCodeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ApplyOfflineAssociationUnlockCodeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApplyOfflineAssociationUnlockCodeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ApplyOfflineAssociationUnlockCodeResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplyOfflineAssociationUnlockCodeResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.ApplyOfflineAssociationUnlockCodeResponse";
  }
  protected:
  explicit ApplyOfflineAssociationUnlockCodeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssociatedFieldNumber = 1,
  };
  // bool associated = 1;
  void clear_associated();
  bool associated() const;
  void set_associated(bool value);
  private:
  bool _internal_associated() const;
  void _internal_set_associated(bool value);
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.manager.ApplyOfflineAssociationUnlockCodeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool associated_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class ListDeveloperApiTokensRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:minknow_api.manager.ListDeveloperApiTokensRequest) */ {
 public:
  inline ListDeveloperApiTokensRequest() : ListDeveloperApiTokensRequest(nullptr) {}
  explicit constexpr ListDeveloperApiTokensRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListDeveloperApiTokensRequest(const ListDeveloperApiTokensRequest& from);
  ListDeveloperApiTokensRequest(ListDeveloperApiTokensRequest&& from) noexcept
    : ListDeveloperApiTokensRequest() {
    *this = ::std::move(from);
  }

  inline ListDeveloperApiTokensRequest& operator=(const ListDeveloperApiTokensRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListDeveloperApiTokensRequest& operator=(ListDeveloperApiTokensRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListDeveloperApiTokensRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListDeveloperApiTokensRequest* internal_default_instance() {
    return reinterpret_cast<const ListDeveloperApiTokensRequest*>(
               &_ListDeveloperApiTokensRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(ListDeveloperApiTokensRequest& a, ListDeveloperApiTokensRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListDeveloperApiTokensRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListDeveloperApiTokensRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListDeveloperApiTokensRequest* New() const final {
    return new ListDeveloperApiTokensRequest();
  }

  ListDeveloperApiTokensRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListDeveloperApiTokensRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ListDeveloperApiTokensRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ListDeveloperApiTokensRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.ListDeveloperApiTokensRequest";
  }
  protected:
  explicit ListDeveloperApiTokensRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:minknow_api.manager.ListDeveloperApiTokensRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class ListDeveloperApiTokensResponse_DeveloperApiToken final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.ListDeveloperApiTokensResponse.DeveloperApiToken) */ {
 public:
  inline ListDeveloperApiTokensResponse_DeveloperApiToken() : ListDeveloperApiTokensResponse_DeveloperApiToken(nullptr) {}
  ~ListDeveloperApiTokensResponse_DeveloperApiToken() override;
  explicit constexpr ListDeveloperApiTokensResponse_DeveloperApiToken(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListDeveloperApiTokensResponse_DeveloperApiToken(const ListDeveloperApiTokensResponse_DeveloperApiToken& from);
  ListDeveloperApiTokensResponse_DeveloperApiToken(ListDeveloperApiTokensResponse_DeveloperApiToken&& from) noexcept
    : ListDeveloperApiTokensResponse_DeveloperApiToken() {
    *this = ::std::move(from);
  }

  inline ListDeveloperApiTokensResponse_DeveloperApiToken& operator=(const ListDeveloperApiTokensResponse_DeveloperApiToken& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListDeveloperApiTokensResponse_DeveloperApiToken& operator=(ListDeveloperApiTokensResponse_DeveloperApiToken&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListDeveloperApiTokensResponse_DeveloperApiToken& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListDeveloperApiTokensResponse_DeveloperApiToken* internal_default_instance() {
    return reinterpret_cast<const ListDeveloperApiTokensResponse_DeveloperApiToken*>(
               &_ListDeveloperApiTokensResponse_DeveloperApiToken_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(ListDeveloperApiTokensResponse_DeveloperApiToken& a, ListDeveloperApiTokensResponse_DeveloperApiToken& b) {
    a.Swap(&b);
  }
  inline void Swap(ListDeveloperApiTokensResponse_DeveloperApiToken* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListDeveloperApiTokensResponse_DeveloperApiToken* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListDeveloperApiTokensResponse_DeveloperApiToken* New() const final {
    return new ListDeveloperApiTokensResponse_DeveloperApiToken();
  }

  ListDeveloperApiTokensResponse_DeveloperApiToken* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListDeveloperApiTokensResponse_DeveloperApiToken>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListDeveloperApiTokensResponse_DeveloperApiToken& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListDeveloperApiTokensResponse_DeveloperApiToken& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListDeveloperApiTokensResponse_DeveloperApiToken* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.ListDeveloperApiTokensResponse.DeveloperApiToken";
  }
  protected:
  explicit ListDeveloperApiTokensResponse_DeveloperApiToken(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kExpiryFieldNumber = 3,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.protobuf.Timestamp expiry = 3;
  bool has_expiry() const;
  private:
  bool _internal_has_expiry() const;
  public:
  void clear_expiry();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& expiry() const;
  PROTOBUF_MUST_USE_RESULT ::PROTOBUF_NAMESPACE_ID::Timestamp* release_expiry();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_expiry();
  void set_allocated_expiry(::PROTOBUF_NAMESPACE_ID::Timestamp* expiry);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_expiry() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_expiry();
  public:
  void unsafe_arena_set_allocated_expiry(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* expiry);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_expiry();

  // @@protoc_insertion_point(class_scope:minknow_api.manager.ListDeveloperApiTokensResponse.DeveloperApiToken)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* expiry_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class ListDeveloperApiTokensResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.ListDeveloperApiTokensResponse) */ {
 public:
  inline ListDeveloperApiTokensResponse() : ListDeveloperApiTokensResponse(nullptr) {}
  ~ListDeveloperApiTokensResponse() override;
  explicit constexpr ListDeveloperApiTokensResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListDeveloperApiTokensResponse(const ListDeveloperApiTokensResponse& from);
  ListDeveloperApiTokensResponse(ListDeveloperApiTokensResponse&& from) noexcept
    : ListDeveloperApiTokensResponse() {
    *this = ::std::move(from);
  }

  inline ListDeveloperApiTokensResponse& operator=(const ListDeveloperApiTokensResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListDeveloperApiTokensResponse& operator=(ListDeveloperApiTokensResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListDeveloperApiTokensResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListDeveloperApiTokensResponse* internal_default_instance() {
    return reinterpret_cast<const ListDeveloperApiTokensResponse*>(
               &_ListDeveloperApiTokensResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(ListDeveloperApiTokensResponse& a, ListDeveloperApiTokensResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListDeveloperApiTokensResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListDeveloperApiTokensResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListDeveloperApiTokensResponse* New() const final {
    return new ListDeveloperApiTokensResponse();
  }

  ListDeveloperApiTokensResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListDeveloperApiTokensResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListDeveloperApiTokensResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListDeveloperApiTokensResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListDeveloperApiTokensResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.ListDeveloperApiTokensResponse";
  }
  protected:
  explicit ListDeveloperApiTokensResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ListDeveloperApiTokensResponse_DeveloperApiToken DeveloperApiToken;

  // accessors -------------------------------------------------------

  enum : int {
    kTokensFieldNumber = 1,
  };
  // repeated .minknow_api.manager.ListDeveloperApiTokensResponse.DeveloperApiToken tokens = 1;
  int tokens_size() const;
  private:
  int _internal_tokens_size() const;
  public:
  void clear_tokens();
  ::minknow_api::manager::ListDeveloperApiTokensResponse_DeveloperApiToken* mutable_tokens(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::ListDeveloperApiTokensResponse_DeveloperApiToken >*
      mutable_tokens();
  private:
  const ::minknow_api::manager::ListDeveloperApiTokensResponse_DeveloperApiToken& _internal_tokens(int index) const;
  ::minknow_api::manager::ListDeveloperApiTokensResponse_DeveloperApiToken* _internal_add_tokens();
  public:
  const ::minknow_api::manager::ListDeveloperApiTokensResponse_DeveloperApiToken& tokens(int index) const;
  ::minknow_api::manager::ListDeveloperApiTokensResponse_DeveloperApiToken* add_tokens();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::ListDeveloperApiTokensResponse_DeveloperApiToken >&
      tokens() const;

  // @@protoc_insertion_point(class_scope:minknow_api.manager.ListDeveloperApiTokensResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::ListDeveloperApiTokensResponse_DeveloperApiToken > tokens_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class CreateDeveloperApiTokenRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.CreateDeveloperApiTokenRequest) */ {
 public:
  inline CreateDeveloperApiTokenRequest() : CreateDeveloperApiTokenRequest(nullptr) {}
  ~CreateDeveloperApiTokenRequest() override;
  explicit constexpr CreateDeveloperApiTokenRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateDeveloperApiTokenRequest(const CreateDeveloperApiTokenRequest& from);
  CreateDeveloperApiTokenRequest(CreateDeveloperApiTokenRequest&& from) noexcept
    : CreateDeveloperApiTokenRequest() {
    *this = ::std::move(from);
  }

  inline CreateDeveloperApiTokenRequest& operator=(const CreateDeveloperApiTokenRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateDeveloperApiTokenRequest& operator=(CreateDeveloperApiTokenRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateDeveloperApiTokenRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateDeveloperApiTokenRequest* internal_default_instance() {
    return reinterpret_cast<const CreateDeveloperApiTokenRequest*>(
               &_CreateDeveloperApiTokenRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(CreateDeveloperApiTokenRequest& a, CreateDeveloperApiTokenRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateDeveloperApiTokenRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateDeveloperApiTokenRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateDeveloperApiTokenRequest* New() const final {
    return new CreateDeveloperApiTokenRequest();
  }

  CreateDeveloperApiTokenRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateDeveloperApiTokenRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateDeveloperApiTokenRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateDeveloperApiTokenRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateDeveloperApiTokenRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.CreateDeveloperApiTokenRequest";
  }
  protected:
  explicit CreateDeveloperApiTokenRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kExpiryFieldNumber = 3,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.protobuf.Timestamp expiry = 3;
  bool has_expiry() const;
  private:
  bool _internal_has_expiry() const;
  public:
  void clear_expiry();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& expiry() const;
  PROTOBUF_MUST_USE_RESULT ::PROTOBUF_NAMESPACE_ID::Timestamp* release_expiry();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_expiry();
  void set_allocated_expiry(::PROTOBUF_NAMESPACE_ID::Timestamp* expiry);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_expiry() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_expiry();
  public:
  void unsafe_arena_set_allocated_expiry(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* expiry);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_expiry();

  // @@protoc_insertion_point(class_scope:minknow_api.manager.CreateDeveloperApiTokenRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* expiry_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class CreateDeveloperApiTokenResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.CreateDeveloperApiTokenResponse) */ {
 public:
  inline CreateDeveloperApiTokenResponse() : CreateDeveloperApiTokenResponse(nullptr) {}
  ~CreateDeveloperApiTokenResponse() override;
  explicit constexpr CreateDeveloperApiTokenResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateDeveloperApiTokenResponse(const CreateDeveloperApiTokenResponse& from);
  CreateDeveloperApiTokenResponse(CreateDeveloperApiTokenResponse&& from) noexcept
    : CreateDeveloperApiTokenResponse() {
    *this = ::std::move(from);
  }

  inline CreateDeveloperApiTokenResponse& operator=(const CreateDeveloperApiTokenResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateDeveloperApiTokenResponse& operator=(CreateDeveloperApiTokenResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateDeveloperApiTokenResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateDeveloperApiTokenResponse* internal_default_instance() {
    return reinterpret_cast<const CreateDeveloperApiTokenResponse*>(
               &_CreateDeveloperApiTokenResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(CreateDeveloperApiTokenResponse& a, CreateDeveloperApiTokenResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateDeveloperApiTokenResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateDeveloperApiTokenResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateDeveloperApiTokenResponse* New() const final {
    return new CreateDeveloperApiTokenResponse();
  }

  CreateDeveloperApiTokenResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateDeveloperApiTokenResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateDeveloperApiTokenResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateDeveloperApiTokenResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateDeveloperApiTokenResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.CreateDeveloperApiTokenResponse";
  }
  protected:
  explicit CreateDeveloperApiTokenResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kTokenFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string token = 2;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_MUST_USE_RESULT std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.manager.CreateDeveloperApiTokenResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class RevokeDeveloperApiTokenRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.RevokeDeveloperApiTokenRequest) */ {
 public:
  inline RevokeDeveloperApiTokenRequest() : RevokeDeveloperApiTokenRequest(nullptr) {}
  ~RevokeDeveloperApiTokenRequest() override;
  explicit constexpr RevokeDeveloperApiTokenRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RevokeDeveloperApiTokenRequest(const RevokeDeveloperApiTokenRequest& from);
  RevokeDeveloperApiTokenRequest(RevokeDeveloperApiTokenRequest&& from) noexcept
    : RevokeDeveloperApiTokenRequest() {
    *this = ::std::move(from);
  }

  inline RevokeDeveloperApiTokenRequest& operator=(const RevokeDeveloperApiTokenRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RevokeDeveloperApiTokenRequest& operator=(RevokeDeveloperApiTokenRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RevokeDeveloperApiTokenRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RevokeDeveloperApiTokenRequest* internal_default_instance() {
    return reinterpret_cast<const RevokeDeveloperApiTokenRequest*>(
               &_RevokeDeveloperApiTokenRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(RevokeDeveloperApiTokenRequest& a, RevokeDeveloperApiTokenRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RevokeDeveloperApiTokenRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RevokeDeveloperApiTokenRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RevokeDeveloperApiTokenRequest* New() const final {
    return new RevokeDeveloperApiTokenRequest();
  }

  RevokeDeveloperApiTokenRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RevokeDeveloperApiTokenRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RevokeDeveloperApiTokenRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RevokeDeveloperApiTokenRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RevokeDeveloperApiTokenRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.RevokeDeveloperApiTokenRequest";
  }
  protected:
  explicit RevokeDeveloperApiTokenRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.manager.RevokeDeveloperApiTokenRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class RevokeDeveloperApiTokensResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:minknow_api.manager.RevokeDeveloperApiTokensResponse) */ {
 public:
  inline RevokeDeveloperApiTokensResponse() : RevokeDeveloperApiTokensResponse(nullptr) {}
  explicit constexpr RevokeDeveloperApiTokensResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RevokeDeveloperApiTokensResponse(const RevokeDeveloperApiTokensResponse& from);
  RevokeDeveloperApiTokensResponse(RevokeDeveloperApiTokensResponse&& from) noexcept
    : RevokeDeveloperApiTokensResponse() {
    *this = ::std::move(from);
  }

  inline RevokeDeveloperApiTokensResponse& operator=(const RevokeDeveloperApiTokensResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RevokeDeveloperApiTokensResponse& operator=(RevokeDeveloperApiTokensResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RevokeDeveloperApiTokensResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RevokeDeveloperApiTokensResponse* internal_default_instance() {
    return reinterpret_cast<const RevokeDeveloperApiTokensResponse*>(
               &_RevokeDeveloperApiTokensResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(RevokeDeveloperApiTokensResponse& a, RevokeDeveloperApiTokensResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RevokeDeveloperApiTokensResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RevokeDeveloperApiTokensResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RevokeDeveloperApiTokensResponse* New() const final {
    return new RevokeDeveloperApiTokensResponse();
  }

  RevokeDeveloperApiTokensResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RevokeDeveloperApiTokensResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RevokeDeveloperApiTokensResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RevokeDeveloperApiTokensResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.RevokeDeveloperApiTokensResponse";
  }
  protected:
  explicit RevokeDeveloperApiTokensResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:minknow_api.manager.RevokeDeveloperApiTokensResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class FindProtocolsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.FindProtocolsRequest) */ {
 public:
  inline FindProtocolsRequest() : FindProtocolsRequest(nullptr) {}
  ~FindProtocolsRequest() override;
  explicit constexpr FindProtocolsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FindProtocolsRequest(const FindProtocolsRequest& from);
  FindProtocolsRequest(FindProtocolsRequest&& from) noexcept
    : FindProtocolsRequest() {
    *this = ::std::move(from);
  }

  inline FindProtocolsRequest& operator=(const FindProtocolsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FindProtocolsRequest& operator=(FindProtocolsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FindProtocolsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FindProtocolsRequest* internal_default_instance() {
    return reinterpret_cast<const FindProtocolsRequest*>(
               &_FindProtocolsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(FindProtocolsRequest& a, FindProtocolsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FindProtocolsRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FindProtocolsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FindProtocolsRequest* New() const final {
    return new FindProtocolsRequest();
  }

  FindProtocolsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FindProtocolsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FindProtocolsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FindProtocolsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FindProtocolsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.FindProtocolsRequest";
  }
  protected:
  explicit FindProtocolsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlowCellProductCodeFieldNumber = 1,
    kSequencingKitFieldNumber = 2,
    kExperimentTypeFieldNumber = 3,
  };
  // string flow_cell_product_code = 1;
  void clear_flow_cell_product_code();
  const std::string& flow_cell_product_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_flow_cell_product_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_flow_cell_product_code();
  PROTOBUF_MUST_USE_RESULT std::string* release_flow_cell_product_code();
  void set_allocated_flow_cell_product_code(std::string* flow_cell_product_code);
  private:
  const std::string& _internal_flow_cell_product_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_flow_cell_product_code(const std::string& value);
  std::string* _internal_mutable_flow_cell_product_code();
  public:

  // string sequencing_kit = 2;
  void clear_sequencing_kit();
  const std::string& sequencing_kit() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sequencing_kit(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sequencing_kit();
  PROTOBUF_MUST_USE_RESULT std::string* release_sequencing_kit();
  void set_allocated_sequencing_kit(std::string* sequencing_kit);
  private:
  const std::string& _internal_sequencing_kit() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sequencing_kit(const std::string& value);
  std::string* _internal_mutable_sequencing_kit();
  public:

  // .minknow_api.manager.ExperimentType experiment_type = 3;
  void clear_experiment_type();
  ::minknow_api::manager::ExperimentType experiment_type() const;
  void set_experiment_type(::minknow_api::manager::ExperimentType value);
  private:
  ::minknow_api::manager::ExperimentType _internal_experiment_type() const;
  void _internal_set_experiment_type(::minknow_api::manager::ExperimentType value);
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.manager.FindProtocolsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr flow_cell_product_code_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sequencing_kit_;
  int experiment_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class FindProtocolsResponse_Protocol final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.FindProtocolsResponse.Protocol) */ {
 public:
  inline FindProtocolsResponse_Protocol() : FindProtocolsResponse_Protocol(nullptr) {}
  ~FindProtocolsResponse_Protocol() override;
  explicit constexpr FindProtocolsResponse_Protocol(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FindProtocolsResponse_Protocol(const FindProtocolsResponse_Protocol& from);
  FindProtocolsResponse_Protocol(FindProtocolsResponse_Protocol&& from) noexcept
    : FindProtocolsResponse_Protocol() {
    *this = ::std::move(from);
  }

  inline FindProtocolsResponse_Protocol& operator=(const FindProtocolsResponse_Protocol& from) {
    CopyFrom(from);
    return *this;
  }
  inline FindProtocolsResponse_Protocol& operator=(FindProtocolsResponse_Protocol&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FindProtocolsResponse_Protocol& default_instance() {
    return *internal_default_instance();
  }
  static inline const FindProtocolsResponse_Protocol* internal_default_instance() {
    return reinterpret_cast<const FindProtocolsResponse_Protocol*>(
               &_FindProtocolsResponse_Protocol_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(FindProtocolsResponse_Protocol& a, FindProtocolsResponse_Protocol& b) {
    a.Swap(&b);
  }
  inline void Swap(FindProtocolsResponse_Protocol* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FindProtocolsResponse_Protocol* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FindProtocolsResponse_Protocol* New() const final {
    return new FindProtocolsResponse_Protocol();
  }

  FindProtocolsResponse_Protocol* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FindProtocolsResponse_Protocol>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FindProtocolsResponse_Protocol& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FindProtocolsResponse_Protocol& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FindProtocolsResponse_Protocol* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.FindProtocolsResponse.Protocol";
  }
  protected:
  explicit FindProtocolsResponse_Protocol(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifierFieldNumber = 1,
    kRequiresFlowCellProductCodeFieldNumber = 2,
    kRequiresSequencingKitFieldNumber = 3,
  };
  // string identifier = 1;
  void clear_identifier();
  const std::string& identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identifier();
  PROTOBUF_MUST_USE_RESULT std::string* release_identifier();
  void set_allocated_identifier(std::string* identifier);
  private:
  const std::string& _internal_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identifier(const std::string& value);
  std::string* _internal_mutable_identifier();
  public:

  // bool requires_flow_cell_product_code = 2;
  void clear_requires_flow_cell_product_code();
  bool requires_flow_cell_product_code() const;
  void set_requires_flow_cell_product_code(bool value);
  private:
  bool _internal_requires_flow_cell_product_code() const;
  void _internal_set_requires_flow_cell_product_code(bool value);
  public:

  // bool requires_sequencing_kit = 3;
  void clear_requires_sequencing_kit();
  bool requires_sequencing_kit() const;
  void set_requires_sequencing_kit(bool value);
  private:
  bool _internal_requires_sequencing_kit() const;
  void _internal_set_requires_sequencing_kit(bool value);
  public:

  // @@protoc_insertion_point(class_scope:minknow_api.manager.FindProtocolsResponse.Protocol)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identifier_;
  bool requires_flow_cell_product_code_;
  bool requires_sequencing_kit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// -------------------------------------------------------------------

class FindProtocolsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minknow_api.manager.FindProtocolsResponse) */ {
 public:
  inline FindProtocolsResponse() : FindProtocolsResponse(nullptr) {}
  ~FindProtocolsResponse() override;
  explicit constexpr FindProtocolsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FindProtocolsResponse(const FindProtocolsResponse& from);
  FindProtocolsResponse(FindProtocolsResponse&& from) noexcept
    : FindProtocolsResponse() {
    *this = ::std::move(from);
  }

  inline FindProtocolsResponse& operator=(const FindProtocolsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FindProtocolsResponse& operator=(FindProtocolsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FindProtocolsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FindProtocolsResponse* internal_default_instance() {
    return reinterpret_cast<const FindProtocolsResponse*>(
               &_FindProtocolsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(FindProtocolsResponse& a, FindProtocolsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FindProtocolsResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FindProtocolsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FindProtocolsResponse* New() const final {
    return new FindProtocolsResponse();
  }

  FindProtocolsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FindProtocolsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FindProtocolsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FindProtocolsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FindProtocolsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minknow_api.manager.FindProtocolsResponse";
  }
  protected:
  explicit FindProtocolsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FindProtocolsResponse_Protocol Protocol;

  // accessors -------------------------------------------------------

  enum : int {
    kProtocolsFieldNumber = 1,
  };
  // repeated .minknow_api.manager.FindProtocolsResponse.Protocol protocols = 1;
  int protocols_size() const;
  private:
  int _internal_protocols_size() const;
  public:
  void clear_protocols();
  ::minknow_api::manager::FindProtocolsResponse_Protocol* mutable_protocols(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::FindProtocolsResponse_Protocol >*
      mutable_protocols();
  private:
  const ::minknow_api::manager::FindProtocolsResponse_Protocol& _internal_protocols(int index) const;
  ::minknow_api::manager::FindProtocolsResponse_Protocol* _internal_add_protocols();
  public:
  const ::minknow_api::manager::FindProtocolsResponse_Protocol& protocols(int index) const;
  ::minknow_api::manager::FindProtocolsResponse_Protocol* add_protocols();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::FindProtocolsResponse_Protocol >&
      protocols() const;

  // @@protoc_insertion_point(class_scope:minknow_api.manager.FindProtocolsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::FindProtocolsResponse_Protocol > protocols_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minknow_5fapi_2fmanager_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DescribeHostRequest

// -------------------------------------------------------------------

// DescribeHostResponse

// string product_code = 1;
inline void DescribeHostResponse::clear_product_code() {
  product_code_.ClearToEmpty();
}
inline const std::string& DescribeHostResponse::product_code() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.DescribeHostResponse.product_code)
  return _internal_product_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DescribeHostResponse::set_product_code(ArgT0&& arg0, ArgT... args) {
 
 product_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.manager.DescribeHostResponse.product_code)
}
inline std::string* DescribeHostResponse::mutable_product_code() {
  std::string* _s = _internal_mutable_product_code();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.DescribeHostResponse.product_code)
  return _s;
}
inline const std::string& DescribeHostResponse::_internal_product_code() const {
  return product_code_.Get();
}
inline void DescribeHostResponse::_internal_set_product_code(const std::string& value) {
  
  product_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DescribeHostResponse::_internal_mutable_product_code() {
  
  return product_code_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DescribeHostResponse::release_product_code() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.DescribeHostResponse.product_code)
  return product_code_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DescribeHostResponse::set_allocated_product_code(std::string* product_code) {
  if (product_code != nullptr) {
    
  } else {
    
  }
  product_code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), product_code,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.DescribeHostResponse.product_code)
}

// string description = 2;
inline void DescribeHostResponse::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& DescribeHostResponse::description() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.DescribeHostResponse.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DescribeHostResponse::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.manager.DescribeHostResponse.description)
}
inline std::string* DescribeHostResponse::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.DescribeHostResponse.description)
  return _s;
}
inline const std::string& DescribeHostResponse::_internal_description() const {
  return description_.Get();
}
inline void DescribeHostResponse::_internal_set_description(const std::string& value) {
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DescribeHostResponse::_internal_mutable_description() {
  
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DescribeHostResponse::release_description() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.DescribeHostResponse.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DescribeHostResponse::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.DescribeHostResponse.description)
}

// string serial = 3;
inline void DescribeHostResponse::clear_serial() {
  serial_.ClearToEmpty();
}
inline const std::string& DescribeHostResponse::serial() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.DescribeHostResponse.serial)
  return _internal_serial();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DescribeHostResponse::set_serial(ArgT0&& arg0, ArgT... args) {
 
 serial_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.manager.DescribeHostResponse.serial)
}
inline std::string* DescribeHostResponse::mutable_serial() {
  std::string* _s = _internal_mutable_serial();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.DescribeHostResponse.serial)
  return _s;
}
inline const std::string& DescribeHostResponse::_internal_serial() const {
  return serial_.Get();
}
inline void DescribeHostResponse::_internal_set_serial(const std::string& value) {
  
  serial_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DescribeHostResponse::_internal_mutable_serial() {
  
  return serial_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DescribeHostResponse::release_serial() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.DescribeHostResponse.serial)
  return serial_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DescribeHostResponse::set_allocated_serial(std::string* serial) {
  if (serial != nullptr) {
    
  } else {
    
  }
  serial_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serial,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.DescribeHostResponse.serial)
}

// string network_name = 4;
inline void DescribeHostResponse::clear_network_name() {
  network_name_.ClearToEmpty();
}
inline const std::string& DescribeHostResponse::network_name() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.DescribeHostResponse.network_name)
  return _internal_network_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DescribeHostResponse::set_network_name(ArgT0&& arg0, ArgT... args) {
 
 network_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.manager.DescribeHostResponse.network_name)
}
inline std::string* DescribeHostResponse::mutable_network_name() {
  std::string* _s = _internal_mutable_network_name();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.DescribeHostResponse.network_name)
  return _s;
}
inline const std::string& DescribeHostResponse::_internal_network_name() const {
  return network_name_.Get();
}
inline void DescribeHostResponse::_internal_set_network_name(const std::string& value) {
  
  network_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DescribeHostResponse::_internal_mutable_network_name() {
  
  return network_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DescribeHostResponse::release_network_name() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.DescribeHostResponse.network_name)
  return network_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DescribeHostResponse::set_allocated_network_name(std::string* network_name) {
  if (network_name != nullptr) {
    
  } else {
    
  }
  network_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), network_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.DescribeHostResponse.network_name)
}

// bool needs_association = 16;
inline void DescribeHostResponse::clear_needs_association() {
  needs_association_ = false;
}
inline bool DescribeHostResponse::_internal_needs_association() const {
  return needs_association_;
}
inline bool DescribeHostResponse::needs_association() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.DescribeHostResponse.needs_association)
  return _internal_needs_association();
}
inline void DescribeHostResponse::_internal_set_needs_association(bool value) {
  
  needs_association_ = value;
}
inline void DescribeHostResponse::set_needs_association(bool value) {
  _internal_set_needs_association(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.DescribeHostResponse.needs_association)
}

// bool can_sequence_offline = 5;
inline void DescribeHostResponse::clear_can_sequence_offline() {
  can_sequence_offline_ = false;
}
inline bool DescribeHostResponse::_internal_can_sequence_offline() const {
  return can_sequence_offline_;
}
inline bool DescribeHostResponse::can_sequence_offline() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.DescribeHostResponse.can_sequence_offline)
  return _internal_can_sequence_offline();
}
inline void DescribeHostResponse::_internal_set_can_sequence_offline(bool value) {
  
  can_sequence_offline_ = value;
}
inline void DescribeHostResponse::set_can_sequence_offline(bool value) {
  _internal_set_can_sequence_offline(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.DescribeHostResponse.can_sequence_offline)
}

// -------------------------------------------------------------------

// FlowCellPosition_Location

// int32 x = 1;
inline void FlowCellPosition_Location::clear_x() {
  x_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FlowCellPosition_Location::_internal_x() const {
  return x_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FlowCellPosition_Location::x() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.FlowCellPosition.Location.x)
  return _internal_x();
}
inline void FlowCellPosition_Location::_internal_set_x(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  x_ = value;
}
inline void FlowCellPosition_Location::set_x(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.FlowCellPosition.Location.x)
}

// int32 y = 2;
inline void FlowCellPosition_Location::clear_y() {
  y_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FlowCellPosition_Location::_internal_y() const {
  return y_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FlowCellPosition_Location::y() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.FlowCellPosition.Location.y)
  return _internal_y();
}
inline void FlowCellPosition_Location::_internal_set_y(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  y_ = value;
}
inline void FlowCellPosition_Location::set_y(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.FlowCellPosition.Location.y)
}

// -------------------------------------------------------------------

// FlowCellPosition_RpcPorts

// uint32 secure = 1;
inline void FlowCellPosition_RpcPorts::clear_secure() {
  secure_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FlowCellPosition_RpcPorts::_internal_secure() const {
  return secure_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FlowCellPosition_RpcPorts::secure() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.FlowCellPosition.RpcPorts.secure)
  return _internal_secure();
}
inline void FlowCellPosition_RpcPorts::_internal_set_secure(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  secure_ = value;
}
inline void FlowCellPosition_RpcPorts::set_secure(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_secure(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.FlowCellPosition.RpcPorts.secure)
}

// uint32 insecure = 2;
inline void FlowCellPosition_RpcPorts::clear_insecure() {
  insecure_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FlowCellPosition_RpcPorts::_internal_insecure() const {
  return insecure_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FlowCellPosition_RpcPorts::insecure() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.FlowCellPosition.RpcPorts.insecure)
  return _internal_insecure();
}
inline void FlowCellPosition_RpcPorts::_internal_set_insecure(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  insecure_ = value;
}
inline void FlowCellPosition_RpcPorts::set_insecure(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_insecure(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.FlowCellPosition.RpcPorts.insecure)
}

// uint32 secure_grpc_web = 3;
inline void FlowCellPosition_RpcPorts::clear_secure_grpc_web() {
  secure_grpc_web_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FlowCellPosition_RpcPorts::_internal_secure_grpc_web() const {
  return secure_grpc_web_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FlowCellPosition_RpcPorts::secure_grpc_web() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.FlowCellPosition.RpcPorts.secure_grpc_web)
  return _internal_secure_grpc_web();
}
inline void FlowCellPosition_RpcPorts::_internal_set_secure_grpc_web(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  secure_grpc_web_ = value;
}
inline void FlowCellPosition_RpcPorts::set_secure_grpc_web(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_secure_grpc_web(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.FlowCellPosition.RpcPorts.secure_grpc_web)
}

// uint32 insecure_grpc_web = 4;
inline void FlowCellPosition_RpcPorts::clear_insecure_grpc_web() {
  insecure_grpc_web_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FlowCellPosition_RpcPorts::_internal_insecure_grpc_web() const {
  return insecure_grpc_web_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FlowCellPosition_RpcPorts::insecure_grpc_web() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.FlowCellPosition.RpcPorts.insecure_grpc_web)
  return _internal_insecure_grpc_web();
}
inline void FlowCellPosition_RpcPorts::_internal_set_insecure_grpc_web(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  insecure_grpc_web_ = value;
}
inline void FlowCellPosition_RpcPorts::set_insecure_grpc_web(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_insecure_grpc_web(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.FlowCellPosition.RpcPorts.insecure_grpc_web)
}

// -------------------------------------------------------------------

// FlowCellPosition_SharedHardwareGroup

// uint32 group_id = 1;
inline void FlowCellPosition_SharedHardwareGroup::clear_group_id() {
  group_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FlowCellPosition_SharedHardwareGroup::_internal_group_id() const {
  return group_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FlowCellPosition_SharedHardwareGroup::group_id() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.FlowCellPosition.SharedHardwareGroup.group_id)
  return _internal_group_id();
}
inline void FlowCellPosition_SharedHardwareGroup::_internal_set_group_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  group_id_ = value;
}
inline void FlowCellPosition_SharedHardwareGroup::set_group_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_group_id(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.FlowCellPosition.SharedHardwareGroup.group_id)
}

// -------------------------------------------------------------------

// FlowCellPosition

// string name = 1;
inline void FlowCellPosition::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& FlowCellPosition::name() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.FlowCellPosition.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FlowCellPosition::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.manager.FlowCellPosition.name)
}
inline std::string* FlowCellPosition::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.FlowCellPosition.name)
  return _s;
}
inline const std::string& FlowCellPosition::_internal_name() const {
  return name_.Get();
}
inline void FlowCellPosition::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FlowCellPosition::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FlowCellPosition::release_name() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.FlowCellPosition.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FlowCellPosition::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.FlowCellPosition.name)
}

// .minknow_api.manager.FlowCellPosition.Location location = 2;
inline bool FlowCellPosition::_internal_has_location() const {
  return this != internal_default_instance() && location_ != nullptr;
}
inline bool FlowCellPosition::has_location() const {
  return _internal_has_location();
}
inline void FlowCellPosition::clear_location() {
  if (GetArenaForAllocation() == nullptr && location_ != nullptr) {
    delete location_;
  }
  location_ = nullptr;
}
inline const ::minknow_api::manager::FlowCellPosition_Location& FlowCellPosition::_internal_location() const {
  const ::minknow_api::manager::FlowCellPosition_Location* p = location_;
  return p != nullptr ? *p : reinterpret_cast<const ::minknow_api::manager::FlowCellPosition_Location&>(
      ::minknow_api::manager::_FlowCellPosition_Location_default_instance_);
}
inline const ::minknow_api::manager::FlowCellPosition_Location& FlowCellPosition::location() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.FlowCellPosition.location)
  return _internal_location();
}
inline void FlowCellPosition::unsafe_arena_set_allocated_location(
    ::minknow_api::manager::FlowCellPosition_Location* location) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(location_);
  }
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minknow_api.manager.FlowCellPosition.location)
}
inline ::minknow_api::manager::FlowCellPosition_Location* FlowCellPosition::release_location() {
  
  ::minknow_api::manager::FlowCellPosition_Location* temp = location_;
  location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::minknow_api::manager::FlowCellPosition_Location* FlowCellPosition::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.FlowCellPosition.location)
  
  ::minknow_api::manager::FlowCellPosition_Location* temp = location_;
  location_ = nullptr;
  return temp;
}
inline ::minknow_api::manager::FlowCellPosition_Location* FlowCellPosition::_internal_mutable_location() {
  
  if (location_ == nullptr) {
    auto* p = CreateMaybeMessage<::minknow_api::manager::FlowCellPosition_Location>(GetArenaForAllocation());
    location_ = p;
  }
  return location_;
}
inline ::minknow_api::manager::FlowCellPosition_Location* FlowCellPosition::mutable_location() {
  ::minknow_api::manager::FlowCellPosition_Location* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.FlowCellPosition.location)
  return _msg;
}
inline void FlowCellPosition::set_allocated_location(::minknow_api::manager::FlowCellPosition_Location* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete location_;
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::minknow_api::manager::FlowCellPosition_Location>::GetOwningArena(location);
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.FlowCellPosition.location)
}

// .minknow_api.manager.FlowCellPosition.State state = 3;
inline void FlowCellPosition::clear_state() {
  state_ = 0;
}
inline ::minknow_api::manager::FlowCellPosition_State FlowCellPosition::_internal_state() const {
  return static_cast< ::minknow_api::manager::FlowCellPosition_State >(state_);
}
inline ::minknow_api::manager::FlowCellPosition_State FlowCellPosition::state() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.FlowCellPosition.state)
  return _internal_state();
}
inline void FlowCellPosition::_internal_set_state(::minknow_api::manager::FlowCellPosition_State value) {
  
  state_ = value;
}
inline void FlowCellPosition::set_state(::minknow_api::manager::FlowCellPosition_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.FlowCellPosition.state)
}

// .minknow_api.manager.FlowCellPosition.RpcPorts rpc_ports = 4;
inline bool FlowCellPosition::_internal_has_rpc_ports() const {
  return this != internal_default_instance() && rpc_ports_ != nullptr;
}
inline bool FlowCellPosition::has_rpc_ports() const {
  return _internal_has_rpc_ports();
}
inline void FlowCellPosition::clear_rpc_ports() {
  if (GetArenaForAllocation() == nullptr && rpc_ports_ != nullptr) {
    delete rpc_ports_;
  }
  rpc_ports_ = nullptr;
}
inline const ::minknow_api::manager::FlowCellPosition_RpcPorts& FlowCellPosition::_internal_rpc_ports() const {
  const ::minknow_api::manager::FlowCellPosition_RpcPorts* p = rpc_ports_;
  return p != nullptr ? *p : reinterpret_cast<const ::minknow_api::manager::FlowCellPosition_RpcPorts&>(
      ::minknow_api::manager::_FlowCellPosition_RpcPorts_default_instance_);
}
inline const ::minknow_api::manager::FlowCellPosition_RpcPorts& FlowCellPosition::rpc_ports() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.FlowCellPosition.rpc_ports)
  return _internal_rpc_ports();
}
inline void FlowCellPosition::unsafe_arena_set_allocated_rpc_ports(
    ::minknow_api::manager::FlowCellPosition_RpcPorts* rpc_ports) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rpc_ports_);
  }
  rpc_ports_ = rpc_ports;
  if (rpc_ports) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minknow_api.manager.FlowCellPosition.rpc_ports)
}
inline ::minknow_api::manager::FlowCellPosition_RpcPorts* FlowCellPosition::release_rpc_ports() {
  
  ::minknow_api::manager::FlowCellPosition_RpcPorts* temp = rpc_ports_;
  rpc_ports_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::minknow_api::manager::FlowCellPosition_RpcPorts* FlowCellPosition::unsafe_arena_release_rpc_ports() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.FlowCellPosition.rpc_ports)
  
  ::minknow_api::manager::FlowCellPosition_RpcPorts* temp = rpc_ports_;
  rpc_ports_ = nullptr;
  return temp;
}
inline ::minknow_api::manager::FlowCellPosition_RpcPorts* FlowCellPosition::_internal_mutable_rpc_ports() {
  
  if (rpc_ports_ == nullptr) {
    auto* p = CreateMaybeMessage<::minknow_api::manager::FlowCellPosition_RpcPorts>(GetArenaForAllocation());
    rpc_ports_ = p;
  }
  return rpc_ports_;
}
inline ::minknow_api::manager::FlowCellPosition_RpcPorts* FlowCellPosition::mutable_rpc_ports() {
  ::minknow_api::manager::FlowCellPosition_RpcPorts* _msg = _internal_mutable_rpc_ports();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.FlowCellPosition.rpc_ports)
  return _msg;
}
inline void FlowCellPosition::set_allocated_rpc_ports(::minknow_api::manager::FlowCellPosition_RpcPorts* rpc_ports) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rpc_ports_;
  }
  if (rpc_ports) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::minknow_api::manager::FlowCellPosition_RpcPorts>::GetOwningArena(rpc_ports);
    if (message_arena != submessage_arena) {
      rpc_ports = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rpc_ports, submessage_arena);
    }
    
  } else {
    
  }
  rpc_ports_ = rpc_ports;
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.FlowCellPosition.rpc_ports)
}

// string error_info = 5;
inline void FlowCellPosition::clear_error_info() {
  error_info_.ClearToEmpty();
}
inline const std::string& FlowCellPosition::error_info() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.FlowCellPosition.error_info)
  return _internal_error_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FlowCellPosition::set_error_info(ArgT0&& arg0, ArgT... args) {
 
 error_info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.manager.FlowCellPosition.error_info)
}
inline std::string* FlowCellPosition::mutable_error_info() {
  std::string* _s = _internal_mutable_error_info();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.FlowCellPosition.error_info)
  return _s;
}
inline const std::string& FlowCellPosition::_internal_error_info() const {
  return error_info_.Get();
}
inline void FlowCellPosition::_internal_set_error_info(const std::string& value) {
  
  error_info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FlowCellPosition::_internal_mutable_error_info() {
  
  return error_info_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FlowCellPosition::release_error_info() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.FlowCellPosition.error_info)
  return error_info_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FlowCellPosition::set_allocated_error_info(std::string* error_info) {
  if (error_info != nullptr) {
    
  } else {
    
  }
  error_info_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_info,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.FlowCellPosition.error_info)
}

// .minknow_api.manager.FlowCellPosition.SharedHardwareGroup shared_hardware_group = 6;
inline bool FlowCellPosition::_internal_has_shared_hardware_group() const {
  return this != internal_default_instance() && shared_hardware_group_ != nullptr;
}
inline bool FlowCellPosition::has_shared_hardware_group() const {
  return _internal_has_shared_hardware_group();
}
inline void FlowCellPosition::clear_shared_hardware_group() {
  if (GetArenaForAllocation() == nullptr && shared_hardware_group_ != nullptr) {
    delete shared_hardware_group_;
  }
  shared_hardware_group_ = nullptr;
}
inline const ::minknow_api::manager::FlowCellPosition_SharedHardwareGroup& FlowCellPosition::_internal_shared_hardware_group() const {
  const ::minknow_api::manager::FlowCellPosition_SharedHardwareGroup* p = shared_hardware_group_;
  return p != nullptr ? *p : reinterpret_cast<const ::minknow_api::manager::FlowCellPosition_SharedHardwareGroup&>(
      ::minknow_api::manager::_FlowCellPosition_SharedHardwareGroup_default_instance_);
}
inline const ::minknow_api::manager::FlowCellPosition_SharedHardwareGroup& FlowCellPosition::shared_hardware_group() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.FlowCellPosition.shared_hardware_group)
  return _internal_shared_hardware_group();
}
inline void FlowCellPosition::unsafe_arena_set_allocated_shared_hardware_group(
    ::minknow_api::manager::FlowCellPosition_SharedHardwareGroup* shared_hardware_group) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(shared_hardware_group_);
  }
  shared_hardware_group_ = shared_hardware_group;
  if (shared_hardware_group) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minknow_api.manager.FlowCellPosition.shared_hardware_group)
}
inline ::minknow_api::manager::FlowCellPosition_SharedHardwareGroup* FlowCellPosition::release_shared_hardware_group() {
  
  ::minknow_api::manager::FlowCellPosition_SharedHardwareGroup* temp = shared_hardware_group_;
  shared_hardware_group_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::minknow_api::manager::FlowCellPosition_SharedHardwareGroup* FlowCellPosition::unsafe_arena_release_shared_hardware_group() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.FlowCellPosition.shared_hardware_group)
  
  ::minknow_api::manager::FlowCellPosition_SharedHardwareGroup* temp = shared_hardware_group_;
  shared_hardware_group_ = nullptr;
  return temp;
}
inline ::minknow_api::manager::FlowCellPosition_SharedHardwareGroup* FlowCellPosition::_internal_mutable_shared_hardware_group() {
  
  if (shared_hardware_group_ == nullptr) {
    auto* p = CreateMaybeMessage<::minknow_api::manager::FlowCellPosition_SharedHardwareGroup>(GetArenaForAllocation());
    shared_hardware_group_ = p;
  }
  return shared_hardware_group_;
}
inline ::minknow_api::manager::FlowCellPosition_SharedHardwareGroup* FlowCellPosition::mutable_shared_hardware_group() {
  ::minknow_api::manager::FlowCellPosition_SharedHardwareGroup* _msg = _internal_mutable_shared_hardware_group();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.FlowCellPosition.shared_hardware_group)
  return _msg;
}
inline void FlowCellPosition::set_allocated_shared_hardware_group(::minknow_api::manager::FlowCellPosition_SharedHardwareGroup* shared_hardware_group) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete shared_hardware_group_;
  }
  if (shared_hardware_group) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::minknow_api::manager::FlowCellPosition_SharedHardwareGroup>::GetOwningArena(shared_hardware_group);
    if (message_arena != submessage_arena) {
      shared_hardware_group = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shared_hardware_group, submessage_arena);
    }
    
  } else {
    
  }
  shared_hardware_group_ = shared_hardware_group;
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.FlowCellPosition.shared_hardware_group)
}

// bool is_integrated = 7;
inline void FlowCellPosition::clear_is_integrated() {
  is_integrated_ = false;
}
inline bool FlowCellPosition::_internal_is_integrated() const {
  return is_integrated_;
}
inline bool FlowCellPosition::is_integrated() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.FlowCellPosition.is_integrated)
  return _internal_is_integrated();
}
inline void FlowCellPosition::_internal_set_is_integrated(bool value) {
  
  is_integrated_ = value;
}
inline void FlowCellPosition::set_is_integrated(bool value) {
  _internal_set_is_integrated(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.FlowCellPosition.is_integrated)
}

// bool can_sequence_offline = 8;
inline void FlowCellPosition::clear_can_sequence_offline() {
  can_sequence_offline_ = false;
}
inline bool FlowCellPosition::_internal_can_sequence_offline() const {
  return can_sequence_offline_;
}
inline bool FlowCellPosition::can_sequence_offline() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.FlowCellPosition.can_sequence_offline)
  return _internal_can_sequence_offline();
}
inline void FlowCellPosition::_internal_set_can_sequence_offline(bool value) {
  
  can_sequence_offline_ = value;
}
inline void FlowCellPosition::set_can_sequence_offline(bool value) {
  _internal_set_can_sequence_offline(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.FlowCellPosition.can_sequence_offline)
}

// -------------------------------------------------------------------

// FlowCellPositionsRequest

// -------------------------------------------------------------------

// FlowCellPositionsResponse

// int32 total_count = 1;
inline void FlowCellPositionsResponse::clear_total_count() {
  total_count_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FlowCellPositionsResponse::_internal_total_count() const {
  return total_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FlowCellPositionsResponse::total_count() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.FlowCellPositionsResponse.total_count)
  return _internal_total_count();
}
inline void FlowCellPositionsResponse::_internal_set_total_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  total_count_ = value;
}
inline void FlowCellPositionsResponse::set_total_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_total_count(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.FlowCellPositionsResponse.total_count)
}

// repeated .minknow_api.manager.FlowCellPosition positions = 2;
inline int FlowCellPositionsResponse::_internal_positions_size() const {
  return positions_.size();
}
inline int FlowCellPositionsResponse::positions_size() const {
  return _internal_positions_size();
}
inline void FlowCellPositionsResponse::clear_positions() {
  positions_.Clear();
}
inline ::minknow_api::manager::FlowCellPosition* FlowCellPositionsResponse::mutable_positions(int index) {
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.FlowCellPositionsResponse.positions)
  return positions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::FlowCellPosition >*
FlowCellPositionsResponse::mutable_positions() {
  // @@protoc_insertion_point(field_mutable_list:minknow_api.manager.FlowCellPositionsResponse.positions)
  return &positions_;
}
inline const ::minknow_api::manager::FlowCellPosition& FlowCellPositionsResponse::_internal_positions(int index) const {
  return positions_.Get(index);
}
inline const ::minknow_api::manager::FlowCellPosition& FlowCellPositionsResponse::positions(int index) const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.FlowCellPositionsResponse.positions)
  return _internal_positions(index);
}
inline ::minknow_api::manager::FlowCellPosition* FlowCellPositionsResponse::_internal_add_positions() {
  return positions_.Add();
}
inline ::minknow_api::manager::FlowCellPosition* FlowCellPositionsResponse::add_positions() {
  ::minknow_api::manager::FlowCellPosition* _add = _internal_add_positions();
  // @@protoc_insertion_point(field_add:minknow_api.manager.FlowCellPositionsResponse.positions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::FlowCellPosition >&
FlowCellPositionsResponse::positions() const {
  // @@protoc_insertion_point(field_list:minknow_api.manager.FlowCellPositionsResponse.positions)
  return positions_;
}

// -------------------------------------------------------------------

// WatchFlowCellPositionsRequest

// -------------------------------------------------------------------

// WatchFlowCellPositionsResponse

// repeated .minknow_api.manager.FlowCellPosition additions = 1;
inline int WatchFlowCellPositionsResponse::_internal_additions_size() const {
  return additions_.size();
}
inline int WatchFlowCellPositionsResponse::additions_size() const {
  return _internal_additions_size();
}
inline void WatchFlowCellPositionsResponse::clear_additions() {
  additions_.Clear();
}
inline ::minknow_api::manager::FlowCellPosition* WatchFlowCellPositionsResponse::mutable_additions(int index) {
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.WatchFlowCellPositionsResponse.additions)
  return additions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::FlowCellPosition >*
WatchFlowCellPositionsResponse::mutable_additions() {
  // @@protoc_insertion_point(field_mutable_list:minknow_api.manager.WatchFlowCellPositionsResponse.additions)
  return &additions_;
}
inline const ::minknow_api::manager::FlowCellPosition& WatchFlowCellPositionsResponse::_internal_additions(int index) const {
  return additions_.Get(index);
}
inline const ::minknow_api::manager::FlowCellPosition& WatchFlowCellPositionsResponse::additions(int index) const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.WatchFlowCellPositionsResponse.additions)
  return _internal_additions(index);
}
inline ::minknow_api::manager::FlowCellPosition* WatchFlowCellPositionsResponse::_internal_add_additions() {
  return additions_.Add();
}
inline ::minknow_api::manager::FlowCellPosition* WatchFlowCellPositionsResponse::add_additions() {
  ::minknow_api::manager::FlowCellPosition* _add = _internal_add_additions();
  // @@protoc_insertion_point(field_add:minknow_api.manager.WatchFlowCellPositionsResponse.additions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::FlowCellPosition >&
WatchFlowCellPositionsResponse::additions() const {
  // @@protoc_insertion_point(field_list:minknow_api.manager.WatchFlowCellPositionsResponse.additions)
  return additions_;
}

// repeated .minknow_api.manager.FlowCellPosition changes = 2;
inline int WatchFlowCellPositionsResponse::_internal_changes_size() const {
  return changes_.size();
}
inline int WatchFlowCellPositionsResponse::changes_size() const {
  return _internal_changes_size();
}
inline void WatchFlowCellPositionsResponse::clear_changes() {
  changes_.Clear();
}
inline ::minknow_api::manager::FlowCellPosition* WatchFlowCellPositionsResponse::mutable_changes(int index) {
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.WatchFlowCellPositionsResponse.changes)
  return changes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::FlowCellPosition >*
WatchFlowCellPositionsResponse::mutable_changes() {
  // @@protoc_insertion_point(field_mutable_list:minknow_api.manager.WatchFlowCellPositionsResponse.changes)
  return &changes_;
}
inline const ::minknow_api::manager::FlowCellPosition& WatchFlowCellPositionsResponse::_internal_changes(int index) const {
  return changes_.Get(index);
}
inline const ::minknow_api::manager::FlowCellPosition& WatchFlowCellPositionsResponse::changes(int index) const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.WatchFlowCellPositionsResponse.changes)
  return _internal_changes(index);
}
inline ::minknow_api::manager::FlowCellPosition* WatchFlowCellPositionsResponse::_internal_add_changes() {
  return changes_.Add();
}
inline ::minknow_api::manager::FlowCellPosition* WatchFlowCellPositionsResponse::add_changes() {
  ::minknow_api::manager::FlowCellPosition* _add = _internal_add_changes();
  // @@protoc_insertion_point(field_add:minknow_api.manager.WatchFlowCellPositionsResponse.changes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::FlowCellPosition >&
WatchFlowCellPositionsResponse::changes() const {
  // @@protoc_insertion_point(field_list:minknow_api.manager.WatchFlowCellPositionsResponse.changes)
  return changes_;
}

// repeated string removals = 3;
inline int WatchFlowCellPositionsResponse::_internal_removals_size() const {
  return removals_.size();
}
inline int WatchFlowCellPositionsResponse::removals_size() const {
  return _internal_removals_size();
}
inline void WatchFlowCellPositionsResponse::clear_removals() {
  removals_.Clear();
}
inline std::string* WatchFlowCellPositionsResponse::add_removals() {
  std::string* _s = _internal_add_removals();
  // @@protoc_insertion_point(field_add_mutable:minknow_api.manager.WatchFlowCellPositionsResponse.removals)
  return _s;
}
inline const std::string& WatchFlowCellPositionsResponse::_internal_removals(int index) const {
  return removals_.Get(index);
}
inline const std::string& WatchFlowCellPositionsResponse::removals(int index) const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.WatchFlowCellPositionsResponse.removals)
  return _internal_removals(index);
}
inline std::string* WatchFlowCellPositionsResponse::mutable_removals(int index) {
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.WatchFlowCellPositionsResponse.removals)
  return removals_.Mutable(index);
}
inline void WatchFlowCellPositionsResponse::set_removals(int index, const std::string& value) {
  removals_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.WatchFlowCellPositionsResponse.removals)
}
inline void WatchFlowCellPositionsResponse::set_removals(int index, std::string&& value) {
  removals_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:minknow_api.manager.WatchFlowCellPositionsResponse.removals)
}
inline void WatchFlowCellPositionsResponse::set_removals(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  removals_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:minknow_api.manager.WatchFlowCellPositionsResponse.removals)
}
inline void WatchFlowCellPositionsResponse::set_removals(int index, const char* value, size_t size) {
  removals_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:minknow_api.manager.WatchFlowCellPositionsResponse.removals)
}
inline std::string* WatchFlowCellPositionsResponse::_internal_add_removals() {
  return removals_.Add();
}
inline void WatchFlowCellPositionsResponse::add_removals(const std::string& value) {
  removals_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:minknow_api.manager.WatchFlowCellPositionsResponse.removals)
}
inline void WatchFlowCellPositionsResponse::add_removals(std::string&& value) {
  removals_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:minknow_api.manager.WatchFlowCellPositionsResponse.removals)
}
inline void WatchFlowCellPositionsResponse::add_removals(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  removals_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:minknow_api.manager.WatchFlowCellPositionsResponse.removals)
}
inline void WatchFlowCellPositionsResponse::add_removals(const char* value, size_t size) {
  removals_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:minknow_api.manager.WatchFlowCellPositionsResponse.removals)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
WatchFlowCellPositionsResponse::removals() const {
  // @@protoc_insertion_point(field_list:minknow_api.manager.WatchFlowCellPositionsResponse.removals)
  return removals_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
WatchFlowCellPositionsResponse::mutable_removals() {
  // @@protoc_insertion_point(field_mutable_list:minknow_api.manager.WatchFlowCellPositionsResponse.removals)
  return &removals_;
}

// -------------------------------------------------------------------

// ResetPositionRequest

// repeated string positions = 3;
inline int ResetPositionRequest::_internal_positions_size() const {
  return positions_.size();
}
inline int ResetPositionRequest::positions_size() const {
  return _internal_positions_size();
}
inline void ResetPositionRequest::clear_positions() {
  positions_.Clear();
}
inline std::string* ResetPositionRequest::add_positions() {
  std::string* _s = _internal_add_positions();
  // @@protoc_insertion_point(field_add_mutable:minknow_api.manager.ResetPositionRequest.positions)
  return _s;
}
inline const std::string& ResetPositionRequest::_internal_positions(int index) const {
  return positions_.Get(index);
}
inline const std::string& ResetPositionRequest::positions(int index) const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.ResetPositionRequest.positions)
  return _internal_positions(index);
}
inline std::string* ResetPositionRequest::mutable_positions(int index) {
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.ResetPositionRequest.positions)
  return positions_.Mutable(index);
}
inline void ResetPositionRequest::set_positions(int index, const std::string& value) {
  positions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.ResetPositionRequest.positions)
}
inline void ResetPositionRequest::set_positions(int index, std::string&& value) {
  positions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:minknow_api.manager.ResetPositionRequest.positions)
}
inline void ResetPositionRequest::set_positions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  positions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:minknow_api.manager.ResetPositionRequest.positions)
}
inline void ResetPositionRequest::set_positions(int index, const char* value, size_t size) {
  positions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:minknow_api.manager.ResetPositionRequest.positions)
}
inline std::string* ResetPositionRequest::_internal_add_positions() {
  return positions_.Add();
}
inline void ResetPositionRequest::add_positions(const std::string& value) {
  positions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:minknow_api.manager.ResetPositionRequest.positions)
}
inline void ResetPositionRequest::add_positions(std::string&& value) {
  positions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:minknow_api.manager.ResetPositionRequest.positions)
}
inline void ResetPositionRequest::add_positions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  positions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:minknow_api.manager.ResetPositionRequest.positions)
}
inline void ResetPositionRequest::add_positions(const char* value, size_t size) {
  positions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:minknow_api.manager.ResetPositionRequest.positions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ResetPositionRequest::positions() const {
  // @@protoc_insertion_point(field_list:minknow_api.manager.ResetPositionRequest.positions)
  return positions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ResetPositionRequest::mutable_positions() {
  // @@protoc_insertion_point(field_mutable_list:minknow_api.manager.ResetPositionRequest.positions)
  return &positions_;
}

// bool force = 2;
inline void ResetPositionRequest::clear_force() {
  force_ = false;
}
inline bool ResetPositionRequest::_internal_force() const {
  return force_;
}
inline bool ResetPositionRequest::force() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.ResetPositionRequest.force)
  return _internal_force();
}
inline void ResetPositionRequest::_internal_set_force(bool value) {
  
  force_ = value;
}
inline void ResetPositionRequest::set_force(bool value) {
  _internal_set_force(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.ResetPositionRequest.force)
}

// -------------------------------------------------------------------

// ResetPositionResponse

// -------------------------------------------------------------------

// BasecallerApiRequest

// -------------------------------------------------------------------

// BasecallerApiResponse

// uint32 secure = 1;
inline void BasecallerApiResponse::clear_secure() {
  secure_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BasecallerApiResponse::_internal_secure() const {
  return secure_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BasecallerApiResponse::secure() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.BasecallerApiResponse.secure)
  return _internal_secure();
}
inline void BasecallerApiResponse::_internal_set_secure(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  secure_ = value;
}
inline void BasecallerApiResponse::set_secure(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_secure(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.BasecallerApiResponse.secure)
}

// uint32 insecure = 2;
inline void BasecallerApiResponse::clear_insecure() {
  insecure_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BasecallerApiResponse::_internal_insecure() const {
  return insecure_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BasecallerApiResponse::insecure() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.BasecallerApiResponse.insecure)
  return _internal_insecure();
}
inline void BasecallerApiResponse::_internal_set_insecure(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  insecure_ = value;
}
inline void BasecallerApiResponse::set_insecure(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_insecure(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.BasecallerApiResponse.insecure)
}

// uint32 secure_grpc_web = 3;
inline void BasecallerApiResponse::clear_secure_grpc_web() {
  secure_grpc_web_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BasecallerApiResponse::_internal_secure_grpc_web() const {
  return secure_grpc_web_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BasecallerApiResponse::secure_grpc_web() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.BasecallerApiResponse.secure_grpc_web)
  return _internal_secure_grpc_web();
}
inline void BasecallerApiResponse::_internal_set_secure_grpc_web(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  secure_grpc_web_ = value;
}
inline void BasecallerApiResponse::set_secure_grpc_web(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_secure_grpc_web(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.BasecallerApiResponse.secure_grpc_web)
}

// uint32 insecure_grpc_web = 4;
inline void BasecallerApiResponse::clear_insecure_grpc_web() {
  insecure_grpc_web_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BasecallerApiResponse::_internal_insecure_grpc_web() const {
  return insecure_grpc_web_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BasecallerApiResponse::insecure_grpc_web() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.BasecallerApiResponse.insecure_grpc_web)
  return _internal_insecure_grpc_web();
}
inline void BasecallerApiResponse::_internal_set_insecure_grpc_web(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  insecure_grpc_web_ = value;
}
inline void BasecallerApiResponse::set_insecure_grpc_web(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_insecure_grpc_web(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.BasecallerApiResponse.insecure_grpc_web)
}

// -------------------------------------------------------------------

// GetGuppyInfoRequest

// -------------------------------------------------------------------

// GetGuppyInfoResponse

// uint32 port = 1;
inline void GetGuppyInfoResponse::clear_port() {
  port_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetGuppyInfoResponse::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetGuppyInfoResponse::port() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetGuppyInfoResponse.port)
  return _internal_port();
}
inline void GetGuppyInfoResponse::_internal_set_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  port_ = value;
}
inline void GetGuppyInfoResponse::set_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetGuppyInfoResponse.port)
}

// string version = 2;
inline void GetGuppyInfoResponse::clear_version() {
  version_.ClearToEmpty();
}
inline const std::string& GetGuppyInfoResponse::version() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetGuppyInfoResponse.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetGuppyInfoResponse::set_version(ArgT0&& arg0, ArgT... args) {
 
 version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetGuppyInfoResponse.version)
}
inline std::string* GetGuppyInfoResponse::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.GetGuppyInfoResponse.version)
  return _s;
}
inline const std::string& GetGuppyInfoResponse::_internal_version() const {
  return version_.Get();
}
inline void GetGuppyInfoResponse::_internal_set_version(const std::string& value) {
  
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetGuppyInfoResponse::_internal_mutable_version() {
  
  return version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetGuppyInfoResponse::release_version() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.GetGuppyInfoResponse.version)
  return version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetGuppyInfoResponse::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.GetGuppyInfoResponse.version)
}

// -------------------------------------------------------------------

// GetVersionInfoRequest

// -------------------------------------------------------------------

// GetVersionInfoResponse

// .minknow_api.instance.GetVersionInfoResponse.MinknowVersion minknow = 1;
inline bool GetVersionInfoResponse::_internal_has_minknow() const {
  return this != internal_default_instance() && minknow_ != nullptr;
}
inline bool GetVersionInfoResponse::has_minknow() const {
  return _internal_has_minknow();
}
inline const ::minknow_api::instance::GetVersionInfoResponse_MinknowVersion& GetVersionInfoResponse::_internal_minknow() const {
  const ::minknow_api::instance::GetVersionInfoResponse_MinknowVersion* p = minknow_;
  return p != nullptr ? *p : reinterpret_cast<const ::minknow_api::instance::GetVersionInfoResponse_MinknowVersion&>(
      ::minknow_api::instance::_GetVersionInfoResponse_MinknowVersion_default_instance_);
}
inline const ::minknow_api::instance::GetVersionInfoResponse_MinknowVersion& GetVersionInfoResponse::minknow() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetVersionInfoResponse.minknow)
  return _internal_minknow();
}
inline void GetVersionInfoResponse::unsafe_arena_set_allocated_minknow(
    ::minknow_api::instance::GetVersionInfoResponse_MinknowVersion* minknow) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(minknow_);
  }
  minknow_ = minknow;
  if (minknow) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minknow_api.manager.GetVersionInfoResponse.minknow)
}
inline ::minknow_api::instance::GetVersionInfoResponse_MinknowVersion* GetVersionInfoResponse::release_minknow() {
  
  ::minknow_api::instance::GetVersionInfoResponse_MinknowVersion* temp = minknow_;
  minknow_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::minknow_api::instance::GetVersionInfoResponse_MinknowVersion* GetVersionInfoResponse::unsafe_arena_release_minknow() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.GetVersionInfoResponse.minknow)
  
  ::minknow_api::instance::GetVersionInfoResponse_MinknowVersion* temp = minknow_;
  minknow_ = nullptr;
  return temp;
}
inline ::minknow_api::instance::GetVersionInfoResponse_MinknowVersion* GetVersionInfoResponse::_internal_mutable_minknow() {
  
  if (minknow_ == nullptr) {
    auto* p = CreateMaybeMessage<::minknow_api::instance::GetVersionInfoResponse_MinknowVersion>(GetArenaForAllocation());
    minknow_ = p;
  }
  return minknow_;
}
inline ::minknow_api::instance::GetVersionInfoResponse_MinknowVersion* GetVersionInfoResponse::mutable_minknow() {
  ::minknow_api::instance::GetVersionInfoResponse_MinknowVersion* _msg = _internal_mutable_minknow();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.GetVersionInfoResponse.minknow)
  return _msg;
}
inline void GetVersionInfoResponse::set_allocated_minknow(::minknow_api::instance::GetVersionInfoResponse_MinknowVersion* minknow) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(minknow_);
  }
  if (minknow) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(minknow));
    if (message_arena != submessage_arena) {
      minknow = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, minknow, submessage_arena);
    }
    
  } else {
    
  }
  minknow_ = minknow;
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.GetVersionInfoResponse.minknow)
}

// string protocols = 2;
inline void GetVersionInfoResponse::clear_protocols() {
  protocols_.ClearToEmpty();
}
inline const std::string& GetVersionInfoResponse::protocols() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetVersionInfoResponse.protocols)
  return _internal_protocols();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetVersionInfoResponse::set_protocols(ArgT0&& arg0, ArgT... args) {
 
 protocols_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetVersionInfoResponse.protocols)
}
inline std::string* GetVersionInfoResponse::mutable_protocols() {
  std::string* _s = _internal_mutable_protocols();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.GetVersionInfoResponse.protocols)
  return _s;
}
inline const std::string& GetVersionInfoResponse::_internal_protocols() const {
  return protocols_.Get();
}
inline void GetVersionInfoResponse::_internal_set_protocols(const std::string& value) {
  
  protocols_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetVersionInfoResponse::_internal_mutable_protocols() {
  
  return protocols_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetVersionInfoResponse::release_protocols() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.GetVersionInfoResponse.protocols)
  return protocols_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetVersionInfoResponse::set_allocated_protocols(std::string* protocols) {
  if (protocols != nullptr) {
    
  } else {
    
  }
  protocols_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), protocols,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.GetVersionInfoResponse.protocols)
}

// string distribution_version = 3;
inline void GetVersionInfoResponse::clear_distribution_version() {
  distribution_version_.ClearToEmpty();
}
inline const std::string& GetVersionInfoResponse::distribution_version() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetVersionInfoResponse.distribution_version)
  return _internal_distribution_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetVersionInfoResponse::set_distribution_version(ArgT0&& arg0, ArgT... args) {
 
 distribution_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetVersionInfoResponse.distribution_version)
}
inline std::string* GetVersionInfoResponse::mutable_distribution_version() {
  std::string* _s = _internal_mutable_distribution_version();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.GetVersionInfoResponse.distribution_version)
  return _s;
}
inline const std::string& GetVersionInfoResponse::_internal_distribution_version() const {
  return distribution_version_.Get();
}
inline void GetVersionInfoResponse::_internal_set_distribution_version(const std::string& value) {
  
  distribution_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetVersionInfoResponse::_internal_mutable_distribution_version() {
  
  return distribution_version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetVersionInfoResponse::release_distribution_version() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.GetVersionInfoResponse.distribution_version)
  return distribution_version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetVersionInfoResponse::set_allocated_distribution_version(std::string* distribution_version) {
  if (distribution_version != nullptr) {
    
  } else {
    
  }
  distribution_version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), distribution_version,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.GetVersionInfoResponse.distribution_version)
}

// .minknow_api.instance.GetVersionInfoResponse.DistributionStatus distribution_status = 4;
inline void GetVersionInfoResponse::clear_distribution_status() {
  distribution_status_ = 0;
}
inline ::minknow_api::instance::GetVersionInfoResponse_DistributionStatus GetVersionInfoResponse::_internal_distribution_status() const {
  return static_cast< ::minknow_api::instance::GetVersionInfoResponse_DistributionStatus >(distribution_status_);
}
inline ::minknow_api::instance::GetVersionInfoResponse_DistributionStatus GetVersionInfoResponse::distribution_status() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetVersionInfoResponse.distribution_status)
  return _internal_distribution_status();
}
inline void GetVersionInfoResponse::_internal_set_distribution_status(::minknow_api::instance::GetVersionInfoResponse_DistributionStatus value) {
  
  distribution_status_ = value;
}
inline void GetVersionInfoResponse::set_distribution_status(::minknow_api::instance::GetVersionInfoResponse_DistributionStatus value) {
  _internal_set_distribution_status(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetVersionInfoResponse.distribution_status)
}

// string guppy_build_version = 5;
inline void GetVersionInfoResponse::clear_guppy_build_version() {
  guppy_build_version_.ClearToEmpty();
}
inline const std::string& GetVersionInfoResponse::guppy_build_version() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetVersionInfoResponse.guppy_build_version)
  return _internal_guppy_build_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetVersionInfoResponse::set_guppy_build_version(ArgT0&& arg0, ArgT... args) {
 
 guppy_build_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetVersionInfoResponse.guppy_build_version)
}
inline std::string* GetVersionInfoResponse::mutable_guppy_build_version() {
  std::string* _s = _internal_mutable_guppy_build_version();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.GetVersionInfoResponse.guppy_build_version)
  return _s;
}
inline const std::string& GetVersionInfoResponse::_internal_guppy_build_version() const {
  return guppy_build_version_.Get();
}
inline void GetVersionInfoResponse::_internal_set_guppy_build_version(const std::string& value) {
  
  guppy_build_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetVersionInfoResponse::_internal_mutable_guppy_build_version() {
  
  return guppy_build_version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetVersionInfoResponse::release_guppy_build_version() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.GetVersionInfoResponse.guppy_build_version)
  return guppy_build_version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetVersionInfoResponse::set_allocated_guppy_build_version(std::string* guppy_build_version) {
  if (guppy_build_version != nullptr) {
    
  } else {
    
  }
  guppy_build_version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), guppy_build_version,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.GetVersionInfoResponse.guppy_build_version)
}

// string guppy_connected_version = 6;
inline void GetVersionInfoResponse::clear_guppy_connected_version() {
  guppy_connected_version_.ClearToEmpty();
}
inline const std::string& GetVersionInfoResponse::guppy_connected_version() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetVersionInfoResponse.guppy_connected_version)
  return _internal_guppy_connected_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetVersionInfoResponse::set_guppy_connected_version(ArgT0&& arg0, ArgT... args) {
 
 guppy_connected_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetVersionInfoResponse.guppy_connected_version)
}
inline std::string* GetVersionInfoResponse::mutable_guppy_connected_version() {
  std::string* _s = _internal_mutable_guppy_connected_version();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.GetVersionInfoResponse.guppy_connected_version)
  return _s;
}
inline const std::string& GetVersionInfoResponse::_internal_guppy_connected_version() const {
  return guppy_connected_version_.Get();
}
inline void GetVersionInfoResponse::_internal_set_guppy_connected_version(const std::string& value) {
  
  guppy_connected_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetVersionInfoResponse::_internal_mutable_guppy_connected_version() {
  
  return guppy_connected_version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetVersionInfoResponse::release_guppy_connected_version() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.GetVersionInfoResponse.guppy_connected_version)
  return guppy_connected_version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetVersionInfoResponse::set_allocated_guppy_connected_version(std::string* guppy_connected_version) {
  if (guppy_connected_version != nullptr) {
    
  } else {
    
  }
  guppy_connected_version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), guppy_connected_version,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.GetVersionInfoResponse.guppy_connected_version)
}

// string configuration = 7;
inline void GetVersionInfoResponse::clear_configuration() {
  configuration_.ClearToEmpty();
}
inline const std::string& GetVersionInfoResponse::configuration() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetVersionInfoResponse.configuration)
  return _internal_configuration();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetVersionInfoResponse::set_configuration(ArgT0&& arg0, ArgT... args) {
 
 configuration_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetVersionInfoResponse.configuration)
}
inline std::string* GetVersionInfoResponse::mutable_configuration() {
  std::string* _s = _internal_mutable_configuration();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.GetVersionInfoResponse.configuration)
  return _s;
}
inline const std::string& GetVersionInfoResponse::_internal_configuration() const {
  return configuration_.Get();
}
inline void GetVersionInfoResponse::_internal_set_configuration(const std::string& value) {
  
  configuration_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetVersionInfoResponse::_internal_mutable_configuration() {
  
  return configuration_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetVersionInfoResponse::release_configuration() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.GetVersionInfoResponse.configuration)
  return configuration_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetVersionInfoResponse::set_allocated_configuration(std::string* configuration) {
  if (configuration != nullptr) {
    
  } else {
    
  }
  configuration_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), configuration,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.GetVersionInfoResponse.configuration)
}

// .minknow_api.manager.GetVersionInfoResponse.InstallationType installation_type = 8;
inline void GetVersionInfoResponse::clear_installation_type() {
  installation_type_ = 0;
}
inline ::minknow_api::manager::GetVersionInfoResponse_InstallationType GetVersionInfoResponse::_internal_installation_type() const {
  return static_cast< ::minknow_api::manager::GetVersionInfoResponse_InstallationType >(installation_type_);
}
inline ::minknow_api::manager::GetVersionInfoResponse_InstallationType GetVersionInfoResponse::installation_type() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetVersionInfoResponse.installation_type)
  return _internal_installation_type();
}
inline void GetVersionInfoResponse::_internal_set_installation_type(::minknow_api::manager::GetVersionInfoResponse_InstallationType value) {
  
  installation_type_ = value;
}
inline void GetVersionInfoResponse::set_installation_type(::minknow_api::manager::GetVersionInfoResponse_InstallationType value) {
  _internal_set_installation_type(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetVersionInfoResponse.installation_type)
}

// -------------------------------------------------------------------

// ListProtocolOutputDirFilesRequest

// string path = 1;
inline void ListProtocolOutputDirFilesRequest::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& ListProtocolOutputDirFilesRequest::path() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.ListProtocolOutputDirFilesRequest.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListProtocolOutputDirFilesRequest::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.manager.ListProtocolOutputDirFilesRequest.path)
}
inline std::string* ListProtocolOutputDirFilesRequest::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.ListProtocolOutputDirFilesRequest.path)
  return _s;
}
inline const std::string& ListProtocolOutputDirFilesRequest::_internal_path() const {
  return path_.Get();
}
inline void ListProtocolOutputDirFilesRequest::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListProtocolOutputDirFilesRequest::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListProtocolOutputDirFilesRequest::release_path() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.ListProtocolOutputDirFilesRequest.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListProtocolOutputDirFilesRequest::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.ListProtocolOutputDirFilesRequest.path)
}

// -------------------------------------------------------------------

// ListProtocolOutputDirFilesResponse_DirectoryInfo

// string name = 1;
inline void ListProtocolOutputDirFilesResponse_DirectoryInfo::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ListProtocolOutputDirFilesResponse_DirectoryInfo::name() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.ListProtocolOutputDirFilesResponse.DirectoryInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListProtocolOutputDirFilesResponse_DirectoryInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.manager.ListProtocolOutputDirFilesResponse.DirectoryInfo.name)
}
inline std::string* ListProtocolOutputDirFilesResponse_DirectoryInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.ListProtocolOutputDirFilesResponse.DirectoryInfo.name)
  return _s;
}
inline const std::string& ListProtocolOutputDirFilesResponse_DirectoryInfo::_internal_name() const {
  return name_.Get();
}
inline void ListProtocolOutputDirFilesResponse_DirectoryInfo::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListProtocolOutputDirFilesResponse_DirectoryInfo::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListProtocolOutputDirFilesResponse_DirectoryInfo::release_name() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.ListProtocolOutputDirFilesResponse.DirectoryInfo.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListProtocolOutputDirFilesResponse_DirectoryInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.ListProtocolOutputDirFilesResponse.DirectoryInfo.name)
}

// int32 directory_count = 2;
inline void ListProtocolOutputDirFilesResponse_DirectoryInfo::clear_directory_count() {
  directory_count_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ListProtocolOutputDirFilesResponse_DirectoryInfo::_internal_directory_count() const {
  return directory_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ListProtocolOutputDirFilesResponse_DirectoryInfo::directory_count() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.ListProtocolOutputDirFilesResponse.DirectoryInfo.directory_count)
  return _internal_directory_count();
}
inline void ListProtocolOutputDirFilesResponse_DirectoryInfo::_internal_set_directory_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  directory_count_ = value;
}
inline void ListProtocolOutputDirFilesResponse_DirectoryInfo::set_directory_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_directory_count(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.ListProtocolOutputDirFilesResponse.DirectoryInfo.directory_count)
}

// int32 file_count = 3;
inline void ListProtocolOutputDirFilesResponse_DirectoryInfo::clear_file_count() {
  file_count_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ListProtocolOutputDirFilesResponse_DirectoryInfo::_internal_file_count() const {
  return file_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ListProtocolOutputDirFilesResponse_DirectoryInfo::file_count() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.ListProtocolOutputDirFilesResponse.DirectoryInfo.file_count)
  return _internal_file_count();
}
inline void ListProtocolOutputDirFilesResponse_DirectoryInfo::_internal_set_file_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  file_count_ = value;
}
inline void ListProtocolOutputDirFilesResponse_DirectoryInfo::set_file_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_file_count(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.ListProtocolOutputDirFilesResponse.DirectoryInfo.file_count)
}

// -------------------------------------------------------------------

// ListProtocolOutputDirFilesResponse

// repeated .minknow_api.manager.ListProtocolOutputDirFilesResponse.DirectoryInfo directories = 1;
inline int ListProtocolOutputDirFilesResponse::_internal_directories_size() const {
  return directories_.size();
}
inline int ListProtocolOutputDirFilesResponse::directories_size() const {
  return _internal_directories_size();
}
inline void ListProtocolOutputDirFilesResponse::clear_directories() {
  directories_.Clear();
}
inline ::minknow_api::manager::ListProtocolOutputDirFilesResponse_DirectoryInfo* ListProtocolOutputDirFilesResponse::mutable_directories(int index) {
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.ListProtocolOutputDirFilesResponse.directories)
  return directories_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::ListProtocolOutputDirFilesResponse_DirectoryInfo >*
ListProtocolOutputDirFilesResponse::mutable_directories() {
  // @@protoc_insertion_point(field_mutable_list:minknow_api.manager.ListProtocolOutputDirFilesResponse.directories)
  return &directories_;
}
inline const ::minknow_api::manager::ListProtocolOutputDirFilesResponse_DirectoryInfo& ListProtocolOutputDirFilesResponse::_internal_directories(int index) const {
  return directories_.Get(index);
}
inline const ::minknow_api::manager::ListProtocolOutputDirFilesResponse_DirectoryInfo& ListProtocolOutputDirFilesResponse::directories(int index) const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.ListProtocolOutputDirFilesResponse.directories)
  return _internal_directories(index);
}
inline ::minknow_api::manager::ListProtocolOutputDirFilesResponse_DirectoryInfo* ListProtocolOutputDirFilesResponse::_internal_add_directories() {
  return directories_.Add();
}
inline ::minknow_api::manager::ListProtocolOutputDirFilesResponse_DirectoryInfo* ListProtocolOutputDirFilesResponse::add_directories() {
  ::minknow_api::manager::ListProtocolOutputDirFilesResponse_DirectoryInfo* _add = _internal_add_directories();
  // @@protoc_insertion_point(field_add:minknow_api.manager.ListProtocolOutputDirFilesResponse.directories)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::ListProtocolOutputDirFilesResponse_DirectoryInfo >&
ListProtocolOutputDirFilesResponse::directories() const {
  // @@protoc_insertion_point(field_list:minknow_api.manager.ListProtocolOutputDirFilesResponse.directories)
  return directories_;
}

// repeated string files = 2;
inline int ListProtocolOutputDirFilesResponse::_internal_files_size() const {
  return files_.size();
}
inline int ListProtocolOutputDirFilesResponse::files_size() const {
  return _internal_files_size();
}
inline void ListProtocolOutputDirFilesResponse::clear_files() {
  files_.Clear();
}
inline std::string* ListProtocolOutputDirFilesResponse::add_files() {
  std::string* _s = _internal_add_files();
  // @@protoc_insertion_point(field_add_mutable:minknow_api.manager.ListProtocolOutputDirFilesResponse.files)
  return _s;
}
inline const std::string& ListProtocolOutputDirFilesResponse::_internal_files(int index) const {
  return files_.Get(index);
}
inline const std::string& ListProtocolOutputDirFilesResponse::files(int index) const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.ListProtocolOutputDirFilesResponse.files)
  return _internal_files(index);
}
inline std::string* ListProtocolOutputDirFilesResponse::mutable_files(int index) {
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.ListProtocolOutputDirFilesResponse.files)
  return files_.Mutable(index);
}
inline void ListProtocolOutputDirFilesResponse::set_files(int index, const std::string& value) {
  files_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.ListProtocolOutputDirFilesResponse.files)
}
inline void ListProtocolOutputDirFilesResponse::set_files(int index, std::string&& value) {
  files_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:minknow_api.manager.ListProtocolOutputDirFilesResponse.files)
}
inline void ListProtocolOutputDirFilesResponse::set_files(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  files_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:minknow_api.manager.ListProtocolOutputDirFilesResponse.files)
}
inline void ListProtocolOutputDirFilesResponse::set_files(int index, const char* value, size_t size) {
  files_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:minknow_api.manager.ListProtocolOutputDirFilesResponse.files)
}
inline std::string* ListProtocolOutputDirFilesResponse::_internal_add_files() {
  return files_.Add();
}
inline void ListProtocolOutputDirFilesResponse::add_files(const std::string& value) {
  files_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:minknow_api.manager.ListProtocolOutputDirFilesResponse.files)
}
inline void ListProtocolOutputDirFilesResponse::add_files(std::string&& value) {
  files_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:minknow_api.manager.ListProtocolOutputDirFilesResponse.files)
}
inline void ListProtocolOutputDirFilesResponse::add_files(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  files_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:minknow_api.manager.ListProtocolOutputDirFilesResponse.files)
}
inline void ListProtocolOutputDirFilesResponse::add_files(const char* value, size_t size) {
  files_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:minknow_api.manager.ListProtocolOutputDirFilesResponse.files)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListProtocolOutputDirFilesResponse::files() const {
  // @@protoc_insertion_point(field_list:minknow_api.manager.ListProtocolOutputDirFilesResponse.files)
  return files_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListProtocolOutputDirFilesResponse::mutable_files() {
  // @@protoc_insertion_point(field_mutable_list:minknow_api.manager.ListProtocolOutputDirFilesResponse.files)
  return &files_;
}

// string current_listed_path = 3;
inline void ListProtocolOutputDirFilesResponse::clear_current_listed_path() {
  current_listed_path_.ClearToEmpty();
}
inline const std::string& ListProtocolOutputDirFilesResponse::current_listed_path() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.ListProtocolOutputDirFilesResponse.current_listed_path)
  return _internal_current_listed_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListProtocolOutputDirFilesResponse::set_current_listed_path(ArgT0&& arg0, ArgT... args) {
 
 current_listed_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.manager.ListProtocolOutputDirFilesResponse.current_listed_path)
}
inline std::string* ListProtocolOutputDirFilesResponse::mutable_current_listed_path() {
  std::string* _s = _internal_mutable_current_listed_path();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.ListProtocolOutputDirFilesResponse.current_listed_path)
  return _s;
}
inline const std::string& ListProtocolOutputDirFilesResponse::_internal_current_listed_path() const {
  return current_listed_path_.Get();
}
inline void ListProtocolOutputDirFilesResponse::_internal_set_current_listed_path(const std::string& value) {
  
  current_listed_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListProtocolOutputDirFilesResponse::_internal_mutable_current_listed_path() {
  
  return current_listed_path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListProtocolOutputDirFilesResponse::release_current_listed_path() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.ListProtocolOutputDirFilesResponse.current_listed_path)
  return current_listed_path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListProtocolOutputDirFilesResponse::set_allocated_current_listed_path(std::string* current_listed_path) {
  if (current_listed_path != nullptr) {
    
  } else {
    
  }
  current_listed_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), current_listed_path,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.ListProtocolOutputDirFilesResponse.current_listed_path)
}

// -------------------------------------------------------------------

// CreateDirectoryRequest

// string parent_path = 1;
inline void CreateDirectoryRequest::clear_parent_path() {
  parent_path_.ClearToEmpty();
}
inline const std::string& CreateDirectoryRequest::parent_path() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.CreateDirectoryRequest.parent_path)
  return _internal_parent_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateDirectoryRequest::set_parent_path(ArgT0&& arg0, ArgT... args) {
 
 parent_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.manager.CreateDirectoryRequest.parent_path)
}
inline std::string* CreateDirectoryRequest::mutable_parent_path() {
  std::string* _s = _internal_mutable_parent_path();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.CreateDirectoryRequest.parent_path)
  return _s;
}
inline const std::string& CreateDirectoryRequest::_internal_parent_path() const {
  return parent_path_.Get();
}
inline void CreateDirectoryRequest::_internal_set_parent_path(const std::string& value) {
  
  parent_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateDirectoryRequest::_internal_mutable_parent_path() {
  
  return parent_path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateDirectoryRequest::release_parent_path() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.CreateDirectoryRequest.parent_path)
  return parent_path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateDirectoryRequest::set_allocated_parent_path(std::string* parent_path) {
  if (parent_path != nullptr) {
    
  } else {
    
  }
  parent_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), parent_path,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.CreateDirectoryRequest.parent_path)
}

// string name = 2;
inline void CreateDirectoryRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CreateDirectoryRequest::name() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.CreateDirectoryRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateDirectoryRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.manager.CreateDirectoryRequest.name)
}
inline std::string* CreateDirectoryRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.CreateDirectoryRequest.name)
  return _s;
}
inline const std::string& CreateDirectoryRequest::_internal_name() const {
  return name_.Get();
}
inline void CreateDirectoryRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateDirectoryRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateDirectoryRequest::release_name() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.CreateDirectoryRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateDirectoryRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.CreateDirectoryRequest.name)
}

// -------------------------------------------------------------------

// CreateDirectoryResponse

// string path = 1;
inline void CreateDirectoryResponse::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& CreateDirectoryResponse::path() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.CreateDirectoryResponse.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateDirectoryResponse::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.manager.CreateDirectoryResponse.path)
}
inline std::string* CreateDirectoryResponse::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.CreateDirectoryResponse.path)
  return _s;
}
inline const std::string& CreateDirectoryResponse::_internal_path() const {
  return path_.Get();
}
inline void CreateDirectoryResponse::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateDirectoryResponse::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateDirectoryResponse::release_path() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.CreateDirectoryResponse.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateDirectoryResponse::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.CreateDirectoryResponse.path)
}

// -------------------------------------------------------------------

// FilesystemDiskSpaceInfo

// string filesystem_id = 1;
inline void FilesystemDiskSpaceInfo::clear_filesystem_id() {
  filesystem_id_.ClearToEmpty();
}
inline const std::string& FilesystemDiskSpaceInfo::filesystem_id() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.FilesystemDiskSpaceInfo.filesystem_id)
  return _internal_filesystem_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FilesystemDiskSpaceInfo::set_filesystem_id(ArgT0&& arg0, ArgT... args) {
 
 filesystem_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.manager.FilesystemDiskSpaceInfo.filesystem_id)
}
inline std::string* FilesystemDiskSpaceInfo::mutable_filesystem_id() {
  std::string* _s = _internal_mutable_filesystem_id();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.FilesystemDiskSpaceInfo.filesystem_id)
  return _s;
}
inline const std::string& FilesystemDiskSpaceInfo::_internal_filesystem_id() const {
  return filesystem_id_.Get();
}
inline void FilesystemDiskSpaceInfo::_internal_set_filesystem_id(const std::string& value) {
  
  filesystem_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FilesystemDiskSpaceInfo::_internal_mutable_filesystem_id() {
  
  return filesystem_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FilesystemDiskSpaceInfo::release_filesystem_id() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.FilesystemDiskSpaceInfo.filesystem_id)
  return filesystem_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FilesystemDiskSpaceInfo::set_allocated_filesystem_id(std::string* filesystem_id) {
  if (filesystem_id != nullptr) {
    
  } else {
    
  }
  filesystem_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filesystem_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.FilesystemDiskSpaceInfo.filesystem_id)
}

// uint64 bytes_available = 2;
inline void FilesystemDiskSpaceInfo::clear_bytes_available() {
  bytes_available_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FilesystemDiskSpaceInfo::_internal_bytes_available() const {
  return bytes_available_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FilesystemDiskSpaceInfo::bytes_available() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.FilesystemDiskSpaceInfo.bytes_available)
  return _internal_bytes_available();
}
inline void FilesystemDiskSpaceInfo::_internal_set_bytes_available(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  bytes_available_ = value;
}
inline void FilesystemDiskSpaceInfo::set_bytes_available(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_bytes_available(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.FilesystemDiskSpaceInfo.bytes_available)
}

// uint64 bytes_capacity = 3;
inline void FilesystemDiskSpaceInfo::clear_bytes_capacity() {
  bytes_capacity_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FilesystemDiskSpaceInfo::_internal_bytes_capacity() const {
  return bytes_capacity_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FilesystemDiskSpaceInfo::bytes_capacity() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.FilesystemDiskSpaceInfo.bytes_capacity)
  return _internal_bytes_capacity();
}
inline void FilesystemDiskSpaceInfo::_internal_set_bytes_capacity(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  bytes_capacity_ = value;
}
inline void FilesystemDiskSpaceInfo::set_bytes_capacity(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_bytes_capacity(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.FilesystemDiskSpaceInfo.bytes_capacity)
}

// repeated string file_types_stored = 4;
inline int FilesystemDiskSpaceInfo::_internal_file_types_stored_size() const {
  return file_types_stored_.size();
}
inline int FilesystemDiskSpaceInfo::file_types_stored_size() const {
  return _internal_file_types_stored_size();
}
inline void FilesystemDiskSpaceInfo::clear_file_types_stored() {
  file_types_stored_.Clear();
}
inline std::string* FilesystemDiskSpaceInfo::add_file_types_stored() {
  std::string* _s = _internal_add_file_types_stored();
  // @@protoc_insertion_point(field_add_mutable:minknow_api.manager.FilesystemDiskSpaceInfo.file_types_stored)
  return _s;
}
inline const std::string& FilesystemDiskSpaceInfo::_internal_file_types_stored(int index) const {
  return file_types_stored_.Get(index);
}
inline const std::string& FilesystemDiskSpaceInfo::file_types_stored(int index) const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.FilesystemDiskSpaceInfo.file_types_stored)
  return _internal_file_types_stored(index);
}
inline std::string* FilesystemDiskSpaceInfo::mutable_file_types_stored(int index) {
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.FilesystemDiskSpaceInfo.file_types_stored)
  return file_types_stored_.Mutable(index);
}
inline void FilesystemDiskSpaceInfo::set_file_types_stored(int index, const std::string& value) {
  file_types_stored_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.FilesystemDiskSpaceInfo.file_types_stored)
}
inline void FilesystemDiskSpaceInfo::set_file_types_stored(int index, std::string&& value) {
  file_types_stored_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:minknow_api.manager.FilesystemDiskSpaceInfo.file_types_stored)
}
inline void FilesystemDiskSpaceInfo::set_file_types_stored(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  file_types_stored_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:minknow_api.manager.FilesystemDiskSpaceInfo.file_types_stored)
}
inline void FilesystemDiskSpaceInfo::set_file_types_stored(int index, const char* value, size_t size) {
  file_types_stored_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:minknow_api.manager.FilesystemDiskSpaceInfo.file_types_stored)
}
inline std::string* FilesystemDiskSpaceInfo::_internal_add_file_types_stored() {
  return file_types_stored_.Add();
}
inline void FilesystemDiskSpaceInfo::add_file_types_stored(const std::string& value) {
  file_types_stored_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:minknow_api.manager.FilesystemDiskSpaceInfo.file_types_stored)
}
inline void FilesystemDiskSpaceInfo::add_file_types_stored(std::string&& value) {
  file_types_stored_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:minknow_api.manager.FilesystemDiskSpaceInfo.file_types_stored)
}
inline void FilesystemDiskSpaceInfo::add_file_types_stored(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  file_types_stored_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:minknow_api.manager.FilesystemDiskSpaceInfo.file_types_stored)
}
inline void FilesystemDiskSpaceInfo::add_file_types_stored(const char* value, size_t size) {
  file_types_stored_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:minknow_api.manager.FilesystemDiskSpaceInfo.file_types_stored)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FilesystemDiskSpaceInfo::file_types_stored() const {
  // @@protoc_insertion_point(field_list:minknow_api.manager.FilesystemDiskSpaceInfo.file_types_stored)
  return file_types_stored_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FilesystemDiskSpaceInfo::mutable_file_types_stored() {
  // @@protoc_insertion_point(field_mutable_list:minknow_api.manager.FilesystemDiskSpaceInfo.file_types_stored)
  return &file_types_stored_;
}

// uint64 bytes_to_stop_cleanly = 5;
inline void FilesystemDiskSpaceInfo::clear_bytes_to_stop_cleanly() {
  bytes_to_stop_cleanly_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FilesystemDiskSpaceInfo::_internal_bytes_to_stop_cleanly() const {
  return bytes_to_stop_cleanly_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FilesystemDiskSpaceInfo::bytes_to_stop_cleanly() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.FilesystemDiskSpaceInfo.bytes_to_stop_cleanly)
  return _internal_bytes_to_stop_cleanly();
}
inline void FilesystemDiskSpaceInfo::_internal_set_bytes_to_stop_cleanly(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  bytes_to_stop_cleanly_ = value;
}
inline void FilesystemDiskSpaceInfo::set_bytes_to_stop_cleanly(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_bytes_to_stop_cleanly(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.FilesystemDiskSpaceInfo.bytes_to_stop_cleanly)
}

// uint64 bytes_when_alert_issued = 6;
inline void FilesystemDiskSpaceInfo::clear_bytes_when_alert_issued() {
  bytes_when_alert_issued_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FilesystemDiskSpaceInfo::_internal_bytes_when_alert_issued() const {
  return bytes_when_alert_issued_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FilesystemDiskSpaceInfo::bytes_when_alert_issued() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.FilesystemDiskSpaceInfo.bytes_when_alert_issued)
  return _internal_bytes_when_alert_issued();
}
inline void FilesystemDiskSpaceInfo::_internal_set_bytes_when_alert_issued(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  bytes_when_alert_issued_ = value;
}
inline void FilesystemDiskSpaceInfo::set_bytes_when_alert_issued(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_bytes_when_alert_issued(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.FilesystemDiskSpaceInfo.bytes_when_alert_issued)
}

// bool recommend_alert = 7;
inline void FilesystemDiskSpaceInfo::clear_recommend_alert() {
  recommend_alert_ = false;
}
inline bool FilesystemDiskSpaceInfo::_internal_recommend_alert() const {
  return recommend_alert_;
}
inline bool FilesystemDiskSpaceInfo::recommend_alert() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.FilesystemDiskSpaceInfo.recommend_alert)
  return _internal_recommend_alert();
}
inline void FilesystemDiskSpaceInfo::_internal_set_recommend_alert(bool value) {
  
  recommend_alert_ = value;
}
inline void FilesystemDiskSpaceInfo::set_recommend_alert(bool value) {
  _internal_set_recommend_alert(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.FilesystemDiskSpaceInfo.recommend_alert)
}

// bool recommend_stop = 8;
inline void FilesystemDiskSpaceInfo::clear_recommend_stop() {
  recommend_stop_ = false;
}
inline bool FilesystemDiskSpaceInfo::_internal_recommend_stop() const {
  return recommend_stop_;
}
inline bool FilesystemDiskSpaceInfo::recommend_stop() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.FilesystemDiskSpaceInfo.recommend_stop)
  return _internal_recommend_stop();
}
inline void FilesystemDiskSpaceInfo::_internal_set_recommend_stop(bool value) {
  
  recommend_stop_ = value;
}
inline void FilesystemDiskSpaceInfo::set_recommend_stop(bool value) {
  _internal_set_recommend_stop(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.FilesystemDiskSpaceInfo.recommend_stop)
}

// int64 bytes_per_second = 9;
inline void FilesystemDiskSpaceInfo::clear_bytes_per_second() {
  bytes_per_second_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FilesystemDiskSpaceInfo::_internal_bytes_per_second() const {
  return bytes_per_second_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FilesystemDiskSpaceInfo::bytes_per_second() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.FilesystemDiskSpaceInfo.bytes_per_second)
  return _internal_bytes_per_second();
}
inline void FilesystemDiskSpaceInfo::_internal_set_bytes_per_second(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  bytes_per_second_ = value;
}
inline void FilesystemDiskSpaceInfo::set_bytes_per_second(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_bytes_per_second(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.FilesystemDiskSpaceInfo.bytes_per_second)
}

// -------------------------------------------------------------------

// GetDiskSpaceInfoRequest

// -------------------------------------------------------------------

// StreamDiskSpaceInfoRequest

// uint32 period = 1;
inline void StreamDiskSpaceInfoRequest::clear_period() {
  period_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StreamDiskSpaceInfoRequest::_internal_period() const {
  return period_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StreamDiskSpaceInfoRequest::period() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.StreamDiskSpaceInfoRequest.period)
  return _internal_period();
}
inline void StreamDiskSpaceInfoRequest::_internal_set_period(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  period_ = value;
}
inline void StreamDiskSpaceInfoRequest::set_period(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_period(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.StreamDiskSpaceInfoRequest.period)
}

// -------------------------------------------------------------------

// GetDiskSpaceInfoResponse

// repeated .minknow_api.manager.FilesystemDiskSpaceInfo filesystem_disk_space_info = 1;
inline int GetDiskSpaceInfoResponse::_internal_filesystem_disk_space_info_size() const {
  return filesystem_disk_space_info_.size();
}
inline int GetDiskSpaceInfoResponse::filesystem_disk_space_info_size() const {
  return _internal_filesystem_disk_space_info_size();
}
inline void GetDiskSpaceInfoResponse::clear_filesystem_disk_space_info() {
  filesystem_disk_space_info_.Clear();
}
inline ::minknow_api::manager::FilesystemDiskSpaceInfo* GetDiskSpaceInfoResponse::mutable_filesystem_disk_space_info(int index) {
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.GetDiskSpaceInfoResponse.filesystem_disk_space_info)
  return filesystem_disk_space_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::FilesystemDiskSpaceInfo >*
GetDiskSpaceInfoResponse::mutable_filesystem_disk_space_info() {
  // @@protoc_insertion_point(field_mutable_list:minknow_api.manager.GetDiskSpaceInfoResponse.filesystem_disk_space_info)
  return &filesystem_disk_space_info_;
}
inline const ::minknow_api::manager::FilesystemDiskSpaceInfo& GetDiskSpaceInfoResponse::_internal_filesystem_disk_space_info(int index) const {
  return filesystem_disk_space_info_.Get(index);
}
inline const ::minknow_api::manager::FilesystemDiskSpaceInfo& GetDiskSpaceInfoResponse::filesystem_disk_space_info(int index) const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetDiskSpaceInfoResponse.filesystem_disk_space_info)
  return _internal_filesystem_disk_space_info(index);
}
inline ::minknow_api::manager::FilesystemDiskSpaceInfo* GetDiskSpaceInfoResponse::_internal_add_filesystem_disk_space_info() {
  return filesystem_disk_space_info_.Add();
}
inline ::minknow_api::manager::FilesystemDiskSpaceInfo* GetDiskSpaceInfoResponse::add_filesystem_disk_space_info() {
  ::minknow_api::manager::FilesystemDiskSpaceInfo* _add = _internal_add_filesystem_disk_space_info();
  // @@protoc_insertion_point(field_add:minknow_api.manager.GetDiskSpaceInfoResponse.filesystem_disk_space_info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::FilesystemDiskSpaceInfo >&
GetDiskSpaceInfoResponse::filesystem_disk_space_info() const {
  // @@protoc_insertion_point(field_list:minknow_api.manager.GetDiskSpaceInfoResponse.filesystem_disk_space_info)
  return filesystem_disk_space_info_;
}

// -------------------------------------------------------------------

// GetBarcodeKitInfoRequest

// -------------------------------------------------------------------

// GetBarcodeKitInfoResponse_BarcodeKitInfo

// bool is_dual = 2;
inline void GetBarcodeKitInfoResponse_BarcodeKitInfo::clear_is_dual() {
  is_dual_ = false;
}
inline bool GetBarcodeKitInfoResponse_BarcodeKitInfo::_internal_is_dual() const {
  return is_dual_;
}
inline bool GetBarcodeKitInfoResponse_BarcodeKitInfo::is_dual() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetBarcodeKitInfoResponse.BarcodeKitInfo.is_dual)
  return _internal_is_dual();
}
inline void GetBarcodeKitInfoResponse_BarcodeKitInfo::_internal_set_is_dual(bool value) {
  
  is_dual_ = value;
}
inline void GetBarcodeKitInfoResponse_BarcodeKitInfo::set_is_dual(bool value) {
  _internal_set_is_dual(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetBarcodeKitInfoResponse.BarcodeKitInfo.is_dual)
}

// bool is_both_ends = 3;
inline void GetBarcodeKitInfoResponse_BarcodeKitInfo::clear_is_both_ends() {
  is_both_ends_ = false;
}
inline bool GetBarcodeKitInfoResponse_BarcodeKitInfo::_internal_is_both_ends() const {
  return is_both_ends_;
}
inline bool GetBarcodeKitInfoResponse_BarcodeKitInfo::is_both_ends() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetBarcodeKitInfoResponse.BarcodeKitInfo.is_both_ends)
  return _internal_is_both_ends();
}
inline void GetBarcodeKitInfoResponse_BarcodeKitInfo::_internal_set_is_both_ends(bool value) {
  
  is_both_ends_ = value;
}
inline void GetBarcodeKitInfoResponse_BarcodeKitInfo::set_is_both_ends(bool value) {
  _internal_set_is_both_ends(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetBarcodeKitInfoResponse.BarcodeKitInfo.is_both_ends)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GetBarcodeKitInfoResponse

// map<string, .minknow_api.manager.GetBarcodeKitInfoResponse.BarcodeKitInfo> barcode_kit_info = 1;
inline int GetBarcodeKitInfoResponse::_internal_barcode_kit_info_size() const {
  return barcode_kit_info_.size();
}
inline int GetBarcodeKitInfoResponse::barcode_kit_info_size() const {
  return _internal_barcode_kit_info_size();
}
inline void GetBarcodeKitInfoResponse::clear_barcode_kit_info() {
  barcode_kit_info_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::minknow_api::manager::GetBarcodeKitInfoResponse_BarcodeKitInfo >&
GetBarcodeKitInfoResponse::_internal_barcode_kit_info() const {
  return barcode_kit_info_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::minknow_api::manager::GetBarcodeKitInfoResponse_BarcodeKitInfo >&
GetBarcodeKitInfoResponse::barcode_kit_info() const {
  // @@protoc_insertion_point(field_map:minknow_api.manager.GetBarcodeKitInfoResponse.barcode_kit_info)
  return _internal_barcode_kit_info();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::minknow_api::manager::GetBarcodeKitInfoResponse_BarcodeKitInfo >*
GetBarcodeKitInfoResponse::_internal_mutable_barcode_kit_info() {
  return barcode_kit_info_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::minknow_api::manager::GetBarcodeKitInfoResponse_BarcodeKitInfo >*
GetBarcodeKitInfoResponse::mutable_barcode_kit_info() {
  // @@protoc_insertion_point(field_mutable_map:minknow_api.manager.GetBarcodeKitInfoResponse.barcode_kit_info)
  return _internal_mutable_barcode_kit_info();
}

// -------------------------------------------------------------------

// GetLampKitInfoRequest

// -------------------------------------------------------------------

// GetLampKitInfoResponse

// repeated string lamp_kits = 2;
inline int GetLampKitInfoResponse::_internal_lamp_kits_size() const {
  return lamp_kits_.size();
}
inline int GetLampKitInfoResponse::lamp_kits_size() const {
  return _internal_lamp_kits_size();
}
inline void GetLampKitInfoResponse::clear_lamp_kits() {
  lamp_kits_.Clear();
}
inline std::string* GetLampKitInfoResponse::add_lamp_kits() {
  std::string* _s = _internal_add_lamp_kits();
  // @@protoc_insertion_point(field_add_mutable:minknow_api.manager.GetLampKitInfoResponse.lamp_kits)
  return _s;
}
inline const std::string& GetLampKitInfoResponse::_internal_lamp_kits(int index) const {
  return lamp_kits_.Get(index);
}
inline const std::string& GetLampKitInfoResponse::lamp_kits(int index) const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetLampKitInfoResponse.lamp_kits)
  return _internal_lamp_kits(index);
}
inline std::string* GetLampKitInfoResponse::mutable_lamp_kits(int index) {
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.GetLampKitInfoResponse.lamp_kits)
  return lamp_kits_.Mutable(index);
}
inline void GetLampKitInfoResponse::set_lamp_kits(int index, const std::string& value) {
  lamp_kits_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetLampKitInfoResponse.lamp_kits)
}
inline void GetLampKitInfoResponse::set_lamp_kits(int index, std::string&& value) {
  lamp_kits_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetLampKitInfoResponse.lamp_kits)
}
inline void GetLampKitInfoResponse::set_lamp_kits(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  lamp_kits_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:minknow_api.manager.GetLampKitInfoResponse.lamp_kits)
}
inline void GetLampKitInfoResponse::set_lamp_kits(int index, const char* value, size_t size) {
  lamp_kits_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:minknow_api.manager.GetLampKitInfoResponse.lamp_kits)
}
inline std::string* GetLampKitInfoResponse::_internal_add_lamp_kits() {
  return lamp_kits_.Add();
}
inline void GetLampKitInfoResponse::add_lamp_kits(const std::string& value) {
  lamp_kits_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:minknow_api.manager.GetLampKitInfoResponse.lamp_kits)
}
inline void GetLampKitInfoResponse::add_lamp_kits(std::string&& value) {
  lamp_kits_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:minknow_api.manager.GetLampKitInfoResponse.lamp_kits)
}
inline void GetLampKitInfoResponse::add_lamp_kits(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  lamp_kits_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:minknow_api.manager.GetLampKitInfoResponse.lamp_kits)
}
inline void GetLampKitInfoResponse::add_lamp_kits(const char* value, size_t size) {
  lamp_kits_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:minknow_api.manager.GetLampKitInfoResponse.lamp_kits)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetLampKitInfoResponse::lamp_kits() const {
  // @@protoc_insertion_point(field_list:minknow_api.manager.GetLampKitInfoResponse.lamp_kits)
  return lamp_kits_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetLampKitInfoResponse::mutable_lamp_kits() {
  // @@protoc_insertion_point(field_mutable_list:minknow_api.manager.GetLampKitInfoResponse.lamp_kits)
  return &lamp_kits_;
}

// -------------------------------------------------------------------

// GetBarcodeKeysRequest

// repeated string barcode_kit_names = 1;
inline int GetBarcodeKeysRequest::_internal_barcode_kit_names_size() const {
  return barcode_kit_names_.size();
}
inline int GetBarcodeKeysRequest::barcode_kit_names_size() const {
  return _internal_barcode_kit_names_size();
}
inline void GetBarcodeKeysRequest::clear_barcode_kit_names() {
  barcode_kit_names_.Clear();
}
inline std::string* GetBarcodeKeysRequest::add_barcode_kit_names() {
  std::string* _s = _internal_add_barcode_kit_names();
  // @@protoc_insertion_point(field_add_mutable:minknow_api.manager.GetBarcodeKeysRequest.barcode_kit_names)
  return _s;
}
inline const std::string& GetBarcodeKeysRequest::_internal_barcode_kit_names(int index) const {
  return barcode_kit_names_.Get(index);
}
inline const std::string& GetBarcodeKeysRequest::barcode_kit_names(int index) const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetBarcodeKeysRequest.barcode_kit_names)
  return _internal_barcode_kit_names(index);
}
inline std::string* GetBarcodeKeysRequest::mutable_barcode_kit_names(int index) {
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.GetBarcodeKeysRequest.barcode_kit_names)
  return barcode_kit_names_.Mutable(index);
}
inline void GetBarcodeKeysRequest::set_barcode_kit_names(int index, const std::string& value) {
  barcode_kit_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetBarcodeKeysRequest.barcode_kit_names)
}
inline void GetBarcodeKeysRequest::set_barcode_kit_names(int index, std::string&& value) {
  barcode_kit_names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetBarcodeKeysRequest.barcode_kit_names)
}
inline void GetBarcodeKeysRequest::set_barcode_kit_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  barcode_kit_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:minknow_api.manager.GetBarcodeKeysRequest.barcode_kit_names)
}
inline void GetBarcodeKeysRequest::set_barcode_kit_names(int index, const char* value, size_t size) {
  barcode_kit_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:minknow_api.manager.GetBarcodeKeysRequest.barcode_kit_names)
}
inline std::string* GetBarcodeKeysRequest::_internal_add_barcode_kit_names() {
  return barcode_kit_names_.Add();
}
inline void GetBarcodeKeysRequest::add_barcode_kit_names(const std::string& value) {
  barcode_kit_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:minknow_api.manager.GetBarcodeKeysRequest.barcode_kit_names)
}
inline void GetBarcodeKeysRequest::add_barcode_kit_names(std::string&& value) {
  barcode_kit_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:minknow_api.manager.GetBarcodeKeysRequest.barcode_kit_names)
}
inline void GetBarcodeKeysRequest::add_barcode_kit_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  barcode_kit_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:minknow_api.manager.GetBarcodeKeysRequest.barcode_kit_names)
}
inline void GetBarcodeKeysRequest::add_barcode_kit_names(const char* value, size_t size) {
  barcode_kit_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:minknow_api.manager.GetBarcodeKeysRequest.barcode_kit_names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetBarcodeKeysRequest::barcode_kit_names() const {
  // @@protoc_insertion_point(field_list:minknow_api.manager.GetBarcodeKeysRequest.barcode_kit_names)
  return barcode_kit_names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetBarcodeKeysRequest::mutable_barcode_kit_names() {
  // @@protoc_insertion_point(field_mutable_list:minknow_api.manager.GetBarcodeKeysRequest.barcode_kit_names)
  return &barcode_kit_names_;
}

// string lamp_kit_name = 2;
inline void GetBarcodeKeysRequest::clear_lamp_kit_name() {
  lamp_kit_name_.ClearToEmpty();
}
inline const std::string& GetBarcodeKeysRequest::lamp_kit_name() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetBarcodeKeysRequest.lamp_kit_name)
  return _internal_lamp_kit_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBarcodeKeysRequest::set_lamp_kit_name(ArgT0&& arg0, ArgT... args) {
 
 lamp_kit_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetBarcodeKeysRequest.lamp_kit_name)
}
inline std::string* GetBarcodeKeysRequest::mutable_lamp_kit_name() {
  std::string* _s = _internal_mutable_lamp_kit_name();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.GetBarcodeKeysRequest.lamp_kit_name)
  return _s;
}
inline const std::string& GetBarcodeKeysRequest::_internal_lamp_kit_name() const {
  return lamp_kit_name_.Get();
}
inline void GetBarcodeKeysRequest::_internal_set_lamp_kit_name(const std::string& value) {
  
  lamp_kit_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetBarcodeKeysRequest::_internal_mutable_lamp_kit_name() {
  
  return lamp_kit_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetBarcodeKeysRequest::release_lamp_kit_name() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.GetBarcodeKeysRequest.lamp_kit_name)
  return lamp_kit_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetBarcodeKeysRequest::set_allocated_lamp_kit_name(std::string* lamp_kit_name) {
  if (lamp_kit_name != nullptr) {
    
  } else {
    
  }
  lamp_kit_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), lamp_kit_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.GetBarcodeKeysRequest.lamp_kit_name)
}

// -------------------------------------------------------------------

// GetBarcodeKeysResponse

// repeated string barcode_keys = 1;
inline int GetBarcodeKeysResponse::_internal_barcode_keys_size() const {
  return barcode_keys_.size();
}
inline int GetBarcodeKeysResponse::barcode_keys_size() const {
  return _internal_barcode_keys_size();
}
inline void GetBarcodeKeysResponse::clear_barcode_keys() {
  barcode_keys_.Clear();
}
inline std::string* GetBarcodeKeysResponse::add_barcode_keys() {
  std::string* _s = _internal_add_barcode_keys();
  // @@protoc_insertion_point(field_add_mutable:minknow_api.manager.GetBarcodeKeysResponse.barcode_keys)
  return _s;
}
inline const std::string& GetBarcodeKeysResponse::_internal_barcode_keys(int index) const {
  return barcode_keys_.Get(index);
}
inline const std::string& GetBarcodeKeysResponse::barcode_keys(int index) const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetBarcodeKeysResponse.barcode_keys)
  return _internal_barcode_keys(index);
}
inline std::string* GetBarcodeKeysResponse::mutable_barcode_keys(int index) {
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.GetBarcodeKeysResponse.barcode_keys)
  return barcode_keys_.Mutable(index);
}
inline void GetBarcodeKeysResponse::set_barcode_keys(int index, const std::string& value) {
  barcode_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetBarcodeKeysResponse.barcode_keys)
}
inline void GetBarcodeKeysResponse::set_barcode_keys(int index, std::string&& value) {
  barcode_keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetBarcodeKeysResponse.barcode_keys)
}
inline void GetBarcodeKeysResponse::set_barcode_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  barcode_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:minknow_api.manager.GetBarcodeKeysResponse.barcode_keys)
}
inline void GetBarcodeKeysResponse::set_barcode_keys(int index, const char* value, size_t size) {
  barcode_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:minknow_api.manager.GetBarcodeKeysResponse.barcode_keys)
}
inline std::string* GetBarcodeKeysResponse::_internal_add_barcode_keys() {
  return barcode_keys_.Add();
}
inline void GetBarcodeKeysResponse::add_barcode_keys(const std::string& value) {
  barcode_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:minknow_api.manager.GetBarcodeKeysResponse.barcode_keys)
}
inline void GetBarcodeKeysResponse::add_barcode_keys(std::string&& value) {
  barcode_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:minknow_api.manager.GetBarcodeKeysResponse.barcode_keys)
}
inline void GetBarcodeKeysResponse::add_barcode_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  barcode_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:minknow_api.manager.GetBarcodeKeysResponse.barcode_keys)
}
inline void GetBarcodeKeysResponse::add_barcode_keys(const char* value, size_t size) {
  barcode_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:minknow_api.manager.GetBarcodeKeysResponse.barcode_keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetBarcodeKeysResponse::barcode_keys() const {
  // @@protoc_insertion_point(field_list:minknow_api.manager.GetBarcodeKeysResponse.barcode_keys)
  return barcode_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetBarcodeKeysResponse::mutable_barcode_keys() {
  // @@protoc_insertion_point(field_mutable_list:minknow_api.manager.GetBarcodeKeysResponse.barcode_keys)
  return &barcode_keys_;
}

// repeated string lamp_keys = 2;
inline int GetBarcodeKeysResponse::_internal_lamp_keys_size() const {
  return lamp_keys_.size();
}
inline int GetBarcodeKeysResponse::lamp_keys_size() const {
  return _internal_lamp_keys_size();
}
inline void GetBarcodeKeysResponse::clear_lamp_keys() {
  lamp_keys_.Clear();
}
inline std::string* GetBarcodeKeysResponse::add_lamp_keys() {
  std::string* _s = _internal_add_lamp_keys();
  // @@protoc_insertion_point(field_add_mutable:minknow_api.manager.GetBarcodeKeysResponse.lamp_keys)
  return _s;
}
inline const std::string& GetBarcodeKeysResponse::_internal_lamp_keys(int index) const {
  return lamp_keys_.Get(index);
}
inline const std::string& GetBarcodeKeysResponse::lamp_keys(int index) const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetBarcodeKeysResponse.lamp_keys)
  return _internal_lamp_keys(index);
}
inline std::string* GetBarcodeKeysResponse::mutable_lamp_keys(int index) {
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.GetBarcodeKeysResponse.lamp_keys)
  return lamp_keys_.Mutable(index);
}
inline void GetBarcodeKeysResponse::set_lamp_keys(int index, const std::string& value) {
  lamp_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetBarcodeKeysResponse.lamp_keys)
}
inline void GetBarcodeKeysResponse::set_lamp_keys(int index, std::string&& value) {
  lamp_keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetBarcodeKeysResponse.lamp_keys)
}
inline void GetBarcodeKeysResponse::set_lamp_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  lamp_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:minknow_api.manager.GetBarcodeKeysResponse.lamp_keys)
}
inline void GetBarcodeKeysResponse::set_lamp_keys(int index, const char* value, size_t size) {
  lamp_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:minknow_api.manager.GetBarcodeKeysResponse.lamp_keys)
}
inline std::string* GetBarcodeKeysResponse::_internal_add_lamp_keys() {
  return lamp_keys_.Add();
}
inline void GetBarcodeKeysResponse::add_lamp_keys(const std::string& value) {
  lamp_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:minknow_api.manager.GetBarcodeKeysResponse.lamp_keys)
}
inline void GetBarcodeKeysResponse::add_lamp_keys(std::string&& value) {
  lamp_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:minknow_api.manager.GetBarcodeKeysResponse.lamp_keys)
}
inline void GetBarcodeKeysResponse::add_lamp_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  lamp_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:minknow_api.manager.GetBarcodeKeysResponse.lamp_keys)
}
inline void GetBarcodeKeysResponse::add_lamp_keys(const char* value, size_t size) {
  lamp_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:minknow_api.manager.GetBarcodeKeysResponse.lamp_keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetBarcodeKeysResponse::lamp_keys() const {
  // @@protoc_insertion_point(field_list:minknow_api.manager.GetBarcodeKeysResponse.lamp_keys)
  return lamp_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetBarcodeKeysResponse::mutable_lamp_keys() {
  // @@protoc_insertion_point(field_mutable_list:minknow_api.manager.GetBarcodeKeysResponse.lamp_keys)
  return &lamp_keys_;
}

// repeated string combined_keys = 3;
inline int GetBarcodeKeysResponse::_internal_combined_keys_size() const {
  return combined_keys_.size();
}
inline int GetBarcodeKeysResponse::combined_keys_size() const {
  return _internal_combined_keys_size();
}
inline void GetBarcodeKeysResponse::clear_combined_keys() {
  combined_keys_.Clear();
}
inline std::string* GetBarcodeKeysResponse::add_combined_keys() {
  std::string* _s = _internal_add_combined_keys();
  // @@protoc_insertion_point(field_add_mutable:minknow_api.manager.GetBarcodeKeysResponse.combined_keys)
  return _s;
}
inline const std::string& GetBarcodeKeysResponse::_internal_combined_keys(int index) const {
  return combined_keys_.Get(index);
}
inline const std::string& GetBarcodeKeysResponse::combined_keys(int index) const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetBarcodeKeysResponse.combined_keys)
  return _internal_combined_keys(index);
}
inline std::string* GetBarcodeKeysResponse::mutable_combined_keys(int index) {
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.GetBarcodeKeysResponse.combined_keys)
  return combined_keys_.Mutable(index);
}
inline void GetBarcodeKeysResponse::set_combined_keys(int index, const std::string& value) {
  combined_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetBarcodeKeysResponse.combined_keys)
}
inline void GetBarcodeKeysResponse::set_combined_keys(int index, std::string&& value) {
  combined_keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetBarcodeKeysResponse.combined_keys)
}
inline void GetBarcodeKeysResponse::set_combined_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  combined_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:minknow_api.manager.GetBarcodeKeysResponse.combined_keys)
}
inline void GetBarcodeKeysResponse::set_combined_keys(int index, const char* value, size_t size) {
  combined_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:minknow_api.manager.GetBarcodeKeysResponse.combined_keys)
}
inline std::string* GetBarcodeKeysResponse::_internal_add_combined_keys() {
  return combined_keys_.Add();
}
inline void GetBarcodeKeysResponse::add_combined_keys(const std::string& value) {
  combined_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:minknow_api.manager.GetBarcodeKeysResponse.combined_keys)
}
inline void GetBarcodeKeysResponse::add_combined_keys(std::string&& value) {
  combined_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:minknow_api.manager.GetBarcodeKeysResponse.combined_keys)
}
inline void GetBarcodeKeysResponse::add_combined_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  combined_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:minknow_api.manager.GetBarcodeKeysResponse.combined_keys)
}
inline void GetBarcodeKeysResponse::add_combined_keys(const char* value, size_t size) {
  combined_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:minknow_api.manager.GetBarcodeKeysResponse.combined_keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetBarcodeKeysResponse::combined_keys() const {
  // @@protoc_insertion_point(field_list:minknow_api.manager.GetBarcodeKeysResponse.combined_keys)
  return combined_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetBarcodeKeysResponse::mutable_combined_keys() {
  // @@protoc_insertion_point(field_mutable_list:minknow_api.manager.GetBarcodeKeysResponse.combined_keys)
  return &combined_keys_;
}

// -------------------------------------------------------------------

// GetFlowCellTypesRequest

// -------------------------------------------------------------------

// GetFlowCellTypesResponse_Info

// string product_code = 1;
inline void GetFlowCellTypesResponse_Info::clear_product_code() {
  product_code_.ClearToEmpty();
}
inline const std::string& GetFlowCellTypesResponse_Info::product_code() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetFlowCellTypesResponse.Info.product_code)
  return _internal_product_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFlowCellTypesResponse_Info::set_product_code(ArgT0&& arg0, ArgT... args) {
 
 product_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetFlowCellTypesResponse.Info.product_code)
}
inline std::string* GetFlowCellTypesResponse_Info::mutable_product_code() {
  std::string* _s = _internal_mutable_product_code();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.GetFlowCellTypesResponse.Info.product_code)
  return _s;
}
inline const std::string& GetFlowCellTypesResponse_Info::_internal_product_code() const {
  return product_code_.Get();
}
inline void GetFlowCellTypesResponse_Info::_internal_set_product_code(const std::string& value) {
  
  product_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetFlowCellTypesResponse_Info::_internal_mutable_product_code() {
  
  return product_code_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetFlowCellTypesResponse_Info::release_product_code() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.GetFlowCellTypesResponse.Info.product_code)
  return product_code_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetFlowCellTypesResponse_Info::set_allocated_product_code(std::string* product_code) {
  if (product_code != nullptr) {
    
  } else {
    
  }
  product_code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), product_code,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.GetFlowCellTypesResponse.Info.product_code)
}

// .minknow_api.device.FlowCellConnectorType connector_type = 2;
inline void GetFlowCellTypesResponse_Info::clear_connector_type() {
  connector_type_ = 0;
}
inline ::minknow_api::device::FlowCellConnectorType GetFlowCellTypesResponse_Info::_internal_connector_type() const {
  return static_cast< ::minknow_api::device::FlowCellConnectorType >(connector_type_);
}
inline ::minknow_api::device::FlowCellConnectorType GetFlowCellTypesResponse_Info::connector_type() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetFlowCellTypesResponse.Info.connector_type)
  return _internal_connector_type();
}
inline void GetFlowCellTypesResponse_Info::_internal_set_connector_type(::minknow_api::device::FlowCellConnectorType value) {
  
  connector_type_ = value;
}
inline void GetFlowCellTypesResponse_Info::set_connector_type(::minknow_api::device::FlowCellConnectorType value) {
  _internal_set_connector_type(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetFlowCellTypesResponse.Info.connector_type)
}

// bool cannot_live_basecall = 3;
inline void GetFlowCellTypesResponse_Info::clear_cannot_live_basecall() {
  cannot_live_basecall_ = false;
}
inline bool GetFlowCellTypesResponse_Info::_internal_cannot_live_basecall() const {
  return cannot_live_basecall_;
}
inline bool GetFlowCellTypesResponse_Info::cannot_live_basecall() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetFlowCellTypesResponse.Info.cannot_live_basecall)
  return _internal_cannot_live_basecall();
}
inline void GetFlowCellTypesResponse_Info::_internal_set_cannot_live_basecall(bool value) {
  
  cannot_live_basecall_ = value;
}
inline void GetFlowCellTypesResponse_Info::set_cannot_live_basecall(bool value) {
  _internal_set_cannot_live_basecall(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetFlowCellTypesResponse.Info.cannot_live_basecall)
}

// -------------------------------------------------------------------

// GetFlowCellTypesResponse

// repeated .minknow_api.manager.GetFlowCellTypesResponse.Info types = 1;
inline int GetFlowCellTypesResponse::_internal_types_size() const {
  return types_.size();
}
inline int GetFlowCellTypesResponse::types_size() const {
  return _internal_types_size();
}
inline void GetFlowCellTypesResponse::clear_types() {
  types_.Clear();
}
inline ::minknow_api::manager::GetFlowCellTypesResponse_Info* GetFlowCellTypesResponse::mutable_types(int index) {
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.GetFlowCellTypesResponse.types)
  return types_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::GetFlowCellTypesResponse_Info >*
GetFlowCellTypesResponse::mutable_types() {
  // @@protoc_insertion_point(field_mutable_list:minknow_api.manager.GetFlowCellTypesResponse.types)
  return &types_;
}
inline const ::minknow_api::manager::GetFlowCellTypesResponse_Info& GetFlowCellTypesResponse::_internal_types(int index) const {
  return types_.Get(index);
}
inline const ::minknow_api::manager::GetFlowCellTypesResponse_Info& GetFlowCellTypesResponse::types(int index) const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetFlowCellTypesResponse.types)
  return _internal_types(index);
}
inline ::minknow_api::manager::GetFlowCellTypesResponse_Info* GetFlowCellTypesResponse::_internal_add_types() {
  return types_.Add();
}
inline ::minknow_api::manager::GetFlowCellTypesResponse_Info* GetFlowCellTypesResponse::add_types() {
  ::minknow_api::manager::GetFlowCellTypesResponse_Info* _add = _internal_add_types();
  // @@protoc_insertion_point(field_add:minknow_api.manager.GetFlowCellTypesResponse.types)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::GetFlowCellTypesResponse_Info >&
GetFlowCellTypesResponse::types() const {
  // @@protoc_insertion_point(field_list:minknow_api.manager.GetFlowCellTypesResponse.types)
  return types_;
}

// -------------------------------------------------------------------

// GetSequencingKitsRequest

// string flow_cell_product_code = 1;
inline void GetSequencingKitsRequest::clear_flow_cell_product_code() {
  flow_cell_product_code_.ClearToEmpty();
}
inline const std::string& GetSequencingKitsRequest::flow_cell_product_code() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetSequencingKitsRequest.flow_cell_product_code)
  return _internal_flow_cell_product_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetSequencingKitsRequest::set_flow_cell_product_code(ArgT0&& arg0, ArgT... args) {
 
 flow_cell_product_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetSequencingKitsRequest.flow_cell_product_code)
}
inline std::string* GetSequencingKitsRequest::mutable_flow_cell_product_code() {
  std::string* _s = _internal_mutable_flow_cell_product_code();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.GetSequencingKitsRequest.flow_cell_product_code)
  return _s;
}
inline const std::string& GetSequencingKitsRequest::_internal_flow_cell_product_code() const {
  return flow_cell_product_code_.Get();
}
inline void GetSequencingKitsRequest::_internal_set_flow_cell_product_code(const std::string& value) {
  
  flow_cell_product_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetSequencingKitsRequest::_internal_mutable_flow_cell_product_code() {
  
  return flow_cell_product_code_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetSequencingKitsRequest::release_flow_cell_product_code() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.GetSequencingKitsRequest.flow_cell_product_code)
  return flow_cell_product_code_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetSequencingKitsRequest::set_allocated_flow_cell_product_code(std::string* flow_cell_product_code) {
  if (flow_cell_product_code != nullptr) {
    
  } else {
    
  }
  flow_cell_product_code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), flow_cell_product_code,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.GetSequencingKitsRequest.flow_cell_product_code)
}

// -------------------------------------------------------------------

// GetSequencingKitsResponse_Kit

// string product_code = 1;
inline void GetSequencingKitsResponse_Kit::clear_product_code() {
  product_code_.ClearToEmpty();
}
inline const std::string& GetSequencingKitsResponse_Kit::product_code() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetSequencingKitsResponse.Kit.product_code)
  return _internal_product_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetSequencingKitsResponse_Kit::set_product_code(ArgT0&& arg0, ArgT... args) {
 
 product_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetSequencingKitsResponse.Kit.product_code)
}
inline std::string* GetSequencingKitsResponse_Kit::mutable_product_code() {
  std::string* _s = _internal_mutable_product_code();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.GetSequencingKitsResponse.Kit.product_code)
  return _s;
}
inline const std::string& GetSequencingKitsResponse_Kit::_internal_product_code() const {
  return product_code_.Get();
}
inline void GetSequencingKitsResponse_Kit::_internal_set_product_code(const std::string& value) {
  
  product_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetSequencingKitsResponse_Kit::_internal_mutable_product_code() {
  
  return product_code_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetSequencingKitsResponse_Kit::release_product_code() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.GetSequencingKitsResponse.Kit.product_code)
  return product_code_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetSequencingKitsResponse_Kit::set_allocated_product_code(std::string* product_code) {
  if (product_code != nullptr) {
    
  } else {
    
  }
  product_code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), product_code,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.GetSequencingKitsResponse.Kit.product_code)
}

// repeated int32 barcoding_expansion_kits = 2;
inline int GetSequencingKitsResponse_Kit::_internal_barcoding_expansion_kits_size() const {
  return barcoding_expansion_kits_.size();
}
inline int GetSequencingKitsResponse_Kit::barcoding_expansion_kits_size() const {
  return _internal_barcoding_expansion_kits_size();
}
inline void GetSequencingKitsResponse_Kit::clear_barcoding_expansion_kits() {
  barcoding_expansion_kits_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetSequencingKitsResponse_Kit::_internal_barcoding_expansion_kits(int index) const {
  return barcoding_expansion_kits_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetSequencingKitsResponse_Kit::barcoding_expansion_kits(int index) const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetSequencingKitsResponse.Kit.barcoding_expansion_kits)
  return _internal_barcoding_expansion_kits(index);
}
inline void GetSequencingKitsResponse_Kit::set_barcoding_expansion_kits(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  barcoding_expansion_kits_.Set(index, value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetSequencingKitsResponse.Kit.barcoding_expansion_kits)
}
inline void GetSequencingKitsResponse_Kit::_internal_add_barcoding_expansion_kits(::PROTOBUF_NAMESPACE_ID::int32 value) {
  barcoding_expansion_kits_.Add(value);
}
inline void GetSequencingKitsResponse_Kit::add_barcoding_expansion_kits(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_barcoding_expansion_kits(value);
  // @@protoc_insertion_point(field_add:minknow_api.manager.GetSequencingKitsResponse.Kit.barcoding_expansion_kits)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
GetSequencingKitsResponse_Kit::_internal_barcoding_expansion_kits() const {
  return barcoding_expansion_kits_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
GetSequencingKitsResponse_Kit::barcoding_expansion_kits() const {
  // @@protoc_insertion_point(field_list:minknow_api.manager.GetSequencingKitsResponse.Kit.barcoding_expansion_kits)
  return _internal_barcoding_expansion_kits();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
GetSequencingKitsResponse_Kit::_internal_mutable_barcoding_expansion_kits() {
  return &barcoding_expansion_kits_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
GetSequencingKitsResponse_Kit::mutable_barcoding_expansion_kits() {
  // @@protoc_insertion_point(field_mutable_list:minknow_api.manager.GetSequencingKitsResponse.Kit.barcoding_expansion_kits)
  return _internal_mutable_barcoding_expansion_kits();
}

// bool includes_barcoding = 3;
inline void GetSequencingKitsResponse_Kit::clear_includes_barcoding() {
  includes_barcoding_ = false;
}
inline bool GetSequencingKitsResponse_Kit::_internal_includes_barcoding() const {
  return includes_barcoding_;
}
inline bool GetSequencingKitsResponse_Kit::includes_barcoding() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetSequencingKitsResponse.Kit.includes_barcoding)
  return _internal_includes_barcoding();
}
inline void GetSequencingKitsResponse_Kit::_internal_set_includes_barcoding(bool value) {
  
  includes_barcoding_ = value;
}
inline void GetSequencingKitsResponse_Kit::set_includes_barcoding(bool value) {
  _internal_set_includes_barcoding(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetSequencingKitsResponse.Kit.includes_barcoding)
}

// bool lamp_kit = 16;
inline void GetSequencingKitsResponse_Kit::clear_lamp_kit() {
  lamp_kit_ = false;
}
inline bool GetSequencingKitsResponse_Kit::_internal_lamp_kit() const {
  return lamp_kit_;
}
inline bool GetSequencingKitsResponse_Kit::lamp_kit() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetSequencingKitsResponse.Kit.lamp_kit)
  return _internal_lamp_kit();
}
inline void GetSequencingKitsResponse_Kit::_internal_set_lamp_kit(bool value) {
  
  lamp_kit_ = value;
}
inline void GetSequencingKitsResponse_Kit::set_lamp_kit(bool value) {
  _internal_set_lamp_kit(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetSequencingKitsResponse.Kit.lamp_kit)
}

// bool has_control_protocol = 4;
inline void GetSequencingKitsResponse_Kit::clear_has_control_protocol() {
  has_control_protocol_ = false;
}
inline bool GetSequencingKitsResponse_Kit::_internal_has_control_protocol() const {
  return has_control_protocol_;
}
inline bool GetSequencingKitsResponse_Kit::has_control_protocol() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetSequencingKitsResponse.Kit.has_control_protocol)
  return _internal_has_control_protocol();
}
inline void GetSequencingKitsResponse_Kit::_internal_set_has_control_protocol(bool value) {
  
  has_control_protocol_ = value;
}
inline void GetSequencingKitsResponse_Kit::set_has_control_protocol(bool value) {
  _internal_set_has_control_protocol(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetSequencingKitsResponse.Kit.has_control_protocol)
}

// bool no_sequencing_protocol = 17;
inline void GetSequencingKitsResponse_Kit::clear_no_sequencing_protocol() {
  no_sequencing_protocol_ = false;
}
inline bool GetSequencingKitsResponse_Kit::_internal_no_sequencing_protocol() const {
  return no_sequencing_protocol_;
}
inline bool GetSequencingKitsResponse_Kit::no_sequencing_protocol() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetSequencingKitsResponse.Kit.no_sequencing_protocol)
  return _internal_no_sequencing_protocol();
}
inline void GetSequencingKitsResponse_Kit::_internal_set_no_sequencing_protocol(bool value) {
  
  no_sequencing_protocol_ = value;
}
inline void GetSequencingKitsResponse_Kit::set_no_sequencing_protocol(bool value) {
  _internal_set_no_sequencing_protocol(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetSequencingKitsResponse.Kit.no_sequencing_protocol)
}

// bool frequently_used = 18;
inline void GetSequencingKitsResponse_Kit::clear_frequently_used() {
  frequently_used_ = false;
}
inline bool GetSequencingKitsResponse_Kit::_internal_frequently_used() const {
  return frequently_used_;
}
inline bool GetSequencingKitsResponse_Kit::frequently_used() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetSequencingKitsResponse.Kit.frequently_used)
  return _internal_frequently_used();
}
inline void GetSequencingKitsResponse_Kit::_internal_set_frequently_used(bool value) {
  
  frequently_used_ = value;
}
inline void GetSequencingKitsResponse_Kit::set_frequently_used(bool value) {
  _internal_set_frequently_used(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetSequencingKitsResponse.Kit.frequently_used)
}

// bool dna = 5;
inline void GetSequencingKitsResponse_Kit::clear_dna() {
  dna_ = false;
}
inline bool GetSequencingKitsResponse_Kit::_internal_dna() const {
  return dna_;
}
inline bool GetSequencingKitsResponse_Kit::dna() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetSequencingKitsResponse.Kit.dna)
  return _internal_dna();
}
inline void GetSequencingKitsResponse_Kit::_internal_set_dna(bool value) {
  
  dna_ = value;
}
inline void GetSequencingKitsResponse_Kit::set_dna(bool value) {
  _internal_set_dna(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetSequencingKitsResponse.Kit.dna)
}

// bool rna = 6;
inline void GetSequencingKitsResponse_Kit::clear_rna() {
  rna_ = false;
}
inline bool GetSequencingKitsResponse_Kit::_internal_rna() const {
  return rna_;
}
inline bool GetSequencingKitsResponse_Kit::rna() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetSequencingKitsResponse.Kit.rna)
  return _internal_rna();
}
inline void GetSequencingKitsResponse_Kit::_internal_set_rna(bool value) {
  
  rna_ = value;
}
inline void GetSequencingKitsResponse_Kit::set_rna(bool value) {
  _internal_set_rna(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetSequencingKitsResponse.Kit.rna)
}

// bool pcr = 7;
inline void GetSequencingKitsResponse_Kit::clear_pcr() {
  pcr_ = false;
}
inline bool GetSequencingKitsResponse_Kit::_internal_pcr() const {
  return pcr_;
}
inline bool GetSequencingKitsResponse_Kit::pcr() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetSequencingKitsResponse.Kit.pcr)
  return _internal_pcr();
}
inline void GetSequencingKitsResponse_Kit::_internal_set_pcr(bool value) {
  
  pcr_ = value;
}
inline void GetSequencingKitsResponse_Kit::set_pcr(bool value) {
  _internal_set_pcr(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetSequencingKitsResponse.Kit.pcr)
}

// bool pcr_free = 8;
inline void GetSequencingKitsResponse_Kit::clear_pcr_free() {
  pcr_free_ = false;
}
inline bool GetSequencingKitsResponse_Kit::_internal_pcr_free() const {
  return pcr_free_;
}
inline bool GetSequencingKitsResponse_Kit::pcr_free() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetSequencingKitsResponse.Kit.pcr_free)
  return _internal_pcr_free();
}
inline void GetSequencingKitsResponse_Kit::_internal_set_pcr_free(bool value) {
  
  pcr_free_ = value;
}
inline void GetSequencingKitsResponse_Kit::set_pcr_free(bool value) {
  _internal_set_pcr_free(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetSequencingKitsResponse.Kit.pcr_free)
}

// -------------------------------------------------------------------

// GetSequencingKitsResponse_BarcodingExpansionKit

// string product_code = 1;
inline void GetSequencingKitsResponse_BarcodingExpansionKit::clear_product_code() {
  product_code_.ClearToEmpty();
}
inline const std::string& GetSequencingKitsResponse_BarcodingExpansionKit::product_code() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetSequencingKitsResponse.BarcodingExpansionKit.product_code)
  return _internal_product_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetSequencingKitsResponse_BarcodingExpansionKit::set_product_code(ArgT0&& arg0, ArgT... args) {
 
 product_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetSequencingKitsResponse.BarcodingExpansionKit.product_code)
}
inline std::string* GetSequencingKitsResponse_BarcodingExpansionKit::mutable_product_code() {
  std::string* _s = _internal_mutable_product_code();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.GetSequencingKitsResponse.BarcodingExpansionKit.product_code)
  return _s;
}
inline const std::string& GetSequencingKitsResponse_BarcodingExpansionKit::_internal_product_code() const {
  return product_code_.Get();
}
inline void GetSequencingKitsResponse_BarcodingExpansionKit::_internal_set_product_code(const std::string& value) {
  
  product_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetSequencingKitsResponse_BarcodingExpansionKit::_internal_mutable_product_code() {
  
  return product_code_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetSequencingKitsResponse_BarcodingExpansionKit::release_product_code() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.GetSequencingKitsResponse.BarcodingExpansionKit.product_code)
  return product_code_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetSequencingKitsResponse_BarcodingExpansionKit::set_allocated_product_code(std::string* product_code) {
  if (product_code != nullptr) {
    
  } else {
    
  }
  product_code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), product_code,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.GetSequencingKitsResponse.BarcodingExpansionKit.product_code)
}

// -------------------------------------------------------------------

// GetSequencingKitsResponse

// repeated .minknow_api.manager.GetSequencingKitsResponse.Kit kits = 1;
inline int GetSequencingKitsResponse::_internal_kits_size() const {
  return kits_.size();
}
inline int GetSequencingKitsResponse::kits_size() const {
  return _internal_kits_size();
}
inline void GetSequencingKitsResponse::clear_kits() {
  kits_.Clear();
}
inline ::minknow_api::manager::GetSequencingKitsResponse_Kit* GetSequencingKitsResponse::mutable_kits(int index) {
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.GetSequencingKitsResponse.kits)
  return kits_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::GetSequencingKitsResponse_Kit >*
GetSequencingKitsResponse::mutable_kits() {
  // @@protoc_insertion_point(field_mutable_list:minknow_api.manager.GetSequencingKitsResponse.kits)
  return &kits_;
}
inline const ::minknow_api::manager::GetSequencingKitsResponse_Kit& GetSequencingKitsResponse::_internal_kits(int index) const {
  return kits_.Get(index);
}
inline const ::minknow_api::manager::GetSequencingKitsResponse_Kit& GetSequencingKitsResponse::kits(int index) const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetSequencingKitsResponse.kits)
  return _internal_kits(index);
}
inline ::minknow_api::manager::GetSequencingKitsResponse_Kit* GetSequencingKitsResponse::_internal_add_kits() {
  return kits_.Add();
}
inline ::minknow_api::manager::GetSequencingKitsResponse_Kit* GetSequencingKitsResponse::add_kits() {
  ::minknow_api::manager::GetSequencingKitsResponse_Kit* _add = _internal_add_kits();
  // @@protoc_insertion_point(field_add:minknow_api.manager.GetSequencingKitsResponse.kits)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::GetSequencingKitsResponse_Kit >&
GetSequencingKitsResponse::kits() const {
  // @@protoc_insertion_point(field_list:minknow_api.manager.GetSequencingKitsResponse.kits)
  return kits_;
}

// repeated .minknow_api.manager.GetSequencingKitsResponse.BarcodingExpansionKit barcoding_expansion_kits = 2;
inline int GetSequencingKitsResponse::_internal_barcoding_expansion_kits_size() const {
  return barcoding_expansion_kits_.size();
}
inline int GetSequencingKitsResponse::barcoding_expansion_kits_size() const {
  return _internal_barcoding_expansion_kits_size();
}
inline void GetSequencingKitsResponse::clear_barcoding_expansion_kits() {
  barcoding_expansion_kits_.Clear();
}
inline ::minknow_api::manager::GetSequencingKitsResponse_BarcodingExpansionKit* GetSequencingKitsResponse::mutable_barcoding_expansion_kits(int index) {
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.GetSequencingKitsResponse.barcoding_expansion_kits)
  return barcoding_expansion_kits_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::GetSequencingKitsResponse_BarcodingExpansionKit >*
GetSequencingKitsResponse::mutable_barcoding_expansion_kits() {
  // @@protoc_insertion_point(field_mutable_list:minknow_api.manager.GetSequencingKitsResponse.barcoding_expansion_kits)
  return &barcoding_expansion_kits_;
}
inline const ::minknow_api::manager::GetSequencingKitsResponse_BarcodingExpansionKit& GetSequencingKitsResponse::_internal_barcoding_expansion_kits(int index) const {
  return barcoding_expansion_kits_.Get(index);
}
inline const ::minknow_api::manager::GetSequencingKitsResponse_BarcodingExpansionKit& GetSequencingKitsResponse::barcoding_expansion_kits(int index) const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetSequencingKitsResponse.barcoding_expansion_kits)
  return _internal_barcoding_expansion_kits(index);
}
inline ::minknow_api::manager::GetSequencingKitsResponse_BarcodingExpansionKit* GetSequencingKitsResponse::_internal_add_barcoding_expansion_kits() {
  return barcoding_expansion_kits_.Add();
}
inline ::minknow_api::manager::GetSequencingKitsResponse_BarcodingExpansionKit* GetSequencingKitsResponse::add_barcoding_expansion_kits() {
  ::minknow_api::manager::GetSequencingKitsResponse_BarcodingExpansionKit* _add = _internal_add_barcoding_expansion_kits();
  // @@protoc_insertion_point(field_add:minknow_api.manager.GetSequencingKitsResponse.barcoding_expansion_kits)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::GetSequencingKitsResponse_BarcodingExpansionKit >&
GetSequencingKitsResponse::barcoding_expansion_kits() const {
  // @@protoc_insertion_point(field_list:minknow_api.manager.GetSequencingKitsResponse.barcoding_expansion_kits)
  return barcoding_expansion_kits_;
}

// -------------------------------------------------------------------

// AddSimulatedDeviceRequest

// string name = 1 [(.minknow_api.rpc_required) = true];
inline void AddSimulatedDeviceRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& AddSimulatedDeviceRequest::name() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.AddSimulatedDeviceRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddSimulatedDeviceRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.manager.AddSimulatedDeviceRequest.name)
}
inline std::string* AddSimulatedDeviceRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.AddSimulatedDeviceRequest.name)
  return _s;
}
inline const std::string& AddSimulatedDeviceRequest::_internal_name() const {
  return name_.Get();
}
inline void AddSimulatedDeviceRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AddSimulatedDeviceRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AddSimulatedDeviceRequest::release_name() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.AddSimulatedDeviceRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AddSimulatedDeviceRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.AddSimulatedDeviceRequest.name)
}

// -------------------------------------------------------------------

// AddSimulatedDeviceResponse

// -------------------------------------------------------------------

// RemoveSimulatedDeviceRequest

// string name = 1 [(.minknow_api.rpc_required) = true];
inline void RemoveSimulatedDeviceRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& RemoveSimulatedDeviceRequest::name() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.RemoveSimulatedDeviceRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoveSimulatedDeviceRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.manager.RemoveSimulatedDeviceRequest.name)
}
inline std::string* RemoveSimulatedDeviceRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.RemoveSimulatedDeviceRequest.name)
  return _s;
}
inline const std::string& RemoveSimulatedDeviceRequest::_internal_name() const {
  return name_.Get();
}
inline void RemoveSimulatedDeviceRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RemoveSimulatedDeviceRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RemoveSimulatedDeviceRequest::release_name() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.RemoveSimulatedDeviceRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RemoveSimulatedDeviceRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.RemoveSimulatedDeviceRequest.name)
}

// -------------------------------------------------------------------

// RemoveSimulatedDeviceResponse

// -------------------------------------------------------------------

// LocalAuthenticationTokenPathRequest

// -------------------------------------------------------------------

// LocalAuthenticationTokenPathResponse

// string path = 1;
inline void LocalAuthenticationTokenPathResponse::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& LocalAuthenticationTokenPathResponse::path() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.LocalAuthenticationTokenPathResponse.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocalAuthenticationTokenPathResponse::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.manager.LocalAuthenticationTokenPathResponse.path)
}
inline std::string* LocalAuthenticationTokenPathResponse::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.LocalAuthenticationTokenPathResponse.path)
  return _s;
}
inline const std::string& LocalAuthenticationTokenPathResponse::_internal_path() const {
  return path_.Get();
}
inline void LocalAuthenticationTokenPathResponse::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LocalAuthenticationTokenPathResponse::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LocalAuthenticationTokenPathResponse::release_path() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.LocalAuthenticationTokenPathResponse.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LocalAuthenticationTokenPathResponse::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.LocalAuthenticationTokenPathResponse.path)
}

// -------------------------------------------------------------------

// GetAlignmentReferenceInformationRequest

// string path = 1;
inline void GetAlignmentReferenceInformationRequest::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& GetAlignmentReferenceInformationRequest::path() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetAlignmentReferenceInformationRequest.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetAlignmentReferenceInformationRequest::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetAlignmentReferenceInformationRequest.path)
}
inline std::string* GetAlignmentReferenceInformationRequest::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.GetAlignmentReferenceInformationRequest.path)
  return _s;
}
inline const std::string& GetAlignmentReferenceInformationRequest::_internal_path() const {
  return path_.Get();
}
inline void GetAlignmentReferenceInformationRequest::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetAlignmentReferenceInformationRequest::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetAlignmentReferenceInformationRequest::release_path() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.GetAlignmentReferenceInformationRequest.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetAlignmentReferenceInformationRequest::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.GetAlignmentReferenceInformationRequest.path)
}

// -------------------------------------------------------------------

// GetAlignmentReferenceInformationResponse

// float estimated_load_time_seconds = 1;
inline void GetAlignmentReferenceInformationResponse::clear_estimated_load_time_seconds() {
  estimated_load_time_seconds_ = 0;
}
inline float GetAlignmentReferenceInformationResponse::_internal_estimated_load_time_seconds() const {
  return estimated_load_time_seconds_;
}
inline float GetAlignmentReferenceInformationResponse::estimated_load_time_seconds() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetAlignmentReferenceInformationResponse.estimated_load_time_seconds)
  return _internal_estimated_load_time_seconds();
}
inline void GetAlignmentReferenceInformationResponse::_internal_set_estimated_load_time_seconds(float value) {
  
  estimated_load_time_seconds_ = value;
}
inline void GetAlignmentReferenceInformationResponse::set_estimated_load_time_seconds(float value) {
  _internal_set_estimated_load_time_seconds(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetAlignmentReferenceInformationResponse.estimated_load_time_seconds)
}

// uint64 estimated_reference_size_bases = 2;
inline void GetAlignmentReferenceInformationResponse::clear_estimated_reference_size_bases() {
  estimated_reference_size_bases_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetAlignmentReferenceInformationResponse::_internal_estimated_reference_size_bases() const {
  return estimated_reference_size_bases_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetAlignmentReferenceInformationResponse::estimated_reference_size_bases() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetAlignmentReferenceInformationResponse.estimated_reference_size_bases)
  return _internal_estimated_reference_size_bases();
}
inline void GetAlignmentReferenceInformationResponse::_internal_set_estimated_reference_size_bases(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  estimated_reference_size_bases_ = value;
}
inline void GetAlignmentReferenceInformationResponse::set_estimated_reference_size_bases(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_estimated_reference_size_bases(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetAlignmentReferenceInformationResponse.estimated_reference_size_bases)
}

// bool recommended_live_usage = 3;
inline void GetAlignmentReferenceInformationResponse::clear_recommended_live_usage() {
  recommended_live_usage_ = false;
}
inline bool GetAlignmentReferenceInformationResponse::_internal_recommended_live_usage() const {
  return recommended_live_usage_;
}
inline bool GetAlignmentReferenceInformationResponse::recommended_live_usage() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.GetAlignmentReferenceInformationResponse.recommended_live_usage)
  return _internal_recommended_live_usage();
}
inline void GetAlignmentReferenceInformationResponse::_internal_set_recommended_live_usage(bool value) {
  
  recommended_live_usage_ = value;
}
inline void GetAlignmentReferenceInformationResponse::set_recommended_live_usage(bool value) {
  _internal_set_recommended_live_usage(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.GetAlignmentReferenceInformationResponse.recommended_live_usage)
}

// -------------------------------------------------------------------

// AssociationDeviceCodeRequest

// string position_name = 1;
inline void AssociationDeviceCodeRequest::clear_position_name() {
  position_name_.ClearToEmpty();
}
inline const std::string& AssociationDeviceCodeRequest::position_name() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.AssociationDeviceCodeRequest.position_name)
  return _internal_position_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AssociationDeviceCodeRequest::set_position_name(ArgT0&& arg0, ArgT... args) {
 
 position_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.manager.AssociationDeviceCodeRequest.position_name)
}
inline std::string* AssociationDeviceCodeRequest::mutable_position_name() {
  std::string* _s = _internal_mutable_position_name();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.AssociationDeviceCodeRequest.position_name)
  return _s;
}
inline const std::string& AssociationDeviceCodeRequest::_internal_position_name() const {
  return position_name_.Get();
}
inline void AssociationDeviceCodeRequest::_internal_set_position_name(const std::string& value) {
  
  position_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AssociationDeviceCodeRequest::_internal_mutable_position_name() {
  
  return position_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AssociationDeviceCodeRequest::release_position_name() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.AssociationDeviceCodeRequest.position_name)
  return position_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AssociationDeviceCodeRequest::set_allocated_position_name(std::string* position_name) {
  if (position_name != nullptr) {
    
  } else {
    
  }
  position_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), position_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.AssociationDeviceCodeRequest.position_name)
}

// bool offline = 2;
inline void AssociationDeviceCodeRequest::clear_offline() {
  offline_ = false;
}
inline bool AssociationDeviceCodeRequest::_internal_offline() const {
  return offline_;
}
inline bool AssociationDeviceCodeRequest::offline() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.AssociationDeviceCodeRequest.offline)
  return _internal_offline();
}
inline void AssociationDeviceCodeRequest::_internal_set_offline(bool value) {
  
  offline_ = value;
}
inline void AssociationDeviceCodeRequest::set_offline(bool value) {
  _internal_set_offline(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.AssociationDeviceCodeRequest.offline)
}

// -------------------------------------------------------------------

// AssociationDeviceCodeResponse

// string code = 1;
inline void AssociationDeviceCodeResponse::clear_code() {
  code_.ClearToEmpty();
}
inline const std::string& AssociationDeviceCodeResponse::code() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.AssociationDeviceCodeResponse.code)
  return _internal_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AssociationDeviceCodeResponse::set_code(ArgT0&& arg0, ArgT... args) {
 
 code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.manager.AssociationDeviceCodeResponse.code)
}
inline std::string* AssociationDeviceCodeResponse::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.AssociationDeviceCodeResponse.code)
  return _s;
}
inline const std::string& AssociationDeviceCodeResponse::_internal_code() const {
  return code_.Get();
}
inline void AssociationDeviceCodeResponse::_internal_set_code(const std::string& value) {
  
  code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AssociationDeviceCodeResponse::_internal_mutable_code() {
  
  return code_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AssociationDeviceCodeResponse::release_code() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.AssociationDeviceCodeResponse.code)
  return code_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AssociationDeviceCodeResponse::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    
  } else {
    
  }
  code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), code,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.AssociationDeviceCodeResponse.code)
}

// -------------------------------------------------------------------

// ApplyOfflineAssociationUnlockCodeRequest

// string position_name = 1;
inline void ApplyOfflineAssociationUnlockCodeRequest::clear_position_name() {
  position_name_.ClearToEmpty();
}
inline const std::string& ApplyOfflineAssociationUnlockCodeRequest::position_name() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.ApplyOfflineAssociationUnlockCodeRequest.position_name)
  return _internal_position_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ApplyOfflineAssociationUnlockCodeRequest::set_position_name(ArgT0&& arg0, ArgT... args) {
 
 position_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.manager.ApplyOfflineAssociationUnlockCodeRequest.position_name)
}
inline std::string* ApplyOfflineAssociationUnlockCodeRequest::mutable_position_name() {
  std::string* _s = _internal_mutable_position_name();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.ApplyOfflineAssociationUnlockCodeRequest.position_name)
  return _s;
}
inline const std::string& ApplyOfflineAssociationUnlockCodeRequest::_internal_position_name() const {
  return position_name_.Get();
}
inline void ApplyOfflineAssociationUnlockCodeRequest::_internal_set_position_name(const std::string& value) {
  
  position_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ApplyOfflineAssociationUnlockCodeRequest::_internal_mutable_position_name() {
  
  return position_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ApplyOfflineAssociationUnlockCodeRequest::release_position_name() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.ApplyOfflineAssociationUnlockCodeRequest.position_name)
  return position_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ApplyOfflineAssociationUnlockCodeRequest::set_allocated_position_name(std::string* position_name) {
  if (position_name != nullptr) {
    
  } else {
    
  }
  position_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), position_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.ApplyOfflineAssociationUnlockCodeRequest.position_name)
}

// string unlock_code = 2;
inline void ApplyOfflineAssociationUnlockCodeRequest::clear_unlock_code() {
  unlock_code_.ClearToEmpty();
}
inline const std::string& ApplyOfflineAssociationUnlockCodeRequest::unlock_code() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.ApplyOfflineAssociationUnlockCodeRequest.unlock_code)
  return _internal_unlock_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ApplyOfflineAssociationUnlockCodeRequest::set_unlock_code(ArgT0&& arg0, ArgT... args) {
 
 unlock_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.manager.ApplyOfflineAssociationUnlockCodeRequest.unlock_code)
}
inline std::string* ApplyOfflineAssociationUnlockCodeRequest::mutable_unlock_code() {
  std::string* _s = _internal_mutable_unlock_code();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.ApplyOfflineAssociationUnlockCodeRequest.unlock_code)
  return _s;
}
inline const std::string& ApplyOfflineAssociationUnlockCodeRequest::_internal_unlock_code() const {
  return unlock_code_.Get();
}
inline void ApplyOfflineAssociationUnlockCodeRequest::_internal_set_unlock_code(const std::string& value) {
  
  unlock_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ApplyOfflineAssociationUnlockCodeRequest::_internal_mutable_unlock_code() {
  
  return unlock_code_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ApplyOfflineAssociationUnlockCodeRequest::release_unlock_code() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.ApplyOfflineAssociationUnlockCodeRequest.unlock_code)
  return unlock_code_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ApplyOfflineAssociationUnlockCodeRequest::set_allocated_unlock_code(std::string* unlock_code) {
  if (unlock_code != nullptr) {
    
  } else {
    
  }
  unlock_code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), unlock_code,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.ApplyOfflineAssociationUnlockCodeRequest.unlock_code)
}

// -------------------------------------------------------------------

// ApplyOfflineAssociationUnlockCodeResponse

// bool associated = 1;
inline void ApplyOfflineAssociationUnlockCodeResponse::clear_associated() {
  associated_ = false;
}
inline bool ApplyOfflineAssociationUnlockCodeResponse::_internal_associated() const {
  return associated_;
}
inline bool ApplyOfflineAssociationUnlockCodeResponse::associated() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.ApplyOfflineAssociationUnlockCodeResponse.associated)
  return _internal_associated();
}
inline void ApplyOfflineAssociationUnlockCodeResponse::_internal_set_associated(bool value) {
  
  associated_ = value;
}
inline void ApplyOfflineAssociationUnlockCodeResponse::set_associated(bool value) {
  _internal_set_associated(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.ApplyOfflineAssociationUnlockCodeResponse.associated)
}

// -------------------------------------------------------------------

// ListDeveloperApiTokensRequest

// -------------------------------------------------------------------

// ListDeveloperApiTokensResponse_DeveloperApiToken

// string id = 1;
inline void ListDeveloperApiTokensResponse_DeveloperApiToken::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& ListDeveloperApiTokensResponse_DeveloperApiToken::id() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.ListDeveloperApiTokensResponse.DeveloperApiToken.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListDeveloperApiTokensResponse_DeveloperApiToken::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.manager.ListDeveloperApiTokensResponse.DeveloperApiToken.id)
}
inline std::string* ListDeveloperApiTokensResponse_DeveloperApiToken::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.ListDeveloperApiTokensResponse.DeveloperApiToken.id)
  return _s;
}
inline const std::string& ListDeveloperApiTokensResponse_DeveloperApiToken::_internal_id() const {
  return id_.Get();
}
inline void ListDeveloperApiTokensResponse_DeveloperApiToken::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListDeveloperApiTokensResponse_DeveloperApiToken::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListDeveloperApiTokensResponse_DeveloperApiToken::release_id() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.ListDeveloperApiTokensResponse.DeveloperApiToken.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListDeveloperApiTokensResponse_DeveloperApiToken::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.ListDeveloperApiTokensResponse.DeveloperApiToken.id)
}

// string name = 2;
inline void ListDeveloperApiTokensResponse_DeveloperApiToken::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ListDeveloperApiTokensResponse_DeveloperApiToken::name() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.ListDeveloperApiTokensResponse.DeveloperApiToken.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListDeveloperApiTokensResponse_DeveloperApiToken::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.manager.ListDeveloperApiTokensResponse.DeveloperApiToken.name)
}
inline std::string* ListDeveloperApiTokensResponse_DeveloperApiToken::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.ListDeveloperApiTokensResponse.DeveloperApiToken.name)
  return _s;
}
inline const std::string& ListDeveloperApiTokensResponse_DeveloperApiToken::_internal_name() const {
  return name_.Get();
}
inline void ListDeveloperApiTokensResponse_DeveloperApiToken::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListDeveloperApiTokensResponse_DeveloperApiToken::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListDeveloperApiTokensResponse_DeveloperApiToken::release_name() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.ListDeveloperApiTokensResponse.DeveloperApiToken.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListDeveloperApiTokensResponse_DeveloperApiToken::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.ListDeveloperApiTokensResponse.DeveloperApiToken.name)
}

// .google.protobuf.Timestamp expiry = 3;
inline bool ListDeveloperApiTokensResponse_DeveloperApiToken::_internal_has_expiry() const {
  return this != internal_default_instance() && expiry_ != nullptr;
}
inline bool ListDeveloperApiTokensResponse_DeveloperApiToken::has_expiry() const {
  return _internal_has_expiry();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ListDeveloperApiTokensResponse_DeveloperApiToken::_internal_expiry() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = expiry_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ListDeveloperApiTokensResponse_DeveloperApiToken::expiry() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.ListDeveloperApiTokensResponse.DeveloperApiToken.expiry)
  return _internal_expiry();
}
inline void ListDeveloperApiTokensResponse_DeveloperApiToken::unsafe_arena_set_allocated_expiry(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* expiry) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expiry_);
  }
  expiry_ = expiry;
  if (expiry) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minknow_api.manager.ListDeveloperApiTokensResponse.DeveloperApiToken.expiry)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListDeveloperApiTokensResponse_DeveloperApiToken::release_expiry() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = expiry_;
  expiry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListDeveloperApiTokensResponse_DeveloperApiToken::unsafe_arena_release_expiry() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.ListDeveloperApiTokensResponse.DeveloperApiToken.expiry)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = expiry_;
  expiry_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListDeveloperApiTokensResponse_DeveloperApiToken::_internal_mutable_expiry() {
  
  if (expiry_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    expiry_ = p;
  }
  return expiry_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListDeveloperApiTokensResponse_DeveloperApiToken::mutable_expiry() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_expiry();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.ListDeveloperApiTokensResponse.DeveloperApiToken.expiry)
  return _msg;
}
inline void ListDeveloperApiTokensResponse_DeveloperApiToken::set_allocated_expiry(::PROTOBUF_NAMESPACE_ID::Timestamp* expiry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(expiry_);
  }
  if (expiry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expiry));
    if (message_arena != submessage_arena) {
      expiry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expiry, submessage_arena);
    }
    
  } else {
    
  }
  expiry_ = expiry;
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.ListDeveloperApiTokensResponse.DeveloperApiToken.expiry)
}

// -------------------------------------------------------------------

// ListDeveloperApiTokensResponse

// repeated .minknow_api.manager.ListDeveloperApiTokensResponse.DeveloperApiToken tokens = 1;
inline int ListDeveloperApiTokensResponse::_internal_tokens_size() const {
  return tokens_.size();
}
inline int ListDeveloperApiTokensResponse::tokens_size() const {
  return _internal_tokens_size();
}
inline void ListDeveloperApiTokensResponse::clear_tokens() {
  tokens_.Clear();
}
inline ::minknow_api::manager::ListDeveloperApiTokensResponse_DeveloperApiToken* ListDeveloperApiTokensResponse::mutable_tokens(int index) {
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.ListDeveloperApiTokensResponse.tokens)
  return tokens_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::ListDeveloperApiTokensResponse_DeveloperApiToken >*
ListDeveloperApiTokensResponse::mutable_tokens() {
  // @@protoc_insertion_point(field_mutable_list:minknow_api.manager.ListDeveloperApiTokensResponse.tokens)
  return &tokens_;
}
inline const ::minknow_api::manager::ListDeveloperApiTokensResponse_DeveloperApiToken& ListDeveloperApiTokensResponse::_internal_tokens(int index) const {
  return tokens_.Get(index);
}
inline const ::minknow_api::manager::ListDeveloperApiTokensResponse_DeveloperApiToken& ListDeveloperApiTokensResponse::tokens(int index) const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.ListDeveloperApiTokensResponse.tokens)
  return _internal_tokens(index);
}
inline ::minknow_api::manager::ListDeveloperApiTokensResponse_DeveloperApiToken* ListDeveloperApiTokensResponse::_internal_add_tokens() {
  return tokens_.Add();
}
inline ::minknow_api::manager::ListDeveloperApiTokensResponse_DeveloperApiToken* ListDeveloperApiTokensResponse::add_tokens() {
  ::minknow_api::manager::ListDeveloperApiTokensResponse_DeveloperApiToken* _add = _internal_add_tokens();
  // @@protoc_insertion_point(field_add:minknow_api.manager.ListDeveloperApiTokensResponse.tokens)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::ListDeveloperApiTokensResponse_DeveloperApiToken >&
ListDeveloperApiTokensResponse::tokens() const {
  // @@protoc_insertion_point(field_list:minknow_api.manager.ListDeveloperApiTokensResponse.tokens)
  return tokens_;
}

// -------------------------------------------------------------------

// CreateDeveloperApiTokenRequest

// string name = 2;
inline void CreateDeveloperApiTokenRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CreateDeveloperApiTokenRequest::name() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.CreateDeveloperApiTokenRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateDeveloperApiTokenRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.manager.CreateDeveloperApiTokenRequest.name)
}
inline std::string* CreateDeveloperApiTokenRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.CreateDeveloperApiTokenRequest.name)
  return _s;
}
inline const std::string& CreateDeveloperApiTokenRequest::_internal_name() const {
  return name_.Get();
}
inline void CreateDeveloperApiTokenRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateDeveloperApiTokenRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateDeveloperApiTokenRequest::release_name() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.CreateDeveloperApiTokenRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateDeveloperApiTokenRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.CreateDeveloperApiTokenRequest.name)
}

// .google.protobuf.Timestamp expiry = 3;
inline bool CreateDeveloperApiTokenRequest::_internal_has_expiry() const {
  return this != internal_default_instance() && expiry_ != nullptr;
}
inline bool CreateDeveloperApiTokenRequest::has_expiry() const {
  return _internal_has_expiry();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CreateDeveloperApiTokenRequest::_internal_expiry() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = expiry_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CreateDeveloperApiTokenRequest::expiry() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.CreateDeveloperApiTokenRequest.expiry)
  return _internal_expiry();
}
inline void CreateDeveloperApiTokenRequest::unsafe_arena_set_allocated_expiry(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* expiry) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expiry_);
  }
  expiry_ = expiry;
  if (expiry) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minknow_api.manager.CreateDeveloperApiTokenRequest.expiry)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CreateDeveloperApiTokenRequest::release_expiry() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = expiry_;
  expiry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CreateDeveloperApiTokenRequest::unsafe_arena_release_expiry() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.CreateDeveloperApiTokenRequest.expiry)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = expiry_;
  expiry_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CreateDeveloperApiTokenRequest::_internal_mutable_expiry() {
  
  if (expiry_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    expiry_ = p;
  }
  return expiry_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CreateDeveloperApiTokenRequest::mutable_expiry() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_expiry();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.CreateDeveloperApiTokenRequest.expiry)
  return _msg;
}
inline void CreateDeveloperApiTokenRequest::set_allocated_expiry(::PROTOBUF_NAMESPACE_ID::Timestamp* expiry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(expiry_);
  }
  if (expiry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expiry));
    if (message_arena != submessage_arena) {
      expiry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expiry, submessage_arena);
    }
    
  } else {
    
  }
  expiry_ = expiry;
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.CreateDeveloperApiTokenRequest.expiry)
}

// -------------------------------------------------------------------

// CreateDeveloperApiTokenResponse

// string id = 1;
inline void CreateDeveloperApiTokenResponse::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& CreateDeveloperApiTokenResponse::id() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.CreateDeveloperApiTokenResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateDeveloperApiTokenResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.manager.CreateDeveloperApiTokenResponse.id)
}
inline std::string* CreateDeveloperApiTokenResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.CreateDeveloperApiTokenResponse.id)
  return _s;
}
inline const std::string& CreateDeveloperApiTokenResponse::_internal_id() const {
  return id_.Get();
}
inline void CreateDeveloperApiTokenResponse::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateDeveloperApiTokenResponse::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateDeveloperApiTokenResponse::release_id() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.CreateDeveloperApiTokenResponse.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateDeveloperApiTokenResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.CreateDeveloperApiTokenResponse.id)
}

// string token = 2;
inline void CreateDeveloperApiTokenResponse::clear_token() {
  token_.ClearToEmpty();
}
inline const std::string& CreateDeveloperApiTokenResponse::token() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.CreateDeveloperApiTokenResponse.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateDeveloperApiTokenResponse::set_token(ArgT0&& arg0, ArgT... args) {
 
 token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.manager.CreateDeveloperApiTokenResponse.token)
}
inline std::string* CreateDeveloperApiTokenResponse::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.CreateDeveloperApiTokenResponse.token)
  return _s;
}
inline const std::string& CreateDeveloperApiTokenResponse::_internal_token() const {
  return token_.Get();
}
inline void CreateDeveloperApiTokenResponse::_internal_set_token(const std::string& value) {
  
  token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateDeveloperApiTokenResponse::_internal_mutable_token() {
  
  return token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateDeveloperApiTokenResponse::release_token() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.CreateDeveloperApiTokenResponse.token)
  return token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateDeveloperApiTokenResponse::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.CreateDeveloperApiTokenResponse.token)
}

// -------------------------------------------------------------------

// RevokeDeveloperApiTokenRequest

// string id = 1;
inline void RevokeDeveloperApiTokenRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& RevokeDeveloperApiTokenRequest::id() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.RevokeDeveloperApiTokenRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RevokeDeveloperApiTokenRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.manager.RevokeDeveloperApiTokenRequest.id)
}
inline std::string* RevokeDeveloperApiTokenRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.RevokeDeveloperApiTokenRequest.id)
  return _s;
}
inline const std::string& RevokeDeveloperApiTokenRequest::_internal_id() const {
  return id_.Get();
}
inline void RevokeDeveloperApiTokenRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RevokeDeveloperApiTokenRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RevokeDeveloperApiTokenRequest::release_id() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.RevokeDeveloperApiTokenRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RevokeDeveloperApiTokenRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.RevokeDeveloperApiTokenRequest.id)
}

// -------------------------------------------------------------------

// RevokeDeveloperApiTokensResponse

// -------------------------------------------------------------------

// FindProtocolsRequest

// string flow_cell_product_code = 1;
inline void FindProtocolsRequest::clear_flow_cell_product_code() {
  flow_cell_product_code_.ClearToEmpty();
}
inline const std::string& FindProtocolsRequest::flow_cell_product_code() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.FindProtocolsRequest.flow_cell_product_code)
  return _internal_flow_cell_product_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FindProtocolsRequest::set_flow_cell_product_code(ArgT0&& arg0, ArgT... args) {
 
 flow_cell_product_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.manager.FindProtocolsRequest.flow_cell_product_code)
}
inline std::string* FindProtocolsRequest::mutable_flow_cell_product_code() {
  std::string* _s = _internal_mutable_flow_cell_product_code();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.FindProtocolsRequest.flow_cell_product_code)
  return _s;
}
inline const std::string& FindProtocolsRequest::_internal_flow_cell_product_code() const {
  return flow_cell_product_code_.Get();
}
inline void FindProtocolsRequest::_internal_set_flow_cell_product_code(const std::string& value) {
  
  flow_cell_product_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FindProtocolsRequest::_internal_mutable_flow_cell_product_code() {
  
  return flow_cell_product_code_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FindProtocolsRequest::release_flow_cell_product_code() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.FindProtocolsRequest.flow_cell_product_code)
  return flow_cell_product_code_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FindProtocolsRequest::set_allocated_flow_cell_product_code(std::string* flow_cell_product_code) {
  if (flow_cell_product_code != nullptr) {
    
  } else {
    
  }
  flow_cell_product_code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), flow_cell_product_code,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.FindProtocolsRequest.flow_cell_product_code)
}

// string sequencing_kit = 2;
inline void FindProtocolsRequest::clear_sequencing_kit() {
  sequencing_kit_.ClearToEmpty();
}
inline const std::string& FindProtocolsRequest::sequencing_kit() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.FindProtocolsRequest.sequencing_kit)
  return _internal_sequencing_kit();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FindProtocolsRequest::set_sequencing_kit(ArgT0&& arg0, ArgT... args) {
 
 sequencing_kit_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.manager.FindProtocolsRequest.sequencing_kit)
}
inline std::string* FindProtocolsRequest::mutable_sequencing_kit() {
  std::string* _s = _internal_mutable_sequencing_kit();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.FindProtocolsRequest.sequencing_kit)
  return _s;
}
inline const std::string& FindProtocolsRequest::_internal_sequencing_kit() const {
  return sequencing_kit_.Get();
}
inline void FindProtocolsRequest::_internal_set_sequencing_kit(const std::string& value) {
  
  sequencing_kit_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FindProtocolsRequest::_internal_mutable_sequencing_kit() {
  
  return sequencing_kit_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FindProtocolsRequest::release_sequencing_kit() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.FindProtocolsRequest.sequencing_kit)
  return sequencing_kit_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FindProtocolsRequest::set_allocated_sequencing_kit(std::string* sequencing_kit) {
  if (sequencing_kit != nullptr) {
    
  } else {
    
  }
  sequencing_kit_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sequencing_kit,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.FindProtocolsRequest.sequencing_kit)
}

// .minknow_api.manager.ExperimentType experiment_type = 3;
inline void FindProtocolsRequest::clear_experiment_type() {
  experiment_type_ = 0;
}
inline ::minknow_api::manager::ExperimentType FindProtocolsRequest::_internal_experiment_type() const {
  return static_cast< ::minknow_api::manager::ExperimentType >(experiment_type_);
}
inline ::minknow_api::manager::ExperimentType FindProtocolsRequest::experiment_type() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.FindProtocolsRequest.experiment_type)
  return _internal_experiment_type();
}
inline void FindProtocolsRequest::_internal_set_experiment_type(::minknow_api::manager::ExperimentType value) {
  
  experiment_type_ = value;
}
inline void FindProtocolsRequest::set_experiment_type(::minknow_api::manager::ExperimentType value) {
  _internal_set_experiment_type(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.FindProtocolsRequest.experiment_type)
}

// -------------------------------------------------------------------

// FindProtocolsResponse_Protocol

// string identifier = 1;
inline void FindProtocolsResponse_Protocol::clear_identifier() {
  identifier_.ClearToEmpty();
}
inline const std::string& FindProtocolsResponse_Protocol::identifier() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.FindProtocolsResponse.Protocol.identifier)
  return _internal_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FindProtocolsResponse_Protocol::set_identifier(ArgT0&& arg0, ArgT... args) {
 
 identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minknow_api.manager.FindProtocolsResponse.Protocol.identifier)
}
inline std::string* FindProtocolsResponse_Protocol::mutable_identifier() {
  std::string* _s = _internal_mutable_identifier();
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.FindProtocolsResponse.Protocol.identifier)
  return _s;
}
inline const std::string& FindProtocolsResponse_Protocol::_internal_identifier() const {
  return identifier_.Get();
}
inline void FindProtocolsResponse_Protocol::_internal_set_identifier(const std::string& value) {
  
  identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FindProtocolsResponse_Protocol::_internal_mutable_identifier() {
  
  return identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FindProtocolsResponse_Protocol::release_identifier() {
  // @@protoc_insertion_point(field_release:minknow_api.manager.FindProtocolsResponse.Protocol.identifier)
  return identifier_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FindProtocolsResponse_Protocol::set_allocated_identifier(std::string* identifier) {
  if (identifier != nullptr) {
    
  } else {
    
  }
  identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), identifier,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minknow_api.manager.FindProtocolsResponse.Protocol.identifier)
}

// bool requires_flow_cell_product_code = 2;
inline void FindProtocolsResponse_Protocol::clear_requires_flow_cell_product_code() {
  requires_flow_cell_product_code_ = false;
}
inline bool FindProtocolsResponse_Protocol::_internal_requires_flow_cell_product_code() const {
  return requires_flow_cell_product_code_;
}
inline bool FindProtocolsResponse_Protocol::requires_flow_cell_product_code() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.FindProtocolsResponse.Protocol.requires_flow_cell_product_code)
  return _internal_requires_flow_cell_product_code();
}
inline void FindProtocolsResponse_Protocol::_internal_set_requires_flow_cell_product_code(bool value) {
  
  requires_flow_cell_product_code_ = value;
}
inline void FindProtocolsResponse_Protocol::set_requires_flow_cell_product_code(bool value) {
  _internal_set_requires_flow_cell_product_code(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.FindProtocolsResponse.Protocol.requires_flow_cell_product_code)
}

// bool requires_sequencing_kit = 3;
inline void FindProtocolsResponse_Protocol::clear_requires_sequencing_kit() {
  requires_sequencing_kit_ = false;
}
inline bool FindProtocolsResponse_Protocol::_internal_requires_sequencing_kit() const {
  return requires_sequencing_kit_;
}
inline bool FindProtocolsResponse_Protocol::requires_sequencing_kit() const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.FindProtocolsResponse.Protocol.requires_sequencing_kit)
  return _internal_requires_sequencing_kit();
}
inline void FindProtocolsResponse_Protocol::_internal_set_requires_sequencing_kit(bool value) {
  
  requires_sequencing_kit_ = value;
}
inline void FindProtocolsResponse_Protocol::set_requires_sequencing_kit(bool value) {
  _internal_set_requires_sequencing_kit(value);
  // @@protoc_insertion_point(field_set:minknow_api.manager.FindProtocolsResponse.Protocol.requires_sequencing_kit)
}

// -------------------------------------------------------------------

// FindProtocolsResponse

// repeated .minknow_api.manager.FindProtocolsResponse.Protocol protocols = 1;
inline int FindProtocolsResponse::_internal_protocols_size() const {
  return protocols_.size();
}
inline int FindProtocolsResponse::protocols_size() const {
  return _internal_protocols_size();
}
inline void FindProtocolsResponse::clear_protocols() {
  protocols_.Clear();
}
inline ::minknow_api::manager::FindProtocolsResponse_Protocol* FindProtocolsResponse::mutable_protocols(int index) {
  // @@protoc_insertion_point(field_mutable:minknow_api.manager.FindProtocolsResponse.protocols)
  return protocols_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::FindProtocolsResponse_Protocol >*
FindProtocolsResponse::mutable_protocols() {
  // @@protoc_insertion_point(field_mutable_list:minknow_api.manager.FindProtocolsResponse.protocols)
  return &protocols_;
}
inline const ::minknow_api::manager::FindProtocolsResponse_Protocol& FindProtocolsResponse::_internal_protocols(int index) const {
  return protocols_.Get(index);
}
inline const ::minknow_api::manager::FindProtocolsResponse_Protocol& FindProtocolsResponse::protocols(int index) const {
  // @@protoc_insertion_point(field_get:minknow_api.manager.FindProtocolsResponse.protocols)
  return _internal_protocols(index);
}
inline ::minknow_api::manager::FindProtocolsResponse_Protocol* FindProtocolsResponse::_internal_add_protocols() {
  return protocols_.Add();
}
inline ::minknow_api::manager::FindProtocolsResponse_Protocol* FindProtocolsResponse::add_protocols() {
  ::minknow_api::manager::FindProtocolsResponse_Protocol* _add = _internal_add_protocols();
  // @@protoc_insertion_point(field_add:minknow_api.manager.FindProtocolsResponse.protocols)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minknow_api::manager::FindProtocolsResponse_Protocol >&
FindProtocolsResponse::protocols() const {
  // @@protoc_insertion_point(field_list:minknow_api.manager.FindProtocolsResponse.protocols)
  return protocols_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace manager
}  // namespace minknow_api

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::minknow_api::manager::FlowCellPosition_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::minknow_api::manager::FlowCellPosition_State>() {
  return ::minknow_api::manager::FlowCellPosition_State_descriptor();
}
template <> struct is_proto_enum< ::minknow_api::manager::GetVersionInfoResponse_InstallationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::minknow_api::manager::GetVersionInfoResponse_InstallationType>() {
  return ::minknow_api::manager::GetVersionInfoResponse_InstallationType_descriptor();
}
template <> struct is_proto_enum< ::minknow_api::manager::ExperimentType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::minknow_api::manager::ExperimentType>() {
  return ::minknow_api::manager::ExperimentType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_minknow_5fapi_2fmanager_2eproto
