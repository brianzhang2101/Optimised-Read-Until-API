// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: minknow_api/protocol.proto
#ifndef GRPC_minknow_5fapi_2fprotocol_2eproto__INCLUDED
#define GRPC_minknow_5fapi_2fprotocol_2eproto__INCLUDED

#include "minknow_api/protocol.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace minknow_api {
namespace protocol {

class ProtocolService final {
 public:
  static constexpr char const* service_full_name() {
    return "minknow_api.protocol.ProtocolService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Initiates a python instance that runs the script specified by the `path` argument.
    // `list_protocols` will give back a list of protocol scripts that can be started by this call
    virtual ::grpc::Status start_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::StartProtocolRequest& request, ::minknow_api::protocol::StartProtocolResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::StartProtocolResponse>> Asyncstart_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::StartProtocolRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::StartProtocolResponse>>(Asyncstart_protocolRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::StartProtocolResponse>> PrepareAsyncstart_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::StartProtocolRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::StartProtocolResponse>>(PrepareAsyncstart_protocolRaw(context, request, cq));
    }
    // Stops the currently running protocol script instance.
    virtual ::grpc::Status stop_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::StopProtocolRequest& request, ::minknow_api::protocol::StopProtocolResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::StopProtocolResponse>> Asyncstop_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::StopProtocolRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::StopProtocolResponse>>(Asyncstop_protocolRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::StopProtocolResponse>> PrepareAsyncstop_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::StopProtocolRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::StopProtocolResponse>>(PrepareAsyncstop_protocolRaw(context, request, cq));
    }
    // Request the protocol to pause.
    //
    // This will return an error unless the ProtocolRunInfo has the `can_pause` field set to true.
    // It will have no effect if the protocol is already paused or pausing.
    //
    // Since 4.4.
    virtual ::grpc::Status pause_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::PauseProtocolRequest& request, ::minknow_api::protocol::PauseProtocolResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::PauseProtocolResponse>> Asyncpause_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::PauseProtocolRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::PauseProtocolResponse>>(Asyncpause_protocolRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::PauseProtocolResponse>> PrepareAsyncpause_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::PauseProtocolRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::PauseProtocolResponse>>(PrepareAsyncpause_protocolRaw(context, request, cq));
    }
    // Request the protocol to resume.
    //
    // This will return an error unless the ProtocolRunInfo has the `can_pause` field set to true.
    // It will have no effect if the protocol is not paused or pausing.
    //
    // Since 4.4.
    virtual ::grpc::Status resume_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::ResumeProtocolRequest& request, ::minknow_api::protocol::ResumeProtocolResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ResumeProtocolResponse>> Asyncresume_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::ResumeProtocolRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ResumeProtocolResponse>>(Asyncresume_protocolRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ResumeProtocolResponse>> PrepareAsyncresume_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::ResumeProtocolRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ResumeProtocolResponse>>(PrepareAsyncresume_protocolRaw(context, request, cq));
    }
    // Request the protocol to perform a mux scan.
    //
    // This will return an error unless the ProtocolRunInfo has the `can_trigger_mux_scan` field set
    // to true. It will have no effect if the protocol is already running or preparing for a mux
    // scan.
    //
    // Since 4.4.
    virtual ::grpc::Status trigger_mux_scan(::grpc::ClientContext* context, const ::minknow_api::protocol::TriggerMuxScanRequest& request, ::minknow_api::protocol::TriggerMuxScanResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::TriggerMuxScanResponse>> Asynctrigger_mux_scan(::grpc::ClientContext* context, const ::minknow_api::protocol::TriggerMuxScanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::TriggerMuxScanResponse>>(Asynctrigger_mux_scanRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::TriggerMuxScanResponse>> PrepareAsynctrigger_mux_scan(::grpc::ClientContext* context, const ::minknow_api::protocol::TriggerMuxScanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::TriggerMuxScanResponse>>(PrepareAsynctrigger_mux_scanRaw(context, request, cq));
    }
    // Wait for a protocol run to finish.
    //
    // The call blocks until the run with the given run ID has finished (or returns immediately if
    // it had already finished) and returns information about the protocol run.
    //
    // If no run has been started with the provided run ID (or no run ID is given), an error is
    // returned.
    //
    // If NOTIFY_BEFORE_TERMINATION is specified for state, the protocol end time is an estimate, including
    // the allowed timeout.
    //
    // Since 1.10
    virtual ::grpc::Status wait_for_finished(::grpc::ClientContext* context, const ::minknow_api::protocol::WaitForFinishedRequest& request, ::minknow_api::protocol::ProtocolRunInfo* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ProtocolRunInfo>> Asyncwait_for_finished(::grpc::ClientContext* context, const ::minknow_api::protocol::WaitForFinishedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ProtocolRunInfo>>(Asyncwait_for_finishedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ProtocolRunInfo>> PrepareAsyncwait_for_finished(::grpc::ClientContext* context, const ::minknow_api::protocol::WaitForFinishedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ProtocolRunInfo>>(PrepareAsyncwait_for_finishedRaw(context, request, cq));
    }
    // Gets information about a protocol run.
    //
    // If no run ID is provided, information about the most recently started protocol run is
    // provided.
    //
    // Since 1.10
    virtual ::grpc::Status get_run_info(::grpc::ClientContext* context, const ::minknow_api::protocol::GetRunInfoRequest& request, ::minknow_api::protocol::ProtocolRunInfo* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ProtocolRunInfo>> Asyncget_run_info(::grpc::ClientContext* context, const ::minknow_api::protocol::GetRunInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ProtocolRunInfo>>(Asyncget_run_infoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ProtocolRunInfo>> PrepareAsyncget_run_info(::grpc::ClientContext* context, const ::minknow_api::protocol::GetRunInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ProtocolRunInfo>>(PrepareAsyncget_run_infoRaw(context, request, cq));
    }
    // List previously started protocol run ids (including any current protocol), in order of starting.
    //
    // The returned object can be used to find protocol information with get_run_info.
    //
    // Since 1.11
    virtual ::grpc::Status list_protocol_runs(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolRunsRequest& request, ::minknow_api::protocol::ListProtocolRunsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ListProtocolRunsResponse>> Asynclist_protocol_runs(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolRunsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ListProtocolRunsResponse>>(Asynclist_protocol_runsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ListProtocolRunsResponse>> PrepareAsynclist_protocol_runs(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolRunsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ListProtocolRunsResponse>>(PrepareAsynclist_protocol_runsRaw(context, request, cq));
    }
    // Returns the name and run id of the currently running protocol.
    //
    // Will fail with FAILED_PRECONDITION if there is no protocol running
    //
    // Since 1.11
    virtual ::grpc::Status get_current_protocol_run(::grpc::ClientContext* context, const ::minknow_api::protocol::GetCurrentProtocolRunRequest& request, ::minknow_api::protocol::ProtocolRunInfo* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ProtocolRunInfo>> Asyncget_current_protocol_run(::grpc::ClientContext* context, const ::minknow_api::protocol::GetCurrentProtocolRunRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ProtocolRunInfo>>(Asyncget_current_protocol_runRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ProtocolRunInfo>> PrepareAsyncget_current_protocol_run(::grpc::ClientContext* context, const ::minknow_api::protocol::GetCurrentProtocolRunRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ProtocolRunInfo>>(PrepareAsyncget_current_protocol_runRaw(context, request, cq));
    }
    // Returns current protocol run info and streams any changes to the current protocol
    //
    // This call can be made even if there is no current protocol running. In this case, the next streamed
    // response will be the start of a new protocol instance and you will receive updates for that protocol
    // until it finishes
    //
    // If a protocol finishes this stream will still continue to run and you will be notified when a new protocol starts
    //
    // Since 1.12
    std::unique_ptr< ::grpc::ClientReaderInterface< ::minknow_api::protocol::ProtocolRunInfo>> watch_current_protocol_run(::grpc::ClientContext* context, const ::minknow_api::protocol::WatchCurrentProtocolRunRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::minknow_api::protocol::ProtocolRunInfo>>(watch_current_protocol_runRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::protocol::ProtocolRunInfo>> Asyncwatch_current_protocol_run(::grpc::ClientContext* context, const ::minknow_api::protocol::WatchCurrentProtocolRunRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::protocol::ProtocolRunInfo>>(Asyncwatch_current_protocol_runRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::protocol::ProtocolRunInfo>> PrepareAsyncwatch_current_protocol_run(::grpc::ClientContext* context, const ::minknow_api::protocol::WatchCurrentProtocolRunRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::protocol::ProtocolRunInfo>>(PrepareAsyncwatch_current_protocol_runRaw(context, request, cq));
    }
    // Gives back a list that contains info about each possible protocol script minknow is aware of.
    // This will most likely be used to retrieve a suitable protocol script that can be passed on to `start_protocol`
    //
    // Since 1.10
    virtual ::grpc::Status list_protocols(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolsRequest& request, ::minknow_api::protocol::ListProtocolsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ListProtocolsResponse>> Asynclist_protocols(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ListProtocolsResponse>>(Asynclist_protocolsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ListProtocolsResponse>> PrepareAsynclist_protocols(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ListProtocolsResponse>>(PrepareAsynclist_protocolsRaw(context, request, cq));
    }
    // Returns string-to-string map of the context tags
    //
    // Since 1.11
    virtual ::grpc::Status get_context_info(::grpc::ClientContext* context, const ::minknow_api::protocol::GetContextInfoRequest& request, ::minknow_api::protocol::GetContextInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::GetContextInfoResponse>> Asyncget_context_info(::grpc::ClientContext* context, const ::minknow_api::protocol::GetContextInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::GetContextInfoResponse>>(Asyncget_context_infoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::GetContextInfoResponse>> PrepareAsyncget_context_info(::grpc::ClientContext* context, const ::minknow_api::protocol::GetContextInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::GetContextInfoResponse>>(PrepareAsyncget_context_infoRaw(context, request, cq));
    }
    // Store context tags as arbitary string-to-string map
    //
    // Since 1.11
    virtual ::grpc::Status set_context_info(::grpc::ClientContext* context, const ::minknow_api::protocol::SetContextInfoRequest& request, ::minknow_api::protocol::SetContextInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::SetContextInfoResponse>> Asyncset_context_info(::grpc::ClientContext* context, const ::minknow_api::protocol::SetContextInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::SetContextInfoResponse>>(Asyncset_context_infoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::SetContextInfoResponse>> PrepareAsyncset_context_info(::grpc::ClientContext* context, const ::minknow_api::protocol::SetContextInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::SetContextInfoResponse>>(PrepareAsyncset_context_infoRaw(context, request, cq));
    }
    // Value set by protocol scripts to define the purpose of the script. Gets this value
    //
    // Since 1.11
    virtual ::grpc::Status get_protocol_purpose(::grpc::ClientContext* context, const ::minknow_api::protocol::GetProtocolPurposeRequest& request, ::minknow_api::protocol::GetProtocolPurposeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::GetProtocolPurposeResponse>> Asyncget_protocol_purpose(::grpc::ClientContext* context, const ::minknow_api::protocol::GetProtocolPurposeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::GetProtocolPurposeResponse>>(Asyncget_protocol_purposeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::GetProtocolPurposeResponse>> PrepareAsyncget_protocol_purpose(::grpc::ClientContext* context, const ::minknow_api::protocol::GetProtocolPurposeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::GetProtocolPurposeResponse>>(PrepareAsyncget_protocol_purposeRaw(context, request, cq));
    }
    // Sets the protocol purpose. See also get_protocol_purpose
    //
    // Since 1.11
    virtual ::grpc::Status set_protocol_purpose(::grpc::ClientContext* context, const ::minknow_api::protocol::SetProtocolPurposeRequest& request, ::minknow_api::protocol::SetProtocolPurposeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::SetProtocolPurposeResponse>> Asyncset_protocol_purpose(::grpc::ClientContext* context, const ::minknow_api::protocol::SetProtocolPurposeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::SetProtocolPurposeResponse>>(Asyncset_protocol_purposeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::SetProtocolPurposeResponse>> PrepareAsyncset_protocol_purpose(::grpc::ClientContext* context, const ::minknow_api::protocol::SetProtocolPurposeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::SetProtocolPurposeResponse>>(PrepareAsyncset_protocol_purposeRaw(context, request, cq));
    }
    // Links an epi2me workflow reference to a run id.
    //
    // Since 1.15
    virtual ::grpc::Status add_epi2me_workflow(::grpc::ClientContext* context, const ::minknow_api::protocol::AddEpi2meWorkflowRequest& request, ::minknow_api::protocol::AddEpi2meWorkflowResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::AddEpi2meWorkflowResponse>> Asyncadd_epi2me_workflow(::grpc::ClientContext* context, const ::minknow_api::protocol::AddEpi2meWorkflowRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::AddEpi2meWorkflowResponse>>(Asyncadd_epi2me_workflowRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::AddEpi2meWorkflowResponse>> PrepareAsyncadd_epi2me_workflow(::grpc::ClientContext* context, const ::minknow_api::protocol::AddEpi2meWorkflowRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::AddEpi2meWorkflowResponse>>(PrepareAsyncadd_epi2me_workflowRaw(context, request, cq));
    }
    // List all used protocol group ids used in any previous protocol on the box.
    //
    // Since 3.2
    virtual ::grpc::Status list_protocol_group_ids(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolGroupIdsRequest& request, ::minknow_api::protocol::ListProtocolGroupIdsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ListProtocolGroupIdsResponse>> Asynclist_protocol_group_ids(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolGroupIdsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ListProtocolGroupIdsResponse>>(Asynclist_protocol_group_idsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ListProtocolGroupIdsResponse>> PrepareAsynclist_protocol_group_ids(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolGroupIdsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ListProtocolGroupIdsResponse>>(PrepareAsynclist_protocol_group_idsRaw(context, request, cq));
    }
    // Run a hardware check on the connected flow cell.
    //
    // Throws an error if there is no flow cell connected.
    //
    // Since 4.3
    virtual ::grpc::Status begin_hardware_check(::grpc::ClientContext* context, const ::minknow_api::protocol::BeginHardwareCheckRequest& request, ::minknow_api::protocol::BeginHardwareCheckResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::BeginHardwareCheckResponse>> Asyncbegin_hardware_check(::grpc::ClientContext* context, const ::minknow_api::protocol::BeginHardwareCheckRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::BeginHardwareCheckResponse>>(Asyncbegin_hardware_checkRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::BeginHardwareCheckResponse>> PrepareAsyncbegin_hardware_check(::grpc::ClientContext* context, const ::minknow_api::protocol::BeginHardwareCheckRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::BeginHardwareCheckResponse>>(PrepareAsyncbegin_hardware_checkRaw(context, request, cq));
    }
    // Run platform qc on the connected flow cell
    //
    // Throws an error if there is no flow cell connected.
    //
    // Since 4.3
    virtual ::grpc::Status begin_platform_qc(::grpc::ClientContext* context, const ::minknow_api::protocol::BeginPlatformQcRequest& request, ::minknow_api::protocol::BeginPlatformQcResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::BeginPlatformQcResponse>> Asyncbegin_platform_qc(::grpc::ClientContext* context, const ::minknow_api::protocol::BeginPlatformQcRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::BeginPlatformQcResponse>>(Asyncbegin_platform_qcRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::BeginPlatformQcResponse>> PrepareAsyncbegin_platform_qc(::grpc::ClientContext* context, const ::minknow_api::protocol::BeginPlatformQcRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::BeginPlatformQcResponse>>(PrepareAsyncbegin_platform_qcRaw(context, request, cq));
    }
    virtual ::grpc::Status set_platform_qc_result(::grpc::ClientContext* context, const ::minknow_api::protocol::SetPlatformQcResultRequest& request, ::minknow_api::protocol::SetPlatformQcResultResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::SetPlatformQcResultResponse>> Asyncset_platform_qc_result(::grpc::ClientContext* context, const ::minknow_api::protocol::SetPlatformQcResultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::SetPlatformQcResultResponse>>(Asyncset_platform_qc_resultRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::SetPlatformQcResultResponse>> PrepareAsyncset_platform_qc_result(::grpc::ClientContext* context, const ::minknow_api::protocol::SetPlatformQcResultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::SetPlatformQcResultResponse>>(PrepareAsyncset_platform_qc_resultRaw(context, request, cq));
    }
    // Given a protocol and some information about the flow-cell and kits will provide a list
    // of settings required by the protocol, their defaults and dependencies.
    //
    // Since 4.3
    virtual ::grpc::Status list_settings_for_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::ListSettingsForProtocolRequest& request, ::minknow_api::protocol::ListSettingsForProtocolResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ListSettingsForProtocolResponse>> Asynclist_settings_for_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::ListSettingsForProtocolRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ListSettingsForProtocolResponse>>(Asynclist_settings_for_protocolRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ListSettingsForProtocolResponse>> PrepareAsynclist_settings_for_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::ListSettingsForProtocolRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ListSettingsForProtocolResponse>>(PrepareAsynclist_settings_for_protocolRaw(context, request, cq));
    }
    // Associated a post processing analysis process, and schedule it to run once the protocol is complete.
    //
    // If the protocol is already complete, the post proecssing analysis is executed immediately.
    //
    // Since 4.4
    virtual ::grpc::Status associate_post_processing_analysis_for_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::AssociatePostProcessingAnalysisRequest& request, ::minknow_api::protocol::AssociatePostProcessingAnalysisResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::AssociatePostProcessingAnalysisResponse>> Asyncassociate_post_processing_analysis_for_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::AssociatePostProcessingAnalysisRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::AssociatePostProcessingAnalysisResponse>>(Asyncassociate_post_processing_analysis_for_protocolRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::AssociatePostProcessingAnalysisResponse>> PrepareAsyncassociate_post_processing_analysis_for_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::AssociatePostProcessingAnalysisRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::AssociatePostProcessingAnalysisResponse>>(PrepareAsyncassociate_post_processing_analysis_for_protocolRaw(context, request, cq));
    }
    // Clears history data for specified protocol(s)
    //
    // History data includes protocol protocol info, acquisition info and statistics.
    //
    // Also clears any persistence data that has been written to disk for those protocols -- this
    // data will not be available after a restart.
    //
    // Does NOT clear experiment results (fast5, fastq, sequencing_summary, etc)
    //
    // Since 4.4
    //
    virtual ::grpc::Status clear_protocol_history_data(::grpc::ClientContext* context, const ::minknow_api::protocol::ClearProtocolHistoryDataRequest& request, ::minknow_api::protocol::ClearProtocolHistoryDataResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ClearProtocolHistoryDataResponse>> Asyncclear_protocol_history_data(::grpc::ClientContext* context, const ::minknow_api::protocol::ClearProtocolHistoryDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ClearProtocolHistoryDataResponse>>(Asyncclear_protocol_history_dataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ClearProtocolHistoryDataResponse>> PrepareAsyncclear_protocol_history_data(::grpc::ClientContext* context, const ::minknow_api::protocol::ClearProtocolHistoryDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ClearProtocolHistoryDataResponse>>(PrepareAsyncclear_protocol_history_dataRaw(context, request, cq));
    }
    // This RPC should only be used by the protocol script.
    //
    // The protocol script can call this to opt in to protocol phase management. It can report the
    // phase it is currently in, and handle requests to change phase.
    //
    // Only one call to this RPC is possible at once. Ending the call will reset the phase to
    // PHASE_UNKNOWN and clear any set capabilities.
    //
    // Since 4.4.
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::minknow_api::protocol::ProtocolPhaseManagementRequest, ::minknow_api::protocol::ProtocolPhaseManagementResponse>> protocol_phase_management(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::minknow_api::protocol::ProtocolPhaseManagementRequest, ::minknow_api::protocol::ProtocolPhaseManagementResponse>>(protocol_phase_managementRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::minknow_api::protocol::ProtocolPhaseManagementRequest, ::minknow_api::protocol::ProtocolPhaseManagementResponse>> Asyncprotocol_phase_management(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::minknow_api::protocol::ProtocolPhaseManagementRequest, ::minknow_api::protocol::ProtocolPhaseManagementResponse>>(Asyncprotocol_phase_managementRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::minknow_api::protocol::ProtocolPhaseManagementRequest, ::minknow_api::protocol::ProtocolPhaseManagementResponse>> PrepareAsyncprotocol_phase_management(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::minknow_api::protocol::ProtocolPhaseManagementRequest, ::minknow_api::protocol::ProtocolPhaseManagementResponse>>(PrepareAsyncprotocol_phase_managementRaw(context, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // Initiates a python instance that runs the script specified by the `path` argument.
      // `list_protocols` will give back a list of protocol scripts that can be started by this call
      virtual void start_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::StartProtocolRequest* request, ::minknow_api::protocol::StartProtocolResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void start_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::StartProtocolRequest* request, ::minknow_api::protocol::StartProtocolResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Stops the currently running protocol script instance.
      virtual void stop_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::StopProtocolRequest* request, ::minknow_api::protocol::StopProtocolResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void stop_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::StopProtocolRequest* request, ::minknow_api::protocol::StopProtocolResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Request the protocol to pause.
      //
      // This will return an error unless the ProtocolRunInfo has the `can_pause` field set to true.
      // It will have no effect if the protocol is already paused or pausing.
      //
      // Since 4.4.
      virtual void pause_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::PauseProtocolRequest* request, ::minknow_api::protocol::PauseProtocolResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void pause_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::PauseProtocolRequest* request, ::minknow_api::protocol::PauseProtocolResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Request the protocol to resume.
      //
      // This will return an error unless the ProtocolRunInfo has the `can_pause` field set to true.
      // It will have no effect if the protocol is not paused or pausing.
      //
      // Since 4.4.
      virtual void resume_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::ResumeProtocolRequest* request, ::minknow_api::protocol::ResumeProtocolResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void resume_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::ResumeProtocolRequest* request, ::minknow_api::protocol::ResumeProtocolResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Request the protocol to perform a mux scan.
      //
      // This will return an error unless the ProtocolRunInfo has the `can_trigger_mux_scan` field set
      // to true. It will have no effect if the protocol is already running or preparing for a mux
      // scan.
      //
      // Since 4.4.
      virtual void trigger_mux_scan(::grpc::ClientContext* context, const ::minknow_api::protocol::TriggerMuxScanRequest* request, ::minknow_api::protocol::TriggerMuxScanResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void trigger_mux_scan(::grpc::ClientContext* context, const ::minknow_api::protocol::TriggerMuxScanRequest* request, ::minknow_api::protocol::TriggerMuxScanResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Wait for a protocol run to finish.
      //
      // The call blocks until the run with the given run ID has finished (or returns immediately if
      // it had already finished) and returns information about the protocol run.
      //
      // If no run has been started with the provided run ID (or no run ID is given), an error is
      // returned.
      //
      // If NOTIFY_BEFORE_TERMINATION is specified for state, the protocol end time is an estimate, including
      // the allowed timeout.
      //
      // Since 1.10
      virtual void wait_for_finished(::grpc::ClientContext* context, const ::minknow_api::protocol::WaitForFinishedRequest* request, ::minknow_api::protocol::ProtocolRunInfo* response, std::function<void(::grpc::Status)>) = 0;
      virtual void wait_for_finished(::grpc::ClientContext* context, const ::minknow_api::protocol::WaitForFinishedRequest* request, ::minknow_api::protocol::ProtocolRunInfo* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Gets information about a protocol run.
      //
      // If no run ID is provided, information about the most recently started protocol run is
      // provided.
      //
      // Since 1.10
      virtual void get_run_info(::grpc::ClientContext* context, const ::minknow_api::protocol::GetRunInfoRequest* request, ::minknow_api::protocol::ProtocolRunInfo* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_run_info(::grpc::ClientContext* context, const ::minknow_api::protocol::GetRunInfoRequest* request, ::minknow_api::protocol::ProtocolRunInfo* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // List previously started protocol run ids (including any current protocol), in order of starting.
      //
      // The returned object can be used to find protocol information with get_run_info.
      //
      // Since 1.11
      virtual void list_protocol_runs(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolRunsRequest* request, ::minknow_api::protocol::ListProtocolRunsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void list_protocol_runs(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolRunsRequest* request, ::minknow_api::protocol::ListProtocolRunsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Returns the name and run id of the currently running protocol.
      //
      // Will fail with FAILED_PRECONDITION if there is no protocol running
      //
      // Since 1.11
      virtual void get_current_protocol_run(::grpc::ClientContext* context, const ::minknow_api::protocol::GetCurrentProtocolRunRequest* request, ::minknow_api::protocol::ProtocolRunInfo* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_current_protocol_run(::grpc::ClientContext* context, const ::minknow_api::protocol::GetCurrentProtocolRunRequest* request, ::minknow_api::protocol::ProtocolRunInfo* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Returns current protocol run info and streams any changes to the current protocol
      //
      // This call can be made even if there is no current protocol running. In this case, the next streamed
      // response will be the start of a new protocol instance and you will receive updates for that protocol
      // until it finishes
      //
      // If a protocol finishes this stream will still continue to run and you will be notified when a new protocol starts
      //
      // Since 1.12
      virtual void watch_current_protocol_run(::grpc::ClientContext* context, const ::minknow_api::protocol::WatchCurrentProtocolRunRequest* request, ::grpc::ClientReadReactor< ::minknow_api::protocol::ProtocolRunInfo>* reactor) = 0;
      // Gives back a list that contains info about each possible protocol script minknow is aware of.
      // This will most likely be used to retrieve a suitable protocol script that can be passed on to `start_protocol`
      //
      // Since 1.10
      virtual void list_protocols(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolsRequest* request, ::minknow_api::protocol::ListProtocolsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void list_protocols(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolsRequest* request, ::minknow_api::protocol::ListProtocolsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Returns string-to-string map of the context tags
      //
      // Since 1.11
      virtual void get_context_info(::grpc::ClientContext* context, const ::minknow_api::protocol::GetContextInfoRequest* request, ::minknow_api::protocol::GetContextInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_context_info(::grpc::ClientContext* context, const ::minknow_api::protocol::GetContextInfoRequest* request, ::minknow_api::protocol::GetContextInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Store context tags as arbitary string-to-string map
      //
      // Since 1.11
      virtual void set_context_info(::grpc::ClientContext* context, const ::minknow_api::protocol::SetContextInfoRequest* request, ::minknow_api::protocol::SetContextInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void set_context_info(::grpc::ClientContext* context, const ::minknow_api::protocol::SetContextInfoRequest* request, ::minknow_api::protocol::SetContextInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Value set by protocol scripts to define the purpose of the script. Gets this value
      //
      // Since 1.11
      virtual void get_protocol_purpose(::grpc::ClientContext* context, const ::minknow_api::protocol::GetProtocolPurposeRequest* request, ::minknow_api::protocol::GetProtocolPurposeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_protocol_purpose(::grpc::ClientContext* context, const ::minknow_api::protocol::GetProtocolPurposeRequest* request, ::minknow_api::protocol::GetProtocolPurposeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Sets the protocol purpose. See also get_protocol_purpose
      //
      // Since 1.11
      virtual void set_protocol_purpose(::grpc::ClientContext* context, const ::minknow_api::protocol::SetProtocolPurposeRequest* request, ::minknow_api::protocol::SetProtocolPurposeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void set_protocol_purpose(::grpc::ClientContext* context, const ::minknow_api::protocol::SetProtocolPurposeRequest* request, ::minknow_api::protocol::SetProtocolPurposeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Links an epi2me workflow reference to a run id.
      //
      // Since 1.15
      virtual void add_epi2me_workflow(::grpc::ClientContext* context, const ::minknow_api::protocol::AddEpi2meWorkflowRequest* request, ::minknow_api::protocol::AddEpi2meWorkflowResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void add_epi2me_workflow(::grpc::ClientContext* context, const ::minknow_api::protocol::AddEpi2meWorkflowRequest* request, ::minknow_api::protocol::AddEpi2meWorkflowResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // List all used protocol group ids used in any previous protocol on the box.
      //
      // Since 3.2
      virtual void list_protocol_group_ids(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolGroupIdsRequest* request, ::minknow_api::protocol::ListProtocolGroupIdsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void list_protocol_group_ids(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolGroupIdsRequest* request, ::minknow_api::protocol::ListProtocolGroupIdsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Run a hardware check on the connected flow cell.
      //
      // Throws an error if there is no flow cell connected.
      //
      // Since 4.3
      virtual void begin_hardware_check(::grpc::ClientContext* context, const ::minknow_api::protocol::BeginHardwareCheckRequest* request, ::minknow_api::protocol::BeginHardwareCheckResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void begin_hardware_check(::grpc::ClientContext* context, const ::minknow_api::protocol::BeginHardwareCheckRequest* request, ::minknow_api::protocol::BeginHardwareCheckResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Run platform qc on the connected flow cell
      //
      // Throws an error if there is no flow cell connected.
      //
      // Since 4.3
      virtual void begin_platform_qc(::grpc::ClientContext* context, const ::minknow_api::protocol::BeginPlatformQcRequest* request, ::minknow_api::protocol::BeginPlatformQcResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void begin_platform_qc(::grpc::ClientContext* context, const ::minknow_api::protocol::BeginPlatformQcRequest* request, ::minknow_api::protocol::BeginPlatformQcResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void set_platform_qc_result(::grpc::ClientContext* context, const ::minknow_api::protocol::SetPlatformQcResultRequest* request, ::minknow_api::protocol::SetPlatformQcResultResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void set_platform_qc_result(::grpc::ClientContext* context, const ::minknow_api::protocol::SetPlatformQcResultRequest* request, ::minknow_api::protocol::SetPlatformQcResultResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Given a protocol and some information about the flow-cell and kits will provide a list
      // of settings required by the protocol, their defaults and dependencies.
      //
      // Since 4.3
      virtual void list_settings_for_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::ListSettingsForProtocolRequest* request, ::minknow_api::protocol::ListSettingsForProtocolResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void list_settings_for_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::ListSettingsForProtocolRequest* request, ::minknow_api::protocol::ListSettingsForProtocolResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Associated a post processing analysis process, and schedule it to run once the protocol is complete.
      //
      // If the protocol is already complete, the post proecssing analysis is executed immediately.
      //
      // Since 4.4
      virtual void associate_post_processing_analysis_for_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::AssociatePostProcessingAnalysisRequest* request, ::minknow_api::protocol::AssociatePostProcessingAnalysisResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void associate_post_processing_analysis_for_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::AssociatePostProcessingAnalysisRequest* request, ::minknow_api::protocol::AssociatePostProcessingAnalysisResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Clears history data for specified protocol(s)
      //
      // History data includes protocol protocol info, acquisition info and statistics.
      //
      // Also clears any persistence data that has been written to disk for those protocols -- this
      // data will not be available after a restart.
      //
      // Does NOT clear experiment results (fast5, fastq, sequencing_summary, etc)
      //
      // Since 4.4
      //
      virtual void clear_protocol_history_data(::grpc::ClientContext* context, const ::minknow_api::protocol::ClearProtocolHistoryDataRequest* request, ::minknow_api::protocol::ClearProtocolHistoryDataResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void clear_protocol_history_data(::grpc::ClientContext* context, const ::minknow_api::protocol::ClearProtocolHistoryDataRequest* request, ::minknow_api::protocol::ClearProtocolHistoryDataResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // This RPC should only be used by the protocol script.
      //
      // The protocol script can call this to opt in to protocol phase management. It can report the
      // phase it is currently in, and handle requests to change phase.
      //
      // Only one call to this RPC is possible at once. Ending the call will reset the phase to
      // PHASE_UNKNOWN and clear any set capabilities.
      //
      // Since 4.4.
      virtual void protocol_phase_management(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::minknow_api::protocol::ProtocolPhaseManagementRequest,::minknow_api::protocol::ProtocolPhaseManagementResponse>* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::StartProtocolResponse>* Asyncstart_protocolRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::StartProtocolRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::StartProtocolResponse>* PrepareAsyncstart_protocolRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::StartProtocolRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::StopProtocolResponse>* Asyncstop_protocolRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::StopProtocolRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::StopProtocolResponse>* PrepareAsyncstop_protocolRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::StopProtocolRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::PauseProtocolResponse>* Asyncpause_protocolRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::PauseProtocolRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::PauseProtocolResponse>* PrepareAsyncpause_protocolRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::PauseProtocolRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ResumeProtocolResponse>* Asyncresume_protocolRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::ResumeProtocolRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ResumeProtocolResponse>* PrepareAsyncresume_protocolRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::ResumeProtocolRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::TriggerMuxScanResponse>* Asynctrigger_mux_scanRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::TriggerMuxScanRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::TriggerMuxScanResponse>* PrepareAsynctrigger_mux_scanRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::TriggerMuxScanRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ProtocolRunInfo>* Asyncwait_for_finishedRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::WaitForFinishedRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ProtocolRunInfo>* PrepareAsyncwait_for_finishedRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::WaitForFinishedRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ProtocolRunInfo>* Asyncget_run_infoRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::GetRunInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ProtocolRunInfo>* PrepareAsyncget_run_infoRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::GetRunInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ListProtocolRunsResponse>* Asynclist_protocol_runsRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolRunsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ListProtocolRunsResponse>* PrepareAsynclist_protocol_runsRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolRunsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ProtocolRunInfo>* Asyncget_current_protocol_runRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::GetCurrentProtocolRunRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ProtocolRunInfo>* PrepareAsyncget_current_protocol_runRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::GetCurrentProtocolRunRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::minknow_api::protocol::ProtocolRunInfo>* watch_current_protocol_runRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::WatchCurrentProtocolRunRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::minknow_api::protocol::ProtocolRunInfo>* Asyncwatch_current_protocol_runRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::WatchCurrentProtocolRunRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::minknow_api::protocol::ProtocolRunInfo>* PrepareAsyncwatch_current_protocol_runRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::WatchCurrentProtocolRunRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ListProtocolsResponse>* Asynclist_protocolsRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ListProtocolsResponse>* PrepareAsynclist_protocolsRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::GetContextInfoResponse>* Asyncget_context_infoRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::GetContextInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::GetContextInfoResponse>* PrepareAsyncget_context_infoRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::GetContextInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::SetContextInfoResponse>* Asyncset_context_infoRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::SetContextInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::SetContextInfoResponse>* PrepareAsyncset_context_infoRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::SetContextInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::GetProtocolPurposeResponse>* Asyncget_protocol_purposeRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::GetProtocolPurposeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::GetProtocolPurposeResponse>* PrepareAsyncget_protocol_purposeRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::GetProtocolPurposeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::SetProtocolPurposeResponse>* Asyncset_protocol_purposeRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::SetProtocolPurposeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::SetProtocolPurposeResponse>* PrepareAsyncset_protocol_purposeRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::SetProtocolPurposeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::AddEpi2meWorkflowResponse>* Asyncadd_epi2me_workflowRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::AddEpi2meWorkflowRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::AddEpi2meWorkflowResponse>* PrepareAsyncadd_epi2me_workflowRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::AddEpi2meWorkflowRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ListProtocolGroupIdsResponse>* Asynclist_protocol_group_idsRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolGroupIdsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ListProtocolGroupIdsResponse>* PrepareAsynclist_protocol_group_idsRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolGroupIdsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::BeginHardwareCheckResponse>* Asyncbegin_hardware_checkRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::BeginHardwareCheckRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::BeginHardwareCheckResponse>* PrepareAsyncbegin_hardware_checkRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::BeginHardwareCheckRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::BeginPlatformQcResponse>* Asyncbegin_platform_qcRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::BeginPlatformQcRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::BeginPlatformQcResponse>* PrepareAsyncbegin_platform_qcRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::BeginPlatformQcRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::SetPlatformQcResultResponse>* Asyncset_platform_qc_resultRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::SetPlatformQcResultRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::SetPlatformQcResultResponse>* PrepareAsyncset_platform_qc_resultRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::SetPlatformQcResultRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ListSettingsForProtocolResponse>* Asynclist_settings_for_protocolRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::ListSettingsForProtocolRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ListSettingsForProtocolResponse>* PrepareAsynclist_settings_for_protocolRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::ListSettingsForProtocolRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::AssociatePostProcessingAnalysisResponse>* Asyncassociate_post_processing_analysis_for_protocolRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::AssociatePostProcessingAnalysisRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::AssociatePostProcessingAnalysisResponse>* PrepareAsyncassociate_post_processing_analysis_for_protocolRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::AssociatePostProcessingAnalysisRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ClearProtocolHistoryDataResponse>* Asyncclear_protocol_history_dataRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::ClearProtocolHistoryDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::protocol::ClearProtocolHistoryDataResponse>* PrepareAsyncclear_protocol_history_dataRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::ClearProtocolHistoryDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::minknow_api::protocol::ProtocolPhaseManagementRequest, ::minknow_api::protocol::ProtocolPhaseManagementResponse>* protocol_phase_managementRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::minknow_api::protocol::ProtocolPhaseManagementRequest, ::minknow_api::protocol::ProtocolPhaseManagementResponse>* Asyncprotocol_phase_managementRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::minknow_api::protocol::ProtocolPhaseManagementRequest, ::minknow_api::protocol::ProtocolPhaseManagementResponse>* PrepareAsyncprotocol_phase_managementRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status start_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::StartProtocolRequest& request, ::minknow_api::protocol::StartProtocolResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::StartProtocolResponse>> Asyncstart_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::StartProtocolRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::StartProtocolResponse>>(Asyncstart_protocolRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::StartProtocolResponse>> PrepareAsyncstart_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::StartProtocolRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::StartProtocolResponse>>(PrepareAsyncstart_protocolRaw(context, request, cq));
    }
    ::grpc::Status stop_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::StopProtocolRequest& request, ::minknow_api::protocol::StopProtocolResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::StopProtocolResponse>> Asyncstop_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::StopProtocolRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::StopProtocolResponse>>(Asyncstop_protocolRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::StopProtocolResponse>> PrepareAsyncstop_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::StopProtocolRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::StopProtocolResponse>>(PrepareAsyncstop_protocolRaw(context, request, cq));
    }
    ::grpc::Status pause_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::PauseProtocolRequest& request, ::minknow_api::protocol::PauseProtocolResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::PauseProtocolResponse>> Asyncpause_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::PauseProtocolRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::PauseProtocolResponse>>(Asyncpause_protocolRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::PauseProtocolResponse>> PrepareAsyncpause_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::PauseProtocolRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::PauseProtocolResponse>>(PrepareAsyncpause_protocolRaw(context, request, cq));
    }
    ::grpc::Status resume_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::ResumeProtocolRequest& request, ::minknow_api::protocol::ResumeProtocolResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ResumeProtocolResponse>> Asyncresume_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::ResumeProtocolRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ResumeProtocolResponse>>(Asyncresume_protocolRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ResumeProtocolResponse>> PrepareAsyncresume_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::ResumeProtocolRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ResumeProtocolResponse>>(PrepareAsyncresume_protocolRaw(context, request, cq));
    }
    ::grpc::Status trigger_mux_scan(::grpc::ClientContext* context, const ::minknow_api::protocol::TriggerMuxScanRequest& request, ::minknow_api::protocol::TriggerMuxScanResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::TriggerMuxScanResponse>> Asynctrigger_mux_scan(::grpc::ClientContext* context, const ::minknow_api::protocol::TriggerMuxScanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::TriggerMuxScanResponse>>(Asynctrigger_mux_scanRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::TriggerMuxScanResponse>> PrepareAsynctrigger_mux_scan(::grpc::ClientContext* context, const ::minknow_api::protocol::TriggerMuxScanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::TriggerMuxScanResponse>>(PrepareAsynctrigger_mux_scanRaw(context, request, cq));
    }
    ::grpc::Status wait_for_finished(::grpc::ClientContext* context, const ::minknow_api::protocol::WaitForFinishedRequest& request, ::minknow_api::protocol::ProtocolRunInfo* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ProtocolRunInfo>> Asyncwait_for_finished(::grpc::ClientContext* context, const ::minknow_api::protocol::WaitForFinishedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ProtocolRunInfo>>(Asyncwait_for_finishedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ProtocolRunInfo>> PrepareAsyncwait_for_finished(::grpc::ClientContext* context, const ::minknow_api::protocol::WaitForFinishedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ProtocolRunInfo>>(PrepareAsyncwait_for_finishedRaw(context, request, cq));
    }
    ::grpc::Status get_run_info(::grpc::ClientContext* context, const ::minknow_api::protocol::GetRunInfoRequest& request, ::minknow_api::protocol::ProtocolRunInfo* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ProtocolRunInfo>> Asyncget_run_info(::grpc::ClientContext* context, const ::minknow_api::protocol::GetRunInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ProtocolRunInfo>>(Asyncget_run_infoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ProtocolRunInfo>> PrepareAsyncget_run_info(::grpc::ClientContext* context, const ::minknow_api::protocol::GetRunInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ProtocolRunInfo>>(PrepareAsyncget_run_infoRaw(context, request, cq));
    }
    ::grpc::Status list_protocol_runs(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolRunsRequest& request, ::minknow_api::protocol::ListProtocolRunsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ListProtocolRunsResponse>> Asynclist_protocol_runs(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolRunsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ListProtocolRunsResponse>>(Asynclist_protocol_runsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ListProtocolRunsResponse>> PrepareAsynclist_protocol_runs(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolRunsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ListProtocolRunsResponse>>(PrepareAsynclist_protocol_runsRaw(context, request, cq));
    }
    ::grpc::Status get_current_protocol_run(::grpc::ClientContext* context, const ::minknow_api::protocol::GetCurrentProtocolRunRequest& request, ::minknow_api::protocol::ProtocolRunInfo* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ProtocolRunInfo>> Asyncget_current_protocol_run(::grpc::ClientContext* context, const ::minknow_api::protocol::GetCurrentProtocolRunRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ProtocolRunInfo>>(Asyncget_current_protocol_runRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ProtocolRunInfo>> PrepareAsyncget_current_protocol_run(::grpc::ClientContext* context, const ::minknow_api::protocol::GetCurrentProtocolRunRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ProtocolRunInfo>>(PrepareAsyncget_current_protocol_runRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::minknow_api::protocol::ProtocolRunInfo>> watch_current_protocol_run(::grpc::ClientContext* context, const ::minknow_api::protocol::WatchCurrentProtocolRunRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::minknow_api::protocol::ProtocolRunInfo>>(watch_current_protocol_runRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::protocol::ProtocolRunInfo>> Asyncwatch_current_protocol_run(::grpc::ClientContext* context, const ::minknow_api::protocol::WatchCurrentProtocolRunRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::protocol::ProtocolRunInfo>>(Asyncwatch_current_protocol_runRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::protocol::ProtocolRunInfo>> PrepareAsyncwatch_current_protocol_run(::grpc::ClientContext* context, const ::minknow_api::protocol::WatchCurrentProtocolRunRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::protocol::ProtocolRunInfo>>(PrepareAsyncwatch_current_protocol_runRaw(context, request, cq));
    }
    ::grpc::Status list_protocols(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolsRequest& request, ::minknow_api::protocol::ListProtocolsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ListProtocolsResponse>> Asynclist_protocols(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ListProtocolsResponse>>(Asynclist_protocolsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ListProtocolsResponse>> PrepareAsynclist_protocols(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ListProtocolsResponse>>(PrepareAsynclist_protocolsRaw(context, request, cq));
    }
    ::grpc::Status get_context_info(::grpc::ClientContext* context, const ::minknow_api::protocol::GetContextInfoRequest& request, ::minknow_api::protocol::GetContextInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::GetContextInfoResponse>> Asyncget_context_info(::grpc::ClientContext* context, const ::minknow_api::protocol::GetContextInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::GetContextInfoResponse>>(Asyncget_context_infoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::GetContextInfoResponse>> PrepareAsyncget_context_info(::grpc::ClientContext* context, const ::minknow_api::protocol::GetContextInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::GetContextInfoResponse>>(PrepareAsyncget_context_infoRaw(context, request, cq));
    }
    ::grpc::Status set_context_info(::grpc::ClientContext* context, const ::minknow_api::protocol::SetContextInfoRequest& request, ::minknow_api::protocol::SetContextInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::SetContextInfoResponse>> Asyncset_context_info(::grpc::ClientContext* context, const ::minknow_api::protocol::SetContextInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::SetContextInfoResponse>>(Asyncset_context_infoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::SetContextInfoResponse>> PrepareAsyncset_context_info(::grpc::ClientContext* context, const ::minknow_api::protocol::SetContextInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::SetContextInfoResponse>>(PrepareAsyncset_context_infoRaw(context, request, cq));
    }
    ::grpc::Status get_protocol_purpose(::grpc::ClientContext* context, const ::minknow_api::protocol::GetProtocolPurposeRequest& request, ::minknow_api::protocol::GetProtocolPurposeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::GetProtocolPurposeResponse>> Asyncget_protocol_purpose(::grpc::ClientContext* context, const ::minknow_api::protocol::GetProtocolPurposeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::GetProtocolPurposeResponse>>(Asyncget_protocol_purposeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::GetProtocolPurposeResponse>> PrepareAsyncget_protocol_purpose(::grpc::ClientContext* context, const ::minknow_api::protocol::GetProtocolPurposeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::GetProtocolPurposeResponse>>(PrepareAsyncget_protocol_purposeRaw(context, request, cq));
    }
    ::grpc::Status set_protocol_purpose(::grpc::ClientContext* context, const ::minknow_api::protocol::SetProtocolPurposeRequest& request, ::minknow_api::protocol::SetProtocolPurposeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::SetProtocolPurposeResponse>> Asyncset_protocol_purpose(::grpc::ClientContext* context, const ::minknow_api::protocol::SetProtocolPurposeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::SetProtocolPurposeResponse>>(Asyncset_protocol_purposeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::SetProtocolPurposeResponse>> PrepareAsyncset_protocol_purpose(::grpc::ClientContext* context, const ::minknow_api::protocol::SetProtocolPurposeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::SetProtocolPurposeResponse>>(PrepareAsyncset_protocol_purposeRaw(context, request, cq));
    }
    ::grpc::Status add_epi2me_workflow(::grpc::ClientContext* context, const ::minknow_api::protocol::AddEpi2meWorkflowRequest& request, ::minknow_api::protocol::AddEpi2meWorkflowResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::AddEpi2meWorkflowResponse>> Asyncadd_epi2me_workflow(::grpc::ClientContext* context, const ::minknow_api::protocol::AddEpi2meWorkflowRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::AddEpi2meWorkflowResponse>>(Asyncadd_epi2me_workflowRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::AddEpi2meWorkflowResponse>> PrepareAsyncadd_epi2me_workflow(::grpc::ClientContext* context, const ::minknow_api::protocol::AddEpi2meWorkflowRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::AddEpi2meWorkflowResponse>>(PrepareAsyncadd_epi2me_workflowRaw(context, request, cq));
    }
    ::grpc::Status list_protocol_group_ids(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolGroupIdsRequest& request, ::minknow_api::protocol::ListProtocolGroupIdsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ListProtocolGroupIdsResponse>> Asynclist_protocol_group_ids(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolGroupIdsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ListProtocolGroupIdsResponse>>(Asynclist_protocol_group_idsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ListProtocolGroupIdsResponse>> PrepareAsynclist_protocol_group_ids(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolGroupIdsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ListProtocolGroupIdsResponse>>(PrepareAsynclist_protocol_group_idsRaw(context, request, cq));
    }
    ::grpc::Status begin_hardware_check(::grpc::ClientContext* context, const ::minknow_api::protocol::BeginHardwareCheckRequest& request, ::minknow_api::protocol::BeginHardwareCheckResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::BeginHardwareCheckResponse>> Asyncbegin_hardware_check(::grpc::ClientContext* context, const ::minknow_api::protocol::BeginHardwareCheckRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::BeginHardwareCheckResponse>>(Asyncbegin_hardware_checkRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::BeginHardwareCheckResponse>> PrepareAsyncbegin_hardware_check(::grpc::ClientContext* context, const ::minknow_api::protocol::BeginHardwareCheckRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::BeginHardwareCheckResponse>>(PrepareAsyncbegin_hardware_checkRaw(context, request, cq));
    }
    ::grpc::Status begin_platform_qc(::grpc::ClientContext* context, const ::minknow_api::protocol::BeginPlatformQcRequest& request, ::minknow_api::protocol::BeginPlatformQcResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::BeginPlatformQcResponse>> Asyncbegin_platform_qc(::grpc::ClientContext* context, const ::minknow_api::protocol::BeginPlatformQcRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::BeginPlatformQcResponse>>(Asyncbegin_platform_qcRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::BeginPlatformQcResponse>> PrepareAsyncbegin_platform_qc(::grpc::ClientContext* context, const ::minknow_api::protocol::BeginPlatformQcRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::BeginPlatformQcResponse>>(PrepareAsyncbegin_platform_qcRaw(context, request, cq));
    }
    ::grpc::Status set_platform_qc_result(::grpc::ClientContext* context, const ::minknow_api::protocol::SetPlatformQcResultRequest& request, ::minknow_api::protocol::SetPlatformQcResultResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::SetPlatformQcResultResponse>> Asyncset_platform_qc_result(::grpc::ClientContext* context, const ::minknow_api::protocol::SetPlatformQcResultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::SetPlatformQcResultResponse>>(Asyncset_platform_qc_resultRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::SetPlatformQcResultResponse>> PrepareAsyncset_platform_qc_result(::grpc::ClientContext* context, const ::minknow_api::protocol::SetPlatformQcResultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::SetPlatformQcResultResponse>>(PrepareAsyncset_platform_qc_resultRaw(context, request, cq));
    }
    ::grpc::Status list_settings_for_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::ListSettingsForProtocolRequest& request, ::minknow_api::protocol::ListSettingsForProtocolResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ListSettingsForProtocolResponse>> Asynclist_settings_for_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::ListSettingsForProtocolRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ListSettingsForProtocolResponse>>(Asynclist_settings_for_protocolRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ListSettingsForProtocolResponse>> PrepareAsynclist_settings_for_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::ListSettingsForProtocolRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ListSettingsForProtocolResponse>>(PrepareAsynclist_settings_for_protocolRaw(context, request, cq));
    }
    ::grpc::Status associate_post_processing_analysis_for_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::AssociatePostProcessingAnalysisRequest& request, ::minknow_api::protocol::AssociatePostProcessingAnalysisResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::AssociatePostProcessingAnalysisResponse>> Asyncassociate_post_processing_analysis_for_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::AssociatePostProcessingAnalysisRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::AssociatePostProcessingAnalysisResponse>>(Asyncassociate_post_processing_analysis_for_protocolRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::AssociatePostProcessingAnalysisResponse>> PrepareAsyncassociate_post_processing_analysis_for_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::AssociatePostProcessingAnalysisRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::AssociatePostProcessingAnalysisResponse>>(PrepareAsyncassociate_post_processing_analysis_for_protocolRaw(context, request, cq));
    }
    ::grpc::Status clear_protocol_history_data(::grpc::ClientContext* context, const ::minknow_api::protocol::ClearProtocolHistoryDataRequest& request, ::minknow_api::protocol::ClearProtocolHistoryDataResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ClearProtocolHistoryDataResponse>> Asyncclear_protocol_history_data(::grpc::ClientContext* context, const ::minknow_api::protocol::ClearProtocolHistoryDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ClearProtocolHistoryDataResponse>>(Asyncclear_protocol_history_dataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ClearProtocolHistoryDataResponse>> PrepareAsyncclear_protocol_history_data(::grpc::ClientContext* context, const ::minknow_api::protocol::ClearProtocolHistoryDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ClearProtocolHistoryDataResponse>>(PrepareAsyncclear_protocol_history_dataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::minknow_api::protocol::ProtocolPhaseManagementRequest, ::minknow_api::protocol::ProtocolPhaseManagementResponse>> protocol_phase_management(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::minknow_api::protocol::ProtocolPhaseManagementRequest, ::minknow_api::protocol::ProtocolPhaseManagementResponse>>(protocol_phase_managementRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::minknow_api::protocol::ProtocolPhaseManagementRequest, ::minknow_api::protocol::ProtocolPhaseManagementResponse>> Asyncprotocol_phase_management(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::minknow_api::protocol::ProtocolPhaseManagementRequest, ::minknow_api::protocol::ProtocolPhaseManagementResponse>>(Asyncprotocol_phase_managementRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::minknow_api::protocol::ProtocolPhaseManagementRequest, ::minknow_api::protocol::ProtocolPhaseManagementResponse>> PrepareAsyncprotocol_phase_management(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::minknow_api::protocol::ProtocolPhaseManagementRequest, ::minknow_api::protocol::ProtocolPhaseManagementResponse>>(PrepareAsyncprotocol_phase_managementRaw(context, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void start_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::StartProtocolRequest* request, ::minknow_api::protocol::StartProtocolResponse* response, std::function<void(::grpc::Status)>) override;
      void start_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::StartProtocolRequest* request, ::minknow_api::protocol::StartProtocolResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void stop_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::StopProtocolRequest* request, ::minknow_api::protocol::StopProtocolResponse* response, std::function<void(::grpc::Status)>) override;
      void stop_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::StopProtocolRequest* request, ::minknow_api::protocol::StopProtocolResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void pause_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::PauseProtocolRequest* request, ::minknow_api::protocol::PauseProtocolResponse* response, std::function<void(::grpc::Status)>) override;
      void pause_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::PauseProtocolRequest* request, ::minknow_api::protocol::PauseProtocolResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void resume_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::ResumeProtocolRequest* request, ::minknow_api::protocol::ResumeProtocolResponse* response, std::function<void(::grpc::Status)>) override;
      void resume_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::ResumeProtocolRequest* request, ::minknow_api::protocol::ResumeProtocolResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void trigger_mux_scan(::grpc::ClientContext* context, const ::minknow_api::protocol::TriggerMuxScanRequest* request, ::minknow_api::protocol::TriggerMuxScanResponse* response, std::function<void(::grpc::Status)>) override;
      void trigger_mux_scan(::grpc::ClientContext* context, const ::minknow_api::protocol::TriggerMuxScanRequest* request, ::minknow_api::protocol::TriggerMuxScanResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void wait_for_finished(::grpc::ClientContext* context, const ::minknow_api::protocol::WaitForFinishedRequest* request, ::minknow_api::protocol::ProtocolRunInfo* response, std::function<void(::grpc::Status)>) override;
      void wait_for_finished(::grpc::ClientContext* context, const ::minknow_api::protocol::WaitForFinishedRequest* request, ::minknow_api::protocol::ProtocolRunInfo* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_run_info(::grpc::ClientContext* context, const ::minknow_api::protocol::GetRunInfoRequest* request, ::minknow_api::protocol::ProtocolRunInfo* response, std::function<void(::grpc::Status)>) override;
      void get_run_info(::grpc::ClientContext* context, const ::minknow_api::protocol::GetRunInfoRequest* request, ::minknow_api::protocol::ProtocolRunInfo* response, ::grpc::ClientUnaryReactor* reactor) override;
      void list_protocol_runs(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolRunsRequest* request, ::minknow_api::protocol::ListProtocolRunsResponse* response, std::function<void(::grpc::Status)>) override;
      void list_protocol_runs(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolRunsRequest* request, ::minknow_api::protocol::ListProtocolRunsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_current_protocol_run(::grpc::ClientContext* context, const ::minknow_api::protocol::GetCurrentProtocolRunRequest* request, ::minknow_api::protocol::ProtocolRunInfo* response, std::function<void(::grpc::Status)>) override;
      void get_current_protocol_run(::grpc::ClientContext* context, const ::minknow_api::protocol::GetCurrentProtocolRunRequest* request, ::minknow_api::protocol::ProtocolRunInfo* response, ::grpc::ClientUnaryReactor* reactor) override;
      void watch_current_protocol_run(::grpc::ClientContext* context, const ::minknow_api::protocol::WatchCurrentProtocolRunRequest* request, ::grpc::ClientReadReactor< ::minknow_api::protocol::ProtocolRunInfo>* reactor) override;
      void list_protocols(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolsRequest* request, ::minknow_api::protocol::ListProtocolsResponse* response, std::function<void(::grpc::Status)>) override;
      void list_protocols(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolsRequest* request, ::minknow_api::protocol::ListProtocolsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_context_info(::grpc::ClientContext* context, const ::minknow_api::protocol::GetContextInfoRequest* request, ::minknow_api::protocol::GetContextInfoResponse* response, std::function<void(::grpc::Status)>) override;
      void get_context_info(::grpc::ClientContext* context, const ::minknow_api::protocol::GetContextInfoRequest* request, ::minknow_api::protocol::GetContextInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void set_context_info(::grpc::ClientContext* context, const ::minknow_api::protocol::SetContextInfoRequest* request, ::minknow_api::protocol::SetContextInfoResponse* response, std::function<void(::grpc::Status)>) override;
      void set_context_info(::grpc::ClientContext* context, const ::minknow_api::protocol::SetContextInfoRequest* request, ::minknow_api::protocol::SetContextInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_protocol_purpose(::grpc::ClientContext* context, const ::minknow_api::protocol::GetProtocolPurposeRequest* request, ::minknow_api::protocol::GetProtocolPurposeResponse* response, std::function<void(::grpc::Status)>) override;
      void get_protocol_purpose(::grpc::ClientContext* context, const ::minknow_api::protocol::GetProtocolPurposeRequest* request, ::minknow_api::protocol::GetProtocolPurposeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void set_protocol_purpose(::grpc::ClientContext* context, const ::minknow_api::protocol::SetProtocolPurposeRequest* request, ::minknow_api::protocol::SetProtocolPurposeResponse* response, std::function<void(::grpc::Status)>) override;
      void set_protocol_purpose(::grpc::ClientContext* context, const ::minknow_api::protocol::SetProtocolPurposeRequest* request, ::minknow_api::protocol::SetProtocolPurposeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void add_epi2me_workflow(::grpc::ClientContext* context, const ::minknow_api::protocol::AddEpi2meWorkflowRequest* request, ::minknow_api::protocol::AddEpi2meWorkflowResponse* response, std::function<void(::grpc::Status)>) override;
      void add_epi2me_workflow(::grpc::ClientContext* context, const ::minknow_api::protocol::AddEpi2meWorkflowRequest* request, ::minknow_api::protocol::AddEpi2meWorkflowResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void list_protocol_group_ids(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolGroupIdsRequest* request, ::minknow_api::protocol::ListProtocolGroupIdsResponse* response, std::function<void(::grpc::Status)>) override;
      void list_protocol_group_ids(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolGroupIdsRequest* request, ::minknow_api::protocol::ListProtocolGroupIdsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void begin_hardware_check(::grpc::ClientContext* context, const ::minknow_api::protocol::BeginHardwareCheckRequest* request, ::minknow_api::protocol::BeginHardwareCheckResponse* response, std::function<void(::grpc::Status)>) override;
      void begin_hardware_check(::grpc::ClientContext* context, const ::minknow_api::protocol::BeginHardwareCheckRequest* request, ::minknow_api::protocol::BeginHardwareCheckResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void begin_platform_qc(::grpc::ClientContext* context, const ::minknow_api::protocol::BeginPlatformQcRequest* request, ::minknow_api::protocol::BeginPlatformQcResponse* response, std::function<void(::grpc::Status)>) override;
      void begin_platform_qc(::grpc::ClientContext* context, const ::minknow_api::protocol::BeginPlatformQcRequest* request, ::minknow_api::protocol::BeginPlatformQcResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void set_platform_qc_result(::grpc::ClientContext* context, const ::minknow_api::protocol::SetPlatformQcResultRequest* request, ::minknow_api::protocol::SetPlatformQcResultResponse* response, std::function<void(::grpc::Status)>) override;
      void set_platform_qc_result(::grpc::ClientContext* context, const ::minknow_api::protocol::SetPlatformQcResultRequest* request, ::minknow_api::protocol::SetPlatformQcResultResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void list_settings_for_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::ListSettingsForProtocolRequest* request, ::minknow_api::protocol::ListSettingsForProtocolResponse* response, std::function<void(::grpc::Status)>) override;
      void list_settings_for_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::ListSettingsForProtocolRequest* request, ::minknow_api::protocol::ListSettingsForProtocolResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void associate_post_processing_analysis_for_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::AssociatePostProcessingAnalysisRequest* request, ::minknow_api::protocol::AssociatePostProcessingAnalysisResponse* response, std::function<void(::grpc::Status)>) override;
      void associate_post_processing_analysis_for_protocol(::grpc::ClientContext* context, const ::minknow_api::protocol::AssociatePostProcessingAnalysisRequest* request, ::minknow_api::protocol::AssociatePostProcessingAnalysisResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void clear_protocol_history_data(::grpc::ClientContext* context, const ::minknow_api::protocol::ClearProtocolHistoryDataRequest* request, ::minknow_api::protocol::ClearProtocolHistoryDataResponse* response, std::function<void(::grpc::Status)>) override;
      void clear_protocol_history_data(::grpc::ClientContext* context, const ::minknow_api::protocol::ClearProtocolHistoryDataRequest* request, ::minknow_api::protocol::ClearProtocolHistoryDataResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void protocol_phase_management(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::minknow_api::protocol::ProtocolPhaseManagementRequest,::minknow_api::protocol::ProtocolPhaseManagementResponse>* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::StartProtocolResponse>* Asyncstart_protocolRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::StartProtocolRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::StartProtocolResponse>* PrepareAsyncstart_protocolRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::StartProtocolRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::StopProtocolResponse>* Asyncstop_protocolRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::StopProtocolRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::StopProtocolResponse>* PrepareAsyncstop_protocolRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::StopProtocolRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::PauseProtocolResponse>* Asyncpause_protocolRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::PauseProtocolRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::PauseProtocolResponse>* PrepareAsyncpause_protocolRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::PauseProtocolRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ResumeProtocolResponse>* Asyncresume_protocolRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::ResumeProtocolRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ResumeProtocolResponse>* PrepareAsyncresume_protocolRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::ResumeProtocolRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::TriggerMuxScanResponse>* Asynctrigger_mux_scanRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::TriggerMuxScanRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::TriggerMuxScanResponse>* PrepareAsynctrigger_mux_scanRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::TriggerMuxScanRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ProtocolRunInfo>* Asyncwait_for_finishedRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::WaitForFinishedRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ProtocolRunInfo>* PrepareAsyncwait_for_finishedRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::WaitForFinishedRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ProtocolRunInfo>* Asyncget_run_infoRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::GetRunInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ProtocolRunInfo>* PrepareAsyncget_run_infoRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::GetRunInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ListProtocolRunsResponse>* Asynclist_protocol_runsRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolRunsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ListProtocolRunsResponse>* PrepareAsynclist_protocol_runsRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolRunsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ProtocolRunInfo>* Asyncget_current_protocol_runRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::GetCurrentProtocolRunRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ProtocolRunInfo>* PrepareAsyncget_current_protocol_runRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::GetCurrentProtocolRunRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::minknow_api::protocol::ProtocolRunInfo>* watch_current_protocol_runRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::WatchCurrentProtocolRunRequest& request) override;
    ::grpc::ClientAsyncReader< ::minknow_api::protocol::ProtocolRunInfo>* Asyncwatch_current_protocol_runRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::WatchCurrentProtocolRunRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::minknow_api::protocol::ProtocolRunInfo>* PrepareAsyncwatch_current_protocol_runRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::WatchCurrentProtocolRunRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ListProtocolsResponse>* Asynclist_protocolsRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ListProtocolsResponse>* PrepareAsynclist_protocolsRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::GetContextInfoResponse>* Asyncget_context_infoRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::GetContextInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::GetContextInfoResponse>* PrepareAsyncget_context_infoRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::GetContextInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::SetContextInfoResponse>* Asyncset_context_infoRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::SetContextInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::SetContextInfoResponse>* PrepareAsyncset_context_infoRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::SetContextInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::GetProtocolPurposeResponse>* Asyncget_protocol_purposeRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::GetProtocolPurposeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::GetProtocolPurposeResponse>* PrepareAsyncget_protocol_purposeRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::GetProtocolPurposeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::SetProtocolPurposeResponse>* Asyncset_protocol_purposeRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::SetProtocolPurposeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::SetProtocolPurposeResponse>* PrepareAsyncset_protocol_purposeRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::SetProtocolPurposeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::AddEpi2meWorkflowResponse>* Asyncadd_epi2me_workflowRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::AddEpi2meWorkflowRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::AddEpi2meWorkflowResponse>* PrepareAsyncadd_epi2me_workflowRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::AddEpi2meWorkflowRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ListProtocolGroupIdsResponse>* Asynclist_protocol_group_idsRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolGroupIdsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ListProtocolGroupIdsResponse>* PrepareAsynclist_protocol_group_idsRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::ListProtocolGroupIdsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::BeginHardwareCheckResponse>* Asyncbegin_hardware_checkRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::BeginHardwareCheckRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::BeginHardwareCheckResponse>* PrepareAsyncbegin_hardware_checkRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::BeginHardwareCheckRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::BeginPlatformQcResponse>* Asyncbegin_platform_qcRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::BeginPlatformQcRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::BeginPlatformQcResponse>* PrepareAsyncbegin_platform_qcRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::BeginPlatformQcRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::SetPlatformQcResultResponse>* Asyncset_platform_qc_resultRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::SetPlatformQcResultRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::SetPlatformQcResultResponse>* PrepareAsyncset_platform_qc_resultRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::SetPlatformQcResultRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ListSettingsForProtocolResponse>* Asynclist_settings_for_protocolRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::ListSettingsForProtocolRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ListSettingsForProtocolResponse>* PrepareAsynclist_settings_for_protocolRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::ListSettingsForProtocolRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::AssociatePostProcessingAnalysisResponse>* Asyncassociate_post_processing_analysis_for_protocolRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::AssociatePostProcessingAnalysisRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::AssociatePostProcessingAnalysisResponse>* PrepareAsyncassociate_post_processing_analysis_for_protocolRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::AssociatePostProcessingAnalysisRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ClearProtocolHistoryDataResponse>* Asyncclear_protocol_history_dataRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::ClearProtocolHistoryDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::protocol::ClearProtocolHistoryDataResponse>* PrepareAsyncclear_protocol_history_dataRaw(::grpc::ClientContext* context, const ::minknow_api::protocol::ClearProtocolHistoryDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReaderWriter< ::minknow_api::protocol::ProtocolPhaseManagementRequest, ::minknow_api::protocol::ProtocolPhaseManagementResponse>* protocol_phase_managementRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::minknow_api::protocol::ProtocolPhaseManagementRequest, ::minknow_api::protocol::ProtocolPhaseManagementResponse>* Asyncprotocol_phase_managementRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::minknow_api::protocol::ProtocolPhaseManagementRequest, ::minknow_api::protocol::ProtocolPhaseManagementResponse>* PrepareAsyncprotocol_phase_managementRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_start_protocol_;
    const ::grpc::internal::RpcMethod rpcmethod_stop_protocol_;
    const ::grpc::internal::RpcMethod rpcmethod_pause_protocol_;
    const ::grpc::internal::RpcMethod rpcmethod_resume_protocol_;
    const ::grpc::internal::RpcMethod rpcmethod_trigger_mux_scan_;
    const ::grpc::internal::RpcMethod rpcmethod_wait_for_finished_;
    const ::grpc::internal::RpcMethod rpcmethod_get_run_info_;
    const ::grpc::internal::RpcMethod rpcmethod_list_protocol_runs_;
    const ::grpc::internal::RpcMethod rpcmethod_get_current_protocol_run_;
    const ::grpc::internal::RpcMethod rpcmethod_watch_current_protocol_run_;
    const ::grpc::internal::RpcMethod rpcmethod_list_protocols_;
    const ::grpc::internal::RpcMethod rpcmethod_get_context_info_;
    const ::grpc::internal::RpcMethod rpcmethod_set_context_info_;
    const ::grpc::internal::RpcMethod rpcmethod_get_protocol_purpose_;
    const ::grpc::internal::RpcMethod rpcmethod_set_protocol_purpose_;
    const ::grpc::internal::RpcMethod rpcmethod_add_epi2me_workflow_;
    const ::grpc::internal::RpcMethod rpcmethod_list_protocol_group_ids_;
    const ::grpc::internal::RpcMethod rpcmethod_begin_hardware_check_;
    const ::grpc::internal::RpcMethod rpcmethod_begin_platform_qc_;
    const ::grpc::internal::RpcMethod rpcmethod_set_platform_qc_result_;
    const ::grpc::internal::RpcMethod rpcmethod_list_settings_for_protocol_;
    const ::grpc::internal::RpcMethod rpcmethod_associate_post_processing_analysis_for_protocol_;
    const ::grpc::internal::RpcMethod rpcmethod_clear_protocol_history_data_;
    const ::grpc::internal::RpcMethod rpcmethod_protocol_phase_management_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Initiates a python instance that runs the script specified by the `path` argument.
    // `list_protocols` will give back a list of protocol scripts that can be started by this call
    virtual ::grpc::Status start_protocol(::grpc::ServerContext* context, const ::minknow_api::protocol::StartProtocolRequest* request, ::minknow_api::protocol::StartProtocolResponse* response);
    // Stops the currently running protocol script instance.
    virtual ::grpc::Status stop_protocol(::grpc::ServerContext* context, const ::minknow_api::protocol::StopProtocolRequest* request, ::minknow_api::protocol::StopProtocolResponse* response);
    // Request the protocol to pause.
    //
    // This will return an error unless the ProtocolRunInfo has the `can_pause` field set to true.
    // It will have no effect if the protocol is already paused or pausing.
    //
    // Since 4.4.
    virtual ::grpc::Status pause_protocol(::grpc::ServerContext* context, const ::minknow_api::protocol::PauseProtocolRequest* request, ::minknow_api::protocol::PauseProtocolResponse* response);
    // Request the protocol to resume.
    //
    // This will return an error unless the ProtocolRunInfo has the `can_pause` field set to true.
    // It will have no effect if the protocol is not paused or pausing.
    //
    // Since 4.4.
    virtual ::grpc::Status resume_protocol(::grpc::ServerContext* context, const ::minknow_api::protocol::ResumeProtocolRequest* request, ::minknow_api::protocol::ResumeProtocolResponse* response);
    // Request the protocol to perform a mux scan.
    //
    // This will return an error unless the ProtocolRunInfo has the `can_trigger_mux_scan` field set
    // to true. It will have no effect if the protocol is already running or preparing for a mux
    // scan.
    //
    // Since 4.4.
    virtual ::grpc::Status trigger_mux_scan(::grpc::ServerContext* context, const ::minknow_api::protocol::TriggerMuxScanRequest* request, ::minknow_api::protocol::TriggerMuxScanResponse* response);
    // Wait for a protocol run to finish.
    //
    // The call blocks until the run with the given run ID has finished (or returns immediately if
    // it had already finished) and returns information about the protocol run.
    //
    // If no run has been started with the provided run ID (or no run ID is given), an error is
    // returned.
    //
    // If NOTIFY_BEFORE_TERMINATION is specified for state, the protocol end time is an estimate, including
    // the allowed timeout.
    //
    // Since 1.10
    virtual ::grpc::Status wait_for_finished(::grpc::ServerContext* context, const ::minknow_api::protocol::WaitForFinishedRequest* request, ::minknow_api::protocol::ProtocolRunInfo* response);
    // Gets information about a protocol run.
    //
    // If no run ID is provided, information about the most recently started protocol run is
    // provided.
    //
    // Since 1.10
    virtual ::grpc::Status get_run_info(::grpc::ServerContext* context, const ::minknow_api::protocol::GetRunInfoRequest* request, ::minknow_api::protocol::ProtocolRunInfo* response);
    // List previously started protocol run ids (including any current protocol), in order of starting.
    //
    // The returned object can be used to find protocol information with get_run_info.
    //
    // Since 1.11
    virtual ::grpc::Status list_protocol_runs(::grpc::ServerContext* context, const ::minknow_api::protocol::ListProtocolRunsRequest* request, ::minknow_api::protocol::ListProtocolRunsResponse* response);
    // Returns the name and run id of the currently running protocol.
    //
    // Will fail with FAILED_PRECONDITION if there is no protocol running
    //
    // Since 1.11
    virtual ::grpc::Status get_current_protocol_run(::grpc::ServerContext* context, const ::minknow_api::protocol::GetCurrentProtocolRunRequest* request, ::minknow_api::protocol::ProtocolRunInfo* response);
    // Returns current protocol run info and streams any changes to the current protocol
    //
    // This call can be made even if there is no current protocol running. In this case, the next streamed
    // response will be the start of a new protocol instance and you will receive updates for that protocol
    // until it finishes
    //
    // If a protocol finishes this stream will still continue to run and you will be notified when a new protocol starts
    //
    // Since 1.12
    virtual ::grpc::Status watch_current_protocol_run(::grpc::ServerContext* context, const ::minknow_api::protocol::WatchCurrentProtocolRunRequest* request, ::grpc::ServerWriter< ::minknow_api::protocol::ProtocolRunInfo>* writer);
    // Gives back a list that contains info about each possible protocol script minknow is aware of.
    // This will most likely be used to retrieve a suitable protocol script that can be passed on to `start_protocol`
    //
    // Since 1.10
    virtual ::grpc::Status list_protocols(::grpc::ServerContext* context, const ::minknow_api::protocol::ListProtocolsRequest* request, ::minknow_api::protocol::ListProtocolsResponse* response);
    // Returns string-to-string map of the context tags
    //
    // Since 1.11
    virtual ::grpc::Status get_context_info(::grpc::ServerContext* context, const ::minknow_api::protocol::GetContextInfoRequest* request, ::minknow_api::protocol::GetContextInfoResponse* response);
    // Store context tags as arbitary string-to-string map
    //
    // Since 1.11
    virtual ::grpc::Status set_context_info(::grpc::ServerContext* context, const ::minknow_api::protocol::SetContextInfoRequest* request, ::minknow_api::protocol::SetContextInfoResponse* response);
    // Value set by protocol scripts to define the purpose of the script. Gets this value
    //
    // Since 1.11
    virtual ::grpc::Status get_protocol_purpose(::grpc::ServerContext* context, const ::minknow_api::protocol::GetProtocolPurposeRequest* request, ::minknow_api::protocol::GetProtocolPurposeResponse* response);
    // Sets the protocol purpose. See also get_protocol_purpose
    //
    // Since 1.11
    virtual ::grpc::Status set_protocol_purpose(::grpc::ServerContext* context, const ::minknow_api::protocol::SetProtocolPurposeRequest* request, ::minknow_api::protocol::SetProtocolPurposeResponse* response);
    // Links an epi2me workflow reference to a run id.
    //
    // Since 1.15
    virtual ::grpc::Status add_epi2me_workflow(::grpc::ServerContext* context, const ::minknow_api::protocol::AddEpi2meWorkflowRequest* request, ::minknow_api::protocol::AddEpi2meWorkflowResponse* response);
    // List all used protocol group ids used in any previous protocol on the box.
    //
    // Since 3.2
    virtual ::grpc::Status list_protocol_group_ids(::grpc::ServerContext* context, const ::minknow_api::protocol::ListProtocolGroupIdsRequest* request, ::minknow_api::protocol::ListProtocolGroupIdsResponse* response);
    // Run a hardware check on the connected flow cell.
    //
    // Throws an error if there is no flow cell connected.
    //
    // Since 4.3
    virtual ::grpc::Status begin_hardware_check(::grpc::ServerContext* context, const ::minknow_api::protocol::BeginHardwareCheckRequest* request, ::minknow_api::protocol::BeginHardwareCheckResponse* response);
    // Run platform qc on the connected flow cell
    //
    // Throws an error if there is no flow cell connected.
    //
    // Since 4.3
    virtual ::grpc::Status begin_platform_qc(::grpc::ServerContext* context, const ::minknow_api::protocol::BeginPlatformQcRequest* request, ::minknow_api::protocol::BeginPlatformQcResponse* response);
    virtual ::grpc::Status set_platform_qc_result(::grpc::ServerContext* context, const ::minknow_api::protocol::SetPlatformQcResultRequest* request, ::minknow_api::protocol::SetPlatformQcResultResponse* response);
    // Given a protocol and some information about the flow-cell and kits will provide a list
    // of settings required by the protocol, their defaults and dependencies.
    //
    // Since 4.3
    virtual ::grpc::Status list_settings_for_protocol(::grpc::ServerContext* context, const ::minknow_api::protocol::ListSettingsForProtocolRequest* request, ::minknow_api::protocol::ListSettingsForProtocolResponse* response);
    // Associated a post processing analysis process, and schedule it to run once the protocol is complete.
    //
    // If the protocol is already complete, the post proecssing analysis is executed immediately.
    //
    // Since 4.4
    virtual ::grpc::Status associate_post_processing_analysis_for_protocol(::grpc::ServerContext* context, const ::minknow_api::protocol::AssociatePostProcessingAnalysisRequest* request, ::minknow_api::protocol::AssociatePostProcessingAnalysisResponse* response);
    // Clears history data for specified protocol(s)
    //
    // History data includes protocol protocol info, acquisition info and statistics.
    //
    // Also clears any persistence data that has been written to disk for those protocols -- this
    // data will not be available after a restart.
    //
    // Does NOT clear experiment results (fast5, fastq, sequencing_summary, etc)
    //
    // Since 4.4
    //
    virtual ::grpc::Status clear_protocol_history_data(::grpc::ServerContext* context, const ::minknow_api::protocol::ClearProtocolHistoryDataRequest* request, ::minknow_api::protocol::ClearProtocolHistoryDataResponse* response);
    // This RPC should only be used by the protocol script.
    //
    // The protocol script can call this to opt in to protocol phase management. It can report the
    // phase it is currently in, and handle requests to change phase.
    //
    // Only one call to this RPC is possible at once. Ending the call will reset the phase to
    // PHASE_UNKNOWN and clear any set capabilities.
    //
    // Since 4.4.
    virtual ::grpc::Status protocol_phase_management(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::minknow_api::protocol::ProtocolPhaseManagementResponse, ::minknow_api::protocol::ProtocolPhaseManagementRequest>* stream);
  };
  template <class BaseClass>
  class WithAsyncMethod_start_protocol : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_start_protocol() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_start_protocol() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status start_protocol(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::StartProtocolRequest* /*request*/, ::minknow_api::protocol::StartProtocolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requeststart_protocol(::grpc::ServerContext* context, ::minknow_api::protocol::StartProtocolRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::protocol::StartProtocolResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_stop_protocol : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_stop_protocol() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_stop_protocol() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stop_protocol(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::StopProtocolRequest* /*request*/, ::minknow_api::protocol::StopProtocolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requeststop_protocol(::grpc::ServerContext* context, ::minknow_api::protocol::StopProtocolRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::protocol::StopProtocolResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_pause_protocol : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_pause_protocol() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_pause_protocol() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pause_protocol(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::PauseProtocolRequest* /*request*/, ::minknow_api::protocol::PauseProtocolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestpause_protocol(::grpc::ServerContext* context, ::minknow_api::protocol::PauseProtocolRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::protocol::PauseProtocolResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_resume_protocol : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_resume_protocol() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_resume_protocol() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status resume_protocol(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::ResumeProtocolRequest* /*request*/, ::minknow_api::protocol::ResumeProtocolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestresume_protocol(::grpc::ServerContext* context, ::minknow_api::protocol::ResumeProtocolRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::protocol::ResumeProtocolResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_trigger_mux_scan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_trigger_mux_scan() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_trigger_mux_scan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status trigger_mux_scan(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::TriggerMuxScanRequest* /*request*/, ::minknow_api::protocol::TriggerMuxScanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesttrigger_mux_scan(::grpc::ServerContext* context, ::minknow_api::protocol::TriggerMuxScanRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::protocol::TriggerMuxScanResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_wait_for_finished : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_wait_for_finished() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_wait_for_finished() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status wait_for_finished(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::WaitForFinishedRequest* /*request*/, ::minknow_api::protocol::ProtocolRunInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestwait_for_finished(::grpc::ServerContext* context, ::minknow_api::protocol::WaitForFinishedRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::protocol::ProtocolRunInfo>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_run_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_run_info() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_get_run_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_run_info(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::GetRunInfoRequest* /*request*/, ::minknow_api::protocol::ProtocolRunInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_run_info(::grpc::ServerContext* context, ::minknow_api::protocol::GetRunInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::protocol::ProtocolRunInfo>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_list_protocol_runs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_list_protocol_runs() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_list_protocol_runs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status list_protocol_runs(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::ListProtocolRunsRequest* /*request*/, ::minknow_api::protocol::ListProtocolRunsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestlist_protocol_runs(::grpc::ServerContext* context, ::minknow_api::protocol::ListProtocolRunsRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::protocol::ListProtocolRunsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_current_protocol_run : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_current_protocol_run() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_get_current_protocol_run() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_current_protocol_run(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::GetCurrentProtocolRunRequest* /*request*/, ::minknow_api::protocol::ProtocolRunInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_current_protocol_run(::grpc::ServerContext* context, ::minknow_api::protocol::GetCurrentProtocolRunRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::protocol::ProtocolRunInfo>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_watch_current_protocol_run : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_watch_current_protocol_run() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_watch_current_protocol_run() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status watch_current_protocol_run(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::WatchCurrentProtocolRunRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::protocol::ProtocolRunInfo>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestwatch_current_protocol_run(::grpc::ServerContext* context, ::minknow_api::protocol::WatchCurrentProtocolRunRequest* request, ::grpc::ServerAsyncWriter< ::minknow_api::protocol::ProtocolRunInfo>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(9, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_list_protocols : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_list_protocols() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_list_protocols() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status list_protocols(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::ListProtocolsRequest* /*request*/, ::minknow_api::protocol::ListProtocolsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestlist_protocols(::grpc::ServerContext* context, ::minknow_api::protocol::ListProtocolsRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::protocol::ListProtocolsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_context_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_context_info() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_get_context_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_context_info(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::GetContextInfoRequest* /*request*/, ::minknow_api::protocol::GetContextInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_context_info(::grpc::ServerContext* context, ::minknow_api::protocol::GetContextInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::protocol::GetContextInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_set_context_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_set_context_info() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_set_context_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_context_info(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::SetContextInfoRequest* /*request*/, ::minknow_api::protocol::SetContextInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_context_info(::grpc::ServerContext* context, ::minknow_api::protocol::SetContextInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::protocol::SetContextInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_protocol_purpose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_protocol_purpose() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_get_protocol_purpose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_protocol_purpose(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::GetProtocolPurposeRequest* /*request*/, ::minknow_api::protocol::GetProtocolPurposeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_protocol_purpose(::grpc::ServerContext* context, ::minknow_api::protocol::GetProtocolPurposeRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::protocol::GetProtocolPurposeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_set_protocol_purpose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_set_protocol_purpose() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_set_protocol_purpose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_protocol_purpose(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::SetProtocolPurposeRequest* /*request*/, ::minknow_api::protocol::SetProtocolPurposeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_protocol_purpose(::grpc::ServerContext* context, ::minknow_api::protocol::SetProtocolPurposeRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::protocol::SetProtocolPurposeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_add_epi2me_workflow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_add_epi2me_workflow() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_add_epi2me_workflow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status add_epi2me_workflow(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::AddEpi2meWorkflowRequest* /*request*/, ::minknow_api::protocol::AddEpi2meWorkflowResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestadd_epi2me_workflow(::grpc::ServerContext* context, ::minknow_api::protocol::AddEpi2meWorkflowRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::protocol::AddEpi2meWorkflowResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_list_protocol_group_ids : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_list_protocol_group_ids() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_list_protocol_group_ids() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status list_protocol_group_ids(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::ListProtocolGroupIdsRequest* /*request*/, ::minknow_api::protocol::ListProtocolGroupIdsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestlist_protocol_group_ids(::grpc::ServerContext* context, ::minknow_api::protocol::ListProtocolGroupIdsRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::protocol::ListProtocolGroupIdsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_begin_hardware_check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_begin_hardware_check() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_begin_hardware_check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status begin_hardware_check(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::BeginHardwareCheckRequest* /*request*/, ::minknow_api::protocol::BeginHardwareCheckResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestbegin_hardware_check(::grpc::ServerContext* context, ::minknow_api::protocol::BeginHardwareCheckRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::protocol::BeginHardwareCheckResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_begin_platform_qc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_begin_platform_qc() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_begin_platform_qc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status begin_platform_qc(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::BeginPlatformQcRequest* /*request*/, ::minknow_api::protocol::BeginPlatformQcResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestbegin_platform_qc(::grpc::ServerContext* context, ::minknow_api::protocol::BeginPlatformQcRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::protocol::BeginPlatformQcResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_set_platform_qc_result : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_set_platform_qc_result() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_set_platform_qc_result() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_platform_qc_result(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::SetPlatformQcResultRequest* /*request*/, ::minknow_api::protocol::SetPlatformQcResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_platform_qc_result(::grpc::ServerContext* context, ::minknow_api::protocol::SetPlatformQcResultRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::protocol::SetPlatformQcResultResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_list_settings_for_protocol : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_list_settings_for_protocol() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_list_settings_for_protocol() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status list_settings_for_protocol(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::ListSettingsForProtocolRequest* /*request*/, ::minknow_api::protocol::ListSettingsForProtocolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestlist_settings_for_protocol(::grpc::ServerContext* context, ::minknow_api::protocol::ListSettingsForProtocolRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::protocol::ListSettingsForProtocolResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_associate_post_processing_analysis_for_protocol : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_associate_post_processing_analysis_for_protocol() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_associate_post_processing_analysis_for_protocol() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status associate_post_processing_analysis_for_protocol(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::AssociatePostProcessingAnalysisRequest* /*request*/, ::minknow_api::protocol::AssociatePostProcessingAnalysisResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestassociate_post_processing_analysis_for_protocol(::grpc::ServerContext* context, ::minknow_api::protocol::AssociatePostProcessingAnalysisRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::protocol::AssociatePostProcessingAnalysisResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_clear_protocol_history_data : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_clear_protocol_history_data() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_clear_protocol_history_data() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clear_protocol_history_data(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::ClearProtocolHistoryDataRequest* /*request*/, ::minknow_api::protocol::ClearProtocolHistoryDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestclear_protocol_history_data(::grpc::ServerContext* context, ::minknow_api::protocol::ClearProtocolHistoryDataRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::protocol::ClearProtocolHistoryDataResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_protocol_phase_management : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_protocol_phase_management() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_protocol_phase_management() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status protocol_phase_management(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::minknow_api::protocol::ProtocolPhaseManagementResponse, ::minknow_api::protocol::ProtocolPhaseManagementRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestprotocol_phase_management(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::minknow_api::protocol::ProtocolPhaseManagementResponse, ::minknow_api::protocol::ProtocolPhaseManagementRequest>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(23, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_start_protocol<WithAsyncMethod_stop_protocol<WithAsyncMethod_pause_protocol<WithAsyncMethod_resume_protocol<WithAsyncMethod_trigger_mux_scan<WithAsyncMethod_wait_for_finished<WithAsyncMethod_get_run_info<WithAsyncMethod_list_protocol_runs<WithAsyncMethod_get_current_protocol_run<WithAsyncMethod_watch_current_protocol_run<WithAsyncMethod_list_protocols<WithAsyncMethod_get_context_info<WithAsyncMethod_set_context_info<WithAsyncMethod_get_protocol_purpose<WithAsyncMethod_set_protocol_purpose<WithAsyncMethod_add_epi2me_workflow<WithAsyncMethod_list_protocol_group_ids<WithAsyncMethod_begin_hardware_check<WithAsyncMethod_begin_platform_qc<WithAsyncMethod_set_platform_qc_result<WithAsyncMethod_list_settings_for_protocol<WithAsyncMethod_associate_post_processing_analysis_for_protocol<WithAsyncMethod_clear_protocol_history_data<WithAsyncMethod_protocol_phase_management<Service > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_start_protocol : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_start_protocol() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::StartProtocolRequest, ::minknow_api::protocol::StartProtocolResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::protocol::StartProtocolRequest* request, ::minknow_api::protocol::StartProtocolResponse* response) { return this->start_protocol(context, request, response); }));}
    void SetMessageAllocatorFor_start_protocol(
        ::grpc::MessageAllocator< ::minknow_api::protocol::StartProtocolRequest, ::minknow_api::protocol::StartProtocolResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::StartProtocolRequest, ::minknow_api::protocol::StartProtocolResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_start_protocol() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status start_protocol(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::StartProtocolRequest* /*request*/, ::minknow_api::protocol::StartProtocolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* start_protocol(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::protocol::StartProtocolRequest* /*request*/, ::minknow_api::protocol::StartProtocolResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_stop_protocol : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_stop_protocol() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::StopProtocolRequest, ::minknow_api::protocol::StopProtocolResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::protocol::StopProtocolRequest* request, ::minknow_api::protocol::StopProtocolResponse* response) { return this->stop_protocol(context, request, response); }));}
    void SetMessageAllocatorFor_stop_protocol(
        ::grpc::MessageAllocator< ::minknow_api::protocol::StopProtocolRequest, ::minknow_api::protocol::StopProtocolResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::StopProtocolRequest, ::minknow_api::protocol::StopProtocolResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_stop_protocol() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stop_protocol(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::StopProtocolRequest* /*request*/, ::minknow_api::protocol::StopProtocolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* stop_protocol(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::protocol::StopProtocolRequest* /*request*/, ::minknow_api::protocol::StopProtocolResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_pause_protocol : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_pause_protocol() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::PauseProtocolRequest, ::minknow_api::protocol::PauseProtocolResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::protocol::PauseProtocolRequest* request, ::minknow_api::protocol::PauseProtocolResponse* response) { return this->pause_protocol(context, request, response); }));}
    void SetMessageAllocatorFor_pause_protocol(
        ::grpc::MessageAllocator< ::minknow_api::protocol::PauseProtocolRequest, ::minknow_api::protocol::PauseProtocolResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::PauseProtocolRequest, ::minknow_api::protocol::PauseProtocolResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_pause_protocol() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pause_protocol(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::PauseProtocolRequest* /*request*/, ::minknow_api::protocol::PauseProtocolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* pause_protocol(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::protocol::PauseProtocolRequest* /*request*/, ::minknow_api::protocol::PauseProtocolResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_resume_protocol : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_resume_protocol() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::ResumeProtocolRequest, ::minknow_api::protocol::ResumeProtocolResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::protocol::ResumeProtocolRequest* request, ::minknow_api::protocol::ResumeProtocolResponse* response) { return this->resume_protocol(context, request, response); }));}
    void SetMessageAllocatorFor_resume_protocol(
        ::grpc::MessageAllocator< ::minknow_api::protocol::ResumeProtocolRequest, ::minknow_api::protocol::ResumeProtocolResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::ResumeProtocolRequest, ::minknow_api::protocol::ResumeProtocolResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_resume_protocol() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status resume_protocol(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::ResumeProtocolRequest* /*request*/, ::minknow_api::protocol::ResumeProtocolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* resume_protocol(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::protocol::ResumeProtocolRequest* /*request*/, ::minknow_api::protocol::ResumeProtocolResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_trigger_mux_scan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_trigger_mux_scan() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::TriggerMuxScanRequest, ::minknow_api::protocol::TriggerMuxScanResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::protocol::TriggerMuxScanRequest* request, ::minknow_api::protocol::TriggerMuxScanResponse* response) { return this->trigger_mux_scan(context, request, response); }));}
    void SetMessageAllocatorFor_trigger_mux_scan(
        ::grpc::MessageAllocator< ::minknow_api::protocol::TriggerMuxScanRequest, ::minknow_api::protocol::TriggerMuxScanResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::TriggerMuxScanRequest, ::minknow_api::protocol::TriggerMuxScanResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_trigger_mux_scan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status trigger_mux_scan(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::TriggerMuxScanRequest* /*request*/, ::minknow_api::protocol::TriggerMuxScanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* trigger_mux_scan(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::protocol::TriggerMuxScanRequest* /*request*/, ::minknow_api::protocol::TriggerMuxScanResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_wait_for_finished : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_wait_for_finished() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::WaitForFinishedRequest, ::minknow_api::protocol::ProtocolRunInfo>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::protocol::WaitForFinishedRequest* request, ::minknow_api::protocol::ProtocolRunInfo* response) { return this->wait_for_finished(context, request, response); }));}
    void SetMessageAllocatorFor_wait_for_finished(
        ::grpc::MessageAllocator< ::minknow_api::protocol::WaitForFinishedRequest, ::minknow_api::protocol::ProtocolRunInfo>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::WaitForFinishedRequest, ::minknow_api::protocol::ProtocolRunInfo>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_wait_for_finished() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status wait_for_finished(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::WaitForFinishedRequest* /*request*/, ::minknow_api::protocol::ProtocolRunInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* wait_for_finished(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::protocol::WaitForFinishedRequest* /*request*/, ::minknow_api::protocol::ProtocolRunInfo* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_run_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_run_info() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::GetRunInfoRequest, ::minknow_api::protocol::ProtocolRunInfo>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::protocol::GetRunInfoRequest* request, ::minknow_api::protocol::ProtocolRunInfo* response) { return this->get_run_info(context, request, response); }));}
    void SetMessageAllocatorFor_get_run_info(
        ::grpc::MessageAllocator< ::minknow_api::protocol::GetRunInfoRequest, ::minknow_api::protocol::ProtocolRunInfo>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::GetRunInfoRequest, ::minknow_api::protocol::ProtocolRunInfo>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_run_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_run_info(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::GetRunInfoRequest* /*request*/, ::minknow_api::protocol::ProtocolRunInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_run_info(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::protocol::GetRunInfoRequest* /*request*/, ::minknow_api::protocol::ProtocolRunInfo* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_list_protocol_runs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_list_protocol_runs() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::ListProtocolRunsRequest, ::minknow_api::protocol::ListProtocolRunsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::protocol::ListProtocolRunsRequest* request, ::minknow_api::protocol::ListProtocolRunsResponse* response) { return this->list_protocol_runs(context, request, response); }));}
    void SetMessageAllocatorFor_list_protocol_runs(
        ::grpc::MessageAllocator< ::minknow_api::protocol::ListProtocolRunsRequest, ::minknow_api::protocol::ListProtocolRunsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::ListProtocolRunsRequest, ::minknow_api::protocol::ListProtocolRunsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_list_protocol_runs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status list_protocol_runs(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::ListProtocolRunsRequest* /*request*/, ::minknow_api::protocol::ListProtocolRunsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* list_protocol_runs(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::protocol::ListProtocolRunsRequest* /*request*/, ::minknow_api::protocol::ListProtocolRunsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_current_protocol_run : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_current_protocol_run() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::GetCurrentProtocolRunRequest, ::minknow_api::protocol::ProtocolRunInfo>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::protocol::GetCurrentProtocolRunRequest* request, ::minknow_api::protocol::ProtocolRunInfo* response) { return this->get_current_protocol_run(context, request, response); }));}
    void SetMessageAllocatorFor_get_current_protocol_run(
        ::grpc::MessageAllocator< ::minknow_api::protocol::GetCurrentProtocolRunRequest, ::minknow_api::protocol::ProtocolRunInfo>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::GetCurrentProtocolRunRequest, ::minknow_api::protocol::ProtocolRunInfo>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_current_protocol_run() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_current_protocol_run(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::GetCurrentProtocolRunRequest* /*request*/, ::minknow_api::protocol::ProtocolRunInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_current_protocol_run(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::protocol::GetCurrentProtocolRunRequest* /*request*/, ::minknow_api::protocol::ProtocolRunInfo* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_watch_current_protocol_run : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_watch_current_protocol_run() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackServerStreamingHandler< ::minknow_api::protocol::WatchCurrentProtocolRunRequest, ::minknow_api::protocol::ProtocolRunInfo>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::protocol::WatchCurrentProtocolRunRequest* request) { return this->watch_current_protocol_run(context, request); }));
    }
    ~WithCallbackMethod_watch_current_protocol_run() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status watch_current_protocol_run(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::WatchCurrentProtocolRunRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::protocol::ProtocolRunInfo>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::minknow_api::protocol::ProtocolRunInfo>* watch_current_protocol_run(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::protocol::WatchCurrentProtocolRunRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_list_protocols : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_list_protocols() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::ListProtocolsRequest, ::minknow_api::protocol::ListProtocolsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::protocol::ListProtocolsRequest* request, ::minknow_api::protocol::ListProtocolsResponse* response) { return this->list_protocols(context, request, response); }));}
    void SetMessageAllocatorFor_list_protocols(
        ::grpc::MessageAllocator< ::minknow_api::protocol::ListProtocolsRequest, ::minknow_api::protocol::ListProtocolsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::ListProtocolsRequest, ::minknow_api::protocol::ListProtocolsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_list_protocols() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status list_protocols(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::ListProtocolsRequest* /*request*/, ::minknow_api::protocol::ListProtocolsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* list_protocols(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::protocol::ListProtocolsRequest* /*request*/, ::minknow_api::protocol::ListProtocolsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_context_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_context_info() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::GetContextInfoRequest, ::minknow_api::protocol::GetContextInfoResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::protocol::GetContextInfoRequest* request, ::minknow_api::protocol::GetContextInfoResponse* response) { return this->get_context_info(context, request, response); }));}
    void SetMessageAllocatorFor_get_context_info(
        ::grpc::MessageAllocator< ::minknow_api::protocol::GetContextInfoRequest, ::minknow_api::protocol::GetContextInfoResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::GetContextInfoRequest, ::minknow_api::protocol::GetContextInfoResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_context_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_context_info(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::GetContextInfoRequest* /*request*/, ::minknow_api::protocol::GetContextInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_context_info(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::protocol::GetContextInfoRequest* /*request*/, ::minknow_api::protocol::GetContextInfoResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_set_context_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_set_context_info() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::SetContextInfoRequest, ::minknow_api::protocol::SetContextInfoResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::protocol::SetContextInfoRequest* request, ::minknow_api::protocol::SetContextInfoResponse* response) { return this->set_context_info(context, request, response); }));}
    void SetMessageAllocatorFor_set_context_info(
        ::grpc::MessageAllocator< ::minknow_api::protocol::SetContextInfoRequest, ::minknow_api::protocol::SetContextInfoResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::SetContextInfoRequest, ::minknow_api::protocol::SetContextInfoResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_set_context_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_context_info(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::SetContextInfoRequest* /*request*/, ::minknow_api::protocol::SetContextInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_context_info(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::protocol::SetContextInfoRequest* /*request*/, ::minknow_api::protocol::SetContextInfoResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_protocol_purpose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_protocol_purpose() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::GetProtocolPurposeRequest, ::minknow_api::protocol::GetProtocolPurposeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::protocol::GetProtocolPurposeRequest* request, ::minknow_api::protocol::GetProtocolPurposeResponse* response) { return this->get_protocol_purpose(context, request, response); }));}
    void SetMessageAllocatorFor_get_protocol_purpose(
        ::grpc::MessageAllocator< ::minknow_api::protocol::GetProtocolPurposeRequest, ::minknow_api::protocol::GetProtocolPurposeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::GetProtocolPurposeRequest, ::minknow_api::protocol::GetProtocolPurposeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_protocol_purpose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_protocol_purpose(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::GetProtocolPurposeRequest* /*request*/, ::minknow_api::protocol::GetProtocolPurposeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_protocol_purpose(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::protocol::GetProtocolPurposeRequest* /*request*/, ::minknow_api::protocol::GetProtocolPurposeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_set_protocol_purpose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_set_protocol_purpose() {
      ::grpc::Service::MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::SetProtocolPurposeRequest, ::minknow_api::protocol::SetProtocolPurposeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::protocol::SetProtocolPurposeRequest* request, ::minknow_api::protocol::SetProtocolPurposeResponse* response) { return this->set_protocol_purpose(context, request, response); }));}
    void SetMessageAllocatorFor_set_protocol_purpose(
        ::grpc::MessageAllocator< ::minknow_api::protocol::SetProtocolPurposeRequest, ::minknow_api::protocol::SetProtocolPurposeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::SetProtocolPurposeRequest, ::minknow_api::protocol::SetProtocolPurposeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_set_protocol_purpose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_protocol_purpose(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::SetProtocolPurposeRequest* /*request*/, ::minknow_api::protocol::SetProtocolPurposeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_protocol_purpose(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::protocol::SetProtocolPurposeRequest* /*request*/, ::minknow_api::protocol::SetProtocolPurposeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_add_epi2me_workflow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_add_epi2me_workflow() {
      ::grpc::Service::MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::AddEpi2meWorkflowRequest, ::minknow_api::protocol::AddEpi2meWorkflowResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::protocol::AddEpi2meWorkflowRequest* request, ::minknow_api::protocol::AddEpi2meWorkflowResponse* response) { return this->add_epi2me_workflow(context, request, response); }));}
    void SetMessageAllocatorFor_add_epi2me_workflow(
        ::grpc::MessageAllocator< ::minknow_api::protocol::AddEpi2meWorkflowRequest, ::minknow_api::protocol::AddEpi2meWorkflowResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::AddEpi2meWorkflowRequest, ::minknow_api::protocol::AddEpi2meWorkflowResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_add_epi2me_workflow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status add_epi2me_workflow(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::AddEpi2meWorkflowRequest* /*request*/, ::minknow_api::protocol::AddEpi2meWorkflowResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* add_epi2me_workflow(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::protocol::AddEpi2meWorkflowRequest* /*request*/, ::minknow_api::protocol::AddEpi2meWorkflowResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_list_protocol_group_ids : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_list_protocol_group_ids() {
      ::grpc::Service::MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::ListProtocolGroupIdsRequest, ::minknow_api::protocol::ListProtocolGroupIdsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::protocol::ListProtocolGroupIdsRequest* request, ::minknow_api::protocol::ListProtocolGroupIdsResponse* response) { return this->list_protocol_group_ids(context, request, response); }));}
    void SetMessageAllocatorFor_list_protocol_group_ids(
        ::grpc::MessageAllocator< ::minknow_api::protocol::ListProtocolGroupIdsRequest, ::minknow_api::protocol::ListProtocolGroupIdsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::ListProtocolGroupIdsRequest, ::minknow_api::protocol::ListProtocolGroupIdsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_list_protocol_group_ids() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status list_protocol_group_ids(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::ListProtocolGroupIdsRequest* /*request*/, ::minknow_api::protocol::ListProtocolGroupIdsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* list_protocol_group_ids(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::protocol::ListProtocolGroupIdsRequest* /*request*/, ::minknow_api::protocol::ListProtocolGroupIdsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_begin_hardware_check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_begin_hardware_check() {
      ::grpc::Service::MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::BeginHardwareCheckRequest, ::minknow_api::protocol::BeginHardwareCheckResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::protocol::BeginHardwareCheckRequest* request, ::minknow_api::protocol::BeginHardwareCheckResponse* response) { return this->begin_hardware_check(context, request, response); }));}
    void SetMessageAllocatorFor_begin_hardware_check(
        ::grpc::MessageAllocator< ::minknow_api::protocol::BeginHardwareCheckRequest, ::minknow_api::protocol::BeginHardwareCheckResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::BeginHardwareCheckRequest, ::minknow_api::protocol::BeginHardwareCheckResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_begin_hardware_check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status begin_hardware_check(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::BeginHardwareCheckRequest* /*request*/, ::minknow_api::protocol::BeginHardwareCheckResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* begin_hardware_check(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::protocol::BeginHardwareCheckRequest* /*request*/, ::minknow_api::protocol::BeginHardwareCheckResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_begin_platform_qc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_begin_platform_qc() {
      ::grpc::Service::MarkMethodCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::BeginPlatformQcRequest, ::minknow_api::protocol::BeginPlatformQcResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::protocol::BeginPlatformQcRequest* request, ::minknow_api::protocol::BeginPlatformQcResponse* response) { return this->begin_platform_qc(context, request, response); }));}
    void SetMessageAllocatorFor_begin_platform_qc(
        ::grpc::MessageAllocator< ::minknow_api::protocol::BeginPlatformQcRequest, ::minknow_api::protocol::BeginPlatformQcResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::BeginPlatformQcRequest, ::minknow_api::protocol::BeginPlatformQcResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_begin_platform_qc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status begin_platform_qc(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::BeginPlatformQcRequest* /*request*/, ::minknow_api::protocol::BeginPlatformQcResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* begin_platform_qc(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::protocol::BeginPlatformQcRequest* /*request*/, ::minknow_api::protocol::BeginPlatformQcResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_set_platform_qc_result : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_set_platform_qc_result() {
      ::grpc::Service::MarkMethodCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::SetPlatformQcResultRequest, ::minknow_api::protocol::SetPlatformQcResultResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::protocol::SetPlatformQcResultRequest* request, ::minknow_api::protocol::SetPlatformQcResultResponse* response) { return this->set_platform_qc_result(context, request, response); }));}
    void SetMessageAllocatorFor_set_platform_qc_result(
        ::grpc::MessageAllocator< ::minknow_api::protocol::SetPlatformQcResultRequest, ::minknow_api::protocol::SetPlatformQcResultResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(19);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::SetPlatformQcResultRequest, ::minknow_api::protocol::SetPlatformQcResultResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_set_platform_qc_result() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_platform_qc_result(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::SetPlatformQcResultRequest* /*request*/, ::minknow_api::protocol::SetPlatformQcResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_platform_qc_result(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::protocol::SetPlatformQcResultRequest* /*request*/, ::minknow_api::protocol::SetPlatformQcResultResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_list_settings_for_protocol : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_list_settings_for_protocol() {
      ::grpc::Service::MarkMethodCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::ListSettingsForProtocolRequest, ::minknow_api::protocol::ListSettingsForProtocolResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::protocol::ListSettingsForProtocolRequest* request, ::minknow_api::protocol::ListSettingsForProtocolResponse* response) { return this->list_settings_for_protocol(context, request, response); }));}
    void SetMessageAllocatorFor_list_settings_for_protocol(
        ::grpc::MessageAllocator< ::minknow_api::protocol::ListSettingsForProtocolRequest, ::minknow_api::protocol::ListSettingsForProtocolResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(20);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::ListSettingsForProtocolRequest, ::minknow_api::protocol::ListSettingsForProtocolResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_list_settings_for_protocol() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status list_settings_for_protocol(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::ListSettingsForProtocolRequest* /*request*/, ::minknow_api::protocol::ListSettingsForProtocolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* list_settings_for_protocol(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::protocol::ListSettingsForProtocolRequest* /*request*/, ::minknow_api::protocol::ListSettingsForProtocolResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_associate_post_processing_analysis_for_protocol : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_associate_post_processing_analysis_for_protocol() {
      ::grpc::Service::MarkMethodCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::AssociatePostProcessingAnalysisRequest, ::minknow_api::protocol::AssociatePostProcessingAnalysisResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::protocol::AssociatePostProcessingAnalysisRequest* request, ::minknow_api::protocol::AssociatePostProcessingAnalysisResponse* response) { return this->associate_post_processing_analysis_for_protocol(context, request, response); }));}
    void SetMessageAllocatorFor_associate_post_processing_analysis_for_protocol(
        ::grpc::MessageAllocator< ::minknow_api::protocol::AssociatePostProcessingAnalysisRequest, ::minknow_api::protocol::AssociatePostProcessingAnalysisResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(21);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::AssociatePostProcessingAnalysisRequest, ::minknow_api::protocol::AssociatePostProcessingAnalysisResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_associate_post_processing_analysis_for_protocol() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status associate_post_processing_analysis_for_protocol(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::AssociatePostProcessingAnalysisRequest* /*request*/, ::minknow_api::protocol::AssociatePostProcessingAnalysisResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* associate_post_processing_analysis_for_protocol(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::protocol::AssociatePostProcessingAnalysisRequest* /*request*/, ::minknow_api::protocol::AssociatePostProcessingAnalysisResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_clear_protocol_history_data : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_clear_protocol_history_data() {
      ::grpc::Service::MarkMethodCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::ClearProtocolHistoryDataRequest, ::minknow_api::protocol::ClearProtocolHistoryDataResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::protocol::ClearProtocolHistoryDataRequest* request, ::minknow_api::protocol::ClearProtocolHistoryDataResponse* response) { return this->clear_protocol_history_data(context, request, response); }));}
    void SetMessageAllocatorFor_clear_protocol_history_data(
        ::grpc::MessageAllocator< ::minknow_api::protocol::ClearProtocolHistoryDataRequest, ::minknow_api::protocol::ClearProtocolHistoryDataResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(22);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::protocol::ClearProtocolHistoryDataRequest, ::minknow_api::protocol::ClearProtocolHistoryDataResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_clear_protocol_history_data() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clear_protocol_history_data(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::ClearProtocolHistoryDataRequest* /*request*/, ::minknow_api::protocol::ClearProtocolHistoryDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* clear_protocol_history_data(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::protocol::ClearProtocolHistoryDataRequest* /*request*/, ::minknow_api::protocol::ClearProtocolHistoryDataResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_protocol_phase_management : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_protocol_phase_management() {
      ::grpc::Service::MarkMethodCallback(23,
          new ::grpc::internal::CallbackBidiHandler< ::minknow_api::protocol::ProtocolPhaseManagementRequest, ::minknow_api::protocol::ProtocolPhaseManagementResponse>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->protocol_phase_management(context); }));
    }
    ~WithCallbackMethod_protocol_phase_management() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status protocol_phase_management(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::minknow_api::protocol::ProtocolPhaseManagementResponse, ::minknow_api::protocol::ProtocolPhaseManagementRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::minknow_api::protocol::ProtocolPhaseManagementRequest, ::minknow_api::protocol::ProtocolPhaseManagementResponse>* protocol_phase_management(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  typedef WithCallbackMethod_start_protocol<WithCallbackMethod_stop_protocol<WithCallbackMethod_pause_protocol<WithCallbackMethod_resume_protocol<WithCallbackMethod_trigger_mux_scan<WithCallbackMethod_wait_for_finished<WithCallbackMethod_get_run_info<WithCallbackMethod_list_protocol_runs<WithCallbackMethod_get_current_protocol_run<WithCallbackMethod_watch_current_protocol_run<WithCallbackMethod_list_protocols<WithCallbackMethod_get_context_info<WithCallbackMethod_set_context_info<WithCallbackMethod_get_protocol_purpose<WithCallbackMethod_set_protocol_purpose<WithCallbackMethod_add_epi2me_workflow<WithCallbackMethod_list_protocol_group_ids<WithCallbackMethod_begin_hardware_check<WithCallbackMethod_begin_platform_qc<WithCallbackMethod_set_platform_qc_result<WithCallbackMethod_list_settings_for_protocol<WithCallbackMethod_associate_post_processing_analysis_for_protocol<WithCallbackMethod_clear_protocol_history_data<WithCallbackMethod_protocol_phase_management<Service > > > > > > > > > > > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_start_protocol : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_start_protocol() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_start_protocol() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status start_protocol(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::StartProtocolRequest* /*request*/, ::minknow_api::protocol::StartProtocolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_stop_protocol : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_stop_protocol() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_stop_protocol() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stop_protocol(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::StopProtocolRequest* /*request*/, ::minknow_api::protocol::StopProtocolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_pause_protocol : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_pause_protocol() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_pause_protocol() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pause_protocol(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::PauseProtocolRequest* /*request*/, ::minknow_api::protocol::PauseProtocolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_resume_protocol : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_resume_protocol() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_resume_protocol() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status resume_protocol(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::ResumeProtocolRequest* /*request*/, ::minknow_api::protocol::ResumeProtocolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_trigger_mux_scan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_trigger_mux_scan() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_trigger_mux_scan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status trigger_mux_scan(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::TriggerMuxScanRequest* /*request*/, ::minknow_api::protocol::TriggerMuxScanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_wait_for_finished : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_wait_for_finished() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_wait_for_finished() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status wait_for_finished(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::WaitForFinishedRequest* /*request*/, ::minknow_api::protocol::ProtocolRunInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_run_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_run_info() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_get_run_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_run_info(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::GetRunInfoRequest* /*request*/, ::minknow_api::protocol::ProtocolRunInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_list_protocol_runs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_list_protocol_runs() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_list_protocol_runs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status list_protocol_runs(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::ListProtocolRunsRequest* /*request*/, ::minknow_api::protocol::ListProtocolRunsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_current_protocol_run : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_current_protocol_run() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_get_current_protocol_run() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_current_protocol_run(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::GetCurrentProtocolRunRequest* /*request*/, ::minknow_api::protocol::ProtocolRunInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_watch_current_protocol_run : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_watch_current_protocol_run() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_watch_current_protocol_run() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status watch_current_protocol_run(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::WatchCurrentProtocolRunRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::protocol::ProtocolRunInfo>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_list_protocols : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_list_protocols() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_list_protocols() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status list_protocols(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::ListProtocolsRequest* /*request*/, ::minknow_api::protocol::ListProtocolsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_context_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_context_info() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_get_context_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_context_info(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::GetContextInfoRequest* /*request*/, ::minknow_api::protocol::GetContextInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_set_context_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_set_context_info() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_set_context_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_context_info(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::SetContextInfoRequest* /*request*/, ::minknow_api::protocol::SetContextInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_protocol_purpose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_protocol_purpose() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_get_protocol_purpose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_protocol_purpose(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::GetProtocolPurposeRequest* /*request*/, ::minknow_api::protocol::GetProtocolPurposeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_set_protocol_purpose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_set_protocol_purpose() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_set_protocol_purpose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_protocol_purpose(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::SetProtocolPurposeRequest* /*request*/, ::minknow_api::protocol::SetProtocolPurposeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_add_epi2me_workflow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_add_epi2me_workflow() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_add_epi2me_workflow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status add_epi2me_workflow(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::AddEpi2meWorkflowRequest* /*request*/, ::minknow_api::protocol::AddEpi2meWorkflowResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_list_protocol_group_ids : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_list_protocol_group_ids() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_list_protocol_group_ids() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status list_protocol_group_ids(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::ListProtocolGroupIdsRequest* /*request*/, ::minknow_api::protocol::ListProtocolGroupIdsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_begin_hardware_check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_begin_hardware_check() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_begin_hardware_check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status begin_hardware_check(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::BeginHardwareCheckRequest* /*request*/, ::minknow_api::protocol::BeginHardwareCheckResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_begin_platform_qc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_begin_platform_qc() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_begin_platform_qc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status begin_platform_qc(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::BeginPlatformQcRequest* /*request*/, ::minknow_api::protocol::BeginPlatformQcResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_set_platform_qc_result : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_set_platform_qc_result() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_set_platform_qc_result() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_platform_qc_result(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::SetPlatformQcResultRequest* /*request*/, ::minknow_api::protocol::SetPlatformQcResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_list_settings_for_protocol : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_list_settings_for_protocol() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_list_settings_for_protocol() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status list_settings_for_protocol(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::ListSettingsForProtocolRequest* /*request*/, ::minknow_api::protocol::ListSettingsForProtocolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_associate_post_processing_analysis_for_protocol : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_associate_post_processing_analysis_for_protocol() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_associate_post_processing_analysis_for_protocol() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status associate_post_processing_analysis_for_protocol(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::AssociatePostProcessingAnalysisRequest* /*request*/, ::minknow_api::protocol::AssociatePostProcessingAnalysisResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_clear_protocol_history_data : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_clear_protocol_history_data() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_clear_protocol_history_data() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clear_protocol_history_data(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::ClearProtocolHistoryDataRequest* /*request*/, ::minknow_api::protocol::ClearProtocolHistoryDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_protocol_phase_management : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_protocol_phase_management() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_protocol_phase_management() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status protocol_phase_management(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::minknow_api::protocol::ProtocolPhaseManagementResponse, ::minknow_api::protocol::ProtocolPhaseManagementRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_start_protocol : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_start_protocol() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_start_protocol() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status start_protocol(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::StartProtocolRequest* /*request*/, ::minknow_api::protocol::StartProtocolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requeststart_protocol(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_stop_protocol : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_stop_protocol() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_stop_protocol() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stop_protocol(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::StopProtocolRequest* /*request*/, ::minknow_api::protocol::StopProtocolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requeststop_protocol(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_pause_protocol : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_pause_protocol() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_pause_protocol() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pause_protocol(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::PauseProtocolRequest* /*request*/, ::minknow_api::protocol::PauseProtocolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestpause_protocol(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_resume_protocol : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_resume_protocol() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_resume_protocol() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status resume_protocol(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::ResumeProtocolRequest* /*request*/, ::minknow_api::protocol::ResumeProtocolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestresume_protocol(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_trigger_mux_scan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_trigger_mux_scan() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_trigger_mux_scan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status trigger_mux_scan(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::TriggerMuxScanRequest* /*request*/, ::minknow_api::protocol::TriggerMuxScanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesttrigger_mux_scan(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_wait_for_finished : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_wait_for_finished() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_wait_for_finished() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status wait_for_finished(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::WaitForFinishedRequest* /*request*/, ::minknow_api::protocol::ProtocolRunInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestwait_for_finished(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_run_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_run_info() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_get_run_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_run_info(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::GetRunInfoRequest* /*request*/, ::minknow_api::protocol::ProtocolRunInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_run_info(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_list_protocol_runs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_list_protocol_runs() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_list_protocol_runs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status list_protocol_runs(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::ListProtocolRunsRequest* /*request*/, ::minknow_api::protocol::ListProtocolRunsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestlist_protocol_runs(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_current_protocol_run : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_current_protocol_run() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_get_current_protocol_run() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_current_protocol_run(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::GetCurrentProtocolRunRequest* /*request*/, ::minknow_api::protocol::ProtocolRunInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_current_protocol_run(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_watch_current_protocol_run : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_watch_current_protocol_run() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_watch_current_protocol_run() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status watch_current_protocol_run(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::WatchCurrentProtocolRunRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::protocol::ProtocolRunInfo>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestwatch_current_protocol_run(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(9, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_list_protocols : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_list_protocols() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_list_protocols() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status list_protocols(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::ListProtocolsRequest* /*request*/, ::minknow_api::protocol::ListProtocolsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestlist_protocols(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_context_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_context_info() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_get_context_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_context_info(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::GetContextInfoRequest* /*request*/, ::minknow_api::protocol::GetContextInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_context_info(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_set_context_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_set_context_info() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_set_context_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_context_info(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::SetContextInfoRequest* /*request*/, ::minknow_api::protocol::SetContextInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_context_info(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_protocol_purpose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_protocol_purpose() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_get_protocol_purpose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_protocol_purpose(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::GetProtocolPurposeRequest* /*request*/, ::minknow_api::protocol::GetProtocolPurposeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_protocol_purpose(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_set_protocol_purpose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_set_protocol_purpose() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_set_protocol_purpose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_protocol_purpose(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::SetProtocolPurposeRequest* /*request*/, ::minknow_api::protocol::SetProtocolPurposeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_protocol_purpose(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_add_epi2me_workflow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_add_epi2me_workflow() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_add_epi2me_workflow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status add_epi2me_workflow(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::AddEpi2meWorkflowRequest* /*request*/, ::minknow_api::protocol::AddEpi2meWorkflowResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestadd_epi2me_workflow(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_list_protocol_group_ids : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_list_protocol_group_ids() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_list_protocol_group_ids() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status list_protocol_group_ids(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::ListProtocolGroupIdsRequest* /*request*/, ::minknow_api::protocol::ListProtocolGroupIdsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestlist_protocol_group_ids(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_begin_hardware_check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_begin_hardware_check() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_begin_hardware_check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status begin_hardware_check(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::BeginHardwareCheckRequest* /*request*/, ::minknow_api::protocol::BeginHardwareCheckResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestbegin_hardware_check(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_begin_platform_qc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_begin_platform_qc() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_begin_platform_qc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status begin_platform_qc(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::BeginPlatformQcRequest* /*request*/, ::minknow_api::protocol::BeginPlatformQcResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestbegin_platform_qc(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_set_platform_qc_result : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_set_platform_qc_result() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_set_platform_qc_result() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_platform_qc_result(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::SetPlatformQcResultRequest* /*request*/, ::minknow_api::protocol::SetPlatformQcResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_platform_qc_result(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_list_settings_for_protocol : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_list_settings_for_protocol() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_list_settings_for_protocol() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status list_settings_for_protocol(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::ListSettingsForProtocolRequest* /*request*/, ::minknow_api::protocol::ListSettingsForProtocolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestlist_settings_for_protocol(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_associate_post_processing_analysis_for_protocol : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_associate_post_processing_analysis_for_protocol() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_associate_post_processing_analysis_for_protocol() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status associate_post_processing_analysis_for_protocol(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::AssociatePostProcessingAnalysisRequest* /*request*/, ::minknow_api::protocol::AssociatePostProcessingAnalysisResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestassociate_post_processing_analysis_for_protocol(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_clear_protocol_history_data : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_clear_protocol_history_data() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_clear_protocol_history_data() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clear_protocol_history_data(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::ClearProtocolHistoryDataRequest* /*request*/, ::minknow_api::protocol::ClearProtocolHistoryDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestclear_protocol_history_data(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_protocol_phase_management : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_protocol_phase_management() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_protocol_phase_management() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status protocol_phase_management(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::minknow_api::protocol::ProtocolPhaseManagementResponse, ::minknow_api::protocol::ProtocolPhaseManagementRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestprotocol_phase_management(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(23, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_start_protocol : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_start_protocol() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->start_protocol(context, request, response); }));
    }
    ~WithRawCallbackMethod_start_protocol() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status start_protocol(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::StartProtocolRequest* /*request*/, ::minknow_api::protocol::StartProtocolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* start_protocol(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_stop_protocol : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_stop_protocol() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->stop_protocol(context, request, response); }));
    }
    ~WithRawCallbackMethod_stop_protocol() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stop_protocol(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::StopProtocolRequest* /*request*/, ::minknow_api::protocol::StopProtocolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* stop_protocol(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_pause_protocol : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_pause_protocol() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->pause_protocol(context, request, response); }));
    }
    ~WithRawCallbackMethod_pause_protocol() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pause_protocol(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::PauseProtocolRequest* /*request*/, ::minknow_api::protocol::PauseProtocolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* pause_protocol(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_resume_protocol : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_resume_protocol() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->resume_protocol(context, request, response); }));
    }
    ~WithRawCallbackMethod_resume_protocol() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status resume_protocol(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::ResumeProtocolRequest* /*request*/, ::minknow_api::protocol::ResumeProtocolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* resume_protocol(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_trigger_mux_scan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_trigger_mux_scan() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->trigger_mux_scan(context, request, response); }));
    }
    ~WithRawCallbackMethod_trigger_mux_scan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status trigger_mux_scan(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::TriggerMuxScanRequest* /*request*/, ::minknow_api::protocol::TriggerMuxScanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* trigger_mux_scan(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_wait_for_finished : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_wait_for_finished() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->wait_for_finished(context, request, response); }));
    }
    ~WithRawCallbackMethod_wait_for_finished() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status wait_for_finished(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::WaitForFinishedRequest* /*request*/, ::minknow_api::protocol::ProtocolRunInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* wait_for_finished(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_run_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_run_info() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_run_info(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_run_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_run_info(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::GetRunInfoRequest* /*request*/, ::minknow_api::protocol::ProtocolRunInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_run_info(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_list_protocol_runs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_list_protocol_runs() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->list_protocol_runs(context, request, response); }));
    }
    ~WithRawCallbackMethod_list_protocol_runs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status list_protocol_runs(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::ListProtocolRunsRequest* /*request*/, ::minknow_api::protocol::ListProtocolRunsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* list_protocol_runs(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_current_protocol_run : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_current_protocol_run() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_current_protocol_run(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_current_protocol_run() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_current_protocol_run(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::GetCurrentProtocolRunRequest* /*request*/, ::minknow_api::protocol::ProtocolRunInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_current_protocol_run(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_watch_current_protocol_run : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_watch_current_protocol_run() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->watch_current_protocol_run(context, request); }));
    }
    ~WithRawCallbackMethod_watch_current_protocol_run() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status watch_current_protocol_run(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::WatchCurrentProtocolRunRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::protocol::ProtocolRunInfo>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* watch_current_protocol_run(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_list_protocols : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_list_protocols() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->list_protocols(context, request, response); }));
    }
    ~WithRawCallbackMethod_list_protocols() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status list_protocols(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::ListProtocolsRequest* /*request*/, ::minknow_api::protocol::ListProtocolsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* list_protocols(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_context_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_context_info() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_context_info(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_context_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_context_info(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::GetContextInfoRequest* /*request*/, ::minknow_api::protocol::GetContextInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_context_info(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_set_context_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_set_context_info() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->set_context_info(context, request, response); }));
    }
    ~WithRawCallbackMethod_set_context_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_context_info(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::SetContextInfoRequest* /*request*/, ::minknow_api::protocol::SetContextInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_context_info(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_protocol_purpose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_protocol_purpose() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_protocol_purpose(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_protocol_purpose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_protocol_purpose(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::GetProtocolPurposeRequest* /*request*/, ::minknow_api::protocol::GetProtocolPurposeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_protocol_purpose(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_set_protocol_purpose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_set_protocol_purpose() {
      ::grpc::Service::MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->set_protocol_purpose(context, request, response); }));
    }
    ~WithRawCallbackMethod_set_protocol_purpose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_protocol_purpose(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::SetProtocolPurposeRequest* /*request*/, ::minknow_api::protocol::SetProtocolPurposeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_protocol_purpose(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_add_epi2me_workflow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_add_epi2me_workflow() {
      ::grpc::Service::MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->add_epi2me_workflow(context, request, response); }));
    }
    ~WithRawCallbackMethod_add_epi2me_workflow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status add_epi2me_workflow(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::AddEpi2meWorkflowRequest* /*request*/, ::minknow_api::protocol::AddEpi2meWorkflowResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* add_epi2me_workflow(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_list_protocol_group_ids : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_list_protocol_group_ids() {
      ::grpc::Service::MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->list_protocol_group_ids(context, request, response); }));
    }
    ~WithRawCallbackMethod_list_protocol_group_ids() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status list_protocol_group_ids(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::ListProtocolGroupIdsRequest* /*request*/, ::minknow_api::protocol::ListProtocolGroupIdsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* list_protocol_group_ids(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_begin_hardware_check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_begin_hardware_check() {
      ::grpc::Service::MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->begin_hardware_check(context, request, response); }));
    }
    ~WithRawCallbackMethod_begin_hardware_check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status begin_hardware_check(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::BeginHardwareCheckRequest* /*request*/, ::minknow_api::protocol::BeginHardwareCheckResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* begin_hardware_check(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_begin_platform_qc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_begin_platform_qc() {
      ::grpc::Service::MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->begin_platform_qc(context, request, response); }));
    }
    ~WithRawCallbackMethod_begin_platform_qc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status begin_platform_qc(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::BeginPlatformQcRequest* /*request*/, ::minknow_api::protocol::BeginPlatformQcResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* begin_platform_qc(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_set_platform_qc_result : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_set_platform_qc_result() {
      ::grpc::Service::MarkMethodRawCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->set_platform_qc_result(context, request, response); }));
    }
    ~WithRawCallbackMethod_set_platform_qc_result() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_platform_qc_result(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::SetPlatformQcResultRequest* /*request*/, ::minknow_api::protocol::SetPlatformQcResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_platform_qc_result(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_list_settings_for_protocol : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_list_settings_for_protocol() {
      ::grpc::Service::MarkMethodRawCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->list_settings_for_protocol(context, request, response); }));
    }
    ~WithRawCallbackMethod_list_settings_for_protocol() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status list_settings_for_protocol(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::ListSettingsForProtocolRequest* /*request*/, ::minknow_api::protocol::ListSettingsForProtocolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* list_settings_for_protocol(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_associate_post_processing_analysis_for_protocol : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_associate_post_processing_analysis_for_protocol() {
      ::grpc::Service::MarkMethodRawCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->associate_post_processing_analysis_for_protocol(context, request, response); }));
    }
    ~WithRawCallbackMethod_associate_post_processing_analysis_for_protocol() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status associate_post_processing_analysis_for_protocol(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::AssociatePostProcessingAnalysisRequest* /*request*/, ::minknow_api::protocol::AssociatePostProcessingAnalysisResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* associate_post_processing_analysis_for_protocol(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_clear_protocol_history_data : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_clear_protocol_history_data() {
      ::grpc::Service::MarkMethodRawCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->clear_protocol_history_data(context, request, response); }));
    }
    ~WithRawCallbackMethod_clear_protocol_history_data() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clear_protocol_history_data(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::ClearProtocolHistoryDataRequest* /*request*/, ::minknow_api::protocol::ClearProtocolHistoryDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* clear_protocol_history_data(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_protocol_phase_management : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_protocol_phase_management() {
      ::grpc::Service::MarkMethodRawCallback(23,
          new ::grpc::internal::CallbackBidiHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->protocol_phase_management(context); }));
    }
    ~WithRawCallbackMethod_protocol_phase_management() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status protocol_phase_management(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::minknow_api::protocol::ProtocolPhaseManagementResponse, ::minknow_api::protocol::ProtocolPhaseManagementRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* protocol_phase_management(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_start_protocol : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_start_protocol() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::protocol::StartProtocolRequest, ::minknow_api::protocol::StartProtocolResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::protocol::StartProtocolRequest, ::minknow_api::protocol::StartProtocolResponse>* streamer) {
                       return this->Streamedstart_protocol(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_start_protocol() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status start_protocol(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::StartProtocolRequest* /*request*/, ::minknow_api::protocol::StartProtocolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedstart_protocol(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::protocol::StartProtocolRequest,::minknow_api::protocol::StartProtocolResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_stop_protocol : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_stop_protocol() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::protocol::StopProtocolRequest, ::minknow_api::protocol::StopProtocolResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::protocol::StopProtocolRequest, ::minknow_api::protocol::StopProtocolResponse>* streamer) {
                       return this->Streamedstop_protocol(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_stop_protocol() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status stop_protocol(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::StopProtocolRequest* /*request*/, ::minknow_api::protocol::StopProtocolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedstop_protocol(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::protocol::StopProtocolRequest,::minknow_api::protocol::StopProtocolResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_pause_protocol : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_pause_protocol() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::protocol::PauseProtocolRequest, ::minknow_api::protocol::PauseProtocolResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::protocol::PauseProtocolRequest, ::minknow_api::protocol::PauseProtocolResponse>* streamer) {
                       return this->Streamedpause_protocol(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_pause_protocol() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status pause_protocol(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::PauseProtocolRequest* /*request*/, ::minknow_api::protocol::PauseProtocolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedpause_protocol(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::protocol::PauseProtocolRequest,::minknow_api::protocol::PauseProtocolResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_resume_protocol : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_resume_protocol() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::protocol::ResumeProtocolRequest, ::minknow_api::protocol::ResumeProtocolResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::protocol::ResumeProtocolRequest, ::minknow_api::protocol::ResumeProtocolResponse>* streamer) {
                       return this->Streamedresume_protocol(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_resume_protocol() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status resume_protocol(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::ResumeProtocolRequest* /*request*/, ::minknow_api::protocol::ResumeProtocolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedresume_protocol(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::protocol::ResumeProtocolRequest,::minknow_api::protocol::ResumeProtocolResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_trigger_mux_scan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_trigger_mux_scan() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::protocol::TriggerMuxScanRequest, ::minknow_api::protocol::TriggerMuxScanResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::protocol::TriggerMuxScanRequest, ::minknow_api::protocol::TriggerMuxScanResponse>* streamer) {
                       return this->Streamedtrigger_mux_scan(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_trigger_mux_scan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status trigger_mux_scan(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::TriggerMuxScanRequest* /*request*/, ::minknow_api::protocol::TriggerMuxScanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedtrigger_mux_scan(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::protocol::TriggerMuxScanRequest,::minknow_api::protocol::TriggerMuxScanResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_wait_for_finished : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_wait_for_finished() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::protocol::WaitForFinishedRequest, ::minknow_api::protocol::ProtocolRunInfo>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::protocol::WaitForFinishedRequest, ::minknow_api::protocol::ProtocolRunInfo>* streamer) {
                       return this->Streamedwait_for_finished(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_wait_for_finished() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status wait_for_finished(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::WaitForFinishedRequest* /*request*/, ::minknow_api::protocol::ProtocolRunInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedwait_for_finished(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::protocol::WaitForFinishedRequest,::minknow_api::protocol::ProtocolRunInfo>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_run_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_run_info() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::protocol::GetRunInfoRequest, ::minknow_api::protocol::ProtocolRunInfo>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::protocol::GetRunInfoRequest, ::minknow_api::protocol::ProtocolRunInfo>* streamer) {
                       return this->Streamedget_run_info(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_run_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_run_info(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::GetRunInfoRequest* /*request*/, ::minknow_api::protocol::ProtocolRunInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_run_info(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::protocol::GetRunInfoRequest,::minknow_api::protocol::ProtocolRunInfo>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_list_protocol_runs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_list_protocol_runs() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::protocol::ListProtocolRunsRequest, ::minknow_api::protocol::ListProtocolRunsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::protocol::ListProtocolRunsRequest, ::minknow_api::protocol::ListProtocolRunsResponse>* streamer) {
                       return this->Streamedlist_protocol_runs(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_list_protocol_runs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status list_protocol_runs(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::ListProtocolRunsRequest* /*request*/, ::minknow_api::protocol::ListProtocolRunsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedlist_protocol_runs(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::protocol::ListProtocolRunsRequest,::minknow_api::protocol::ListProtocolRunsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_current_protocol_run : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_current_protocol_run() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::protocol::GetCurrentProtocolRunRequest, ::minknow_api::protocol::ProtocolRunInfo>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::protocol::GetCurrentProtocolRunRequest, ::minknow_api::protocol::ProtocolRunInfo>* streamer) {
                       return this->Streamedget_current_protocol_run(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_current_protocol_run() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_current_protocol_run(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::GetCurrentProtocolRunRequest* /*request*/, ::minknow_api::protocol::ProtocolRunInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_current_protocol_run(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::protocol::GetCurrentProtocolRunRequest,::minknow_api::protocol::ProtocolRunInfo>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_list_protocols : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_list_protocols() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::protocol::ListProtocolsRequest, ::minknow_api::protocol::ListProtocolsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::protocol::ListProtocolsRequest, ::minknow_api::protocol::ListProtocolsResponse>* streamer) {
                       return this->Streamedlist_protocols(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_list_protocols() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status list_protocols(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::ListProtocolsRequest* /*request*/, ::minknow_api::protocol::ListProtocolsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedlist_protocols(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::protocol::ListProtocolsRequest,::minknow_api::protocol::ListProtocolsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_context_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_context_info() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::protocol::GetContextInfoRequest, ::minknow_api::protocol::GetContextInfoResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::protocol::GetContextInfoRequest, ::minknow_api::protocol::GetContextInfoResponse>* streamer) {
                       return this->Streamedget_context_info(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_context_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_context_info(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::GetContextInfoRequest* /*request*/, ::minknow_api::protocol::GetContextInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_context_info(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::protocol::GetContextInfoRequest,::minknow_api::protocol::GetContextInfoResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_set_context_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_set_context_info() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::protocol::SetContextInfoRequest, ::minknow_api::protocol::SetContextInfoResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::protocol::SetContextInfoRequest, ::minknow_api::protocol::SetContextInfoResponse>* streamer) {
                       return this->Streamedset_context_info(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_set_context_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status set_context_info(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::SetContextInfoRequest* /*request*/, ::minknow_api::protocol::SetContextInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedset_context_info(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::protocol::SetContextInfoRequest,::minknow_api::protocol::SetContextInfoResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_protocol_purpose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_protocol_purpose() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::protocol::GetProtocolPurposeRequest, ::minknow_api::protocol::GetProtocolPurposeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::protocol::GetProtocolPurposeRequest, ::minknow_api::protocol::GetProtocolPurposeResponse>* streamer) {
                       return this->Streamedget_protocol_purpose(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_protocol_purpose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_protocol_purpose(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::GetProtocolPurposeRequest* /*request*/, ::minknow_api::protocol::GetProtocolPurposeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_protocol_purpose(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::protocol::GetProtocolPurposeRequest,::minknow_api::protocol::GetProtocolPurposeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_set_protocol_purpose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_set_protocol_purpose() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::protocol::SetProtocolPurposeRequest, ::minknow_api::protocol::SetProtocolPurposeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::protocol::SetProtocolPurposeRequest, ::minknow_api::protocol::SetProtocolPurposeResponse>* streamer) {
                       return this->Streamedset_protocol_purpose(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_set_protocol_purpose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status set_protocol_purpose(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::SetProtocolPurposeRequest* /*request*/, ::minknow_api::protocol::SetProtocolPurposeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedset_protocol_purpose(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::protocol::SetProtocolPurposeRequest,::minknow_api::protocol::SetProtocolPurposeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_add_epi2me_workflow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_add_epi2me_workflow() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::protocol::AddEpi2meWorkflowRequest, ::minknow_api::protocol::AddEpi2meWorkflowResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::protocol::AddEpi2meWorkflowRequest, ::minknow_api::protocol::AddEpi2meWorkflowResponse>* streamer) {
                       return this->Streamedadd_epi2me_workflow(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_add_epi2me_workflow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status add_epi2me_workflow(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::AddEpi2meWorkflowRequest* /*request*/, ::minknow_api::protocol::AddEpi2meWorkflowResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedadd_epi2me_workflow(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::protocol::AddEpi2meWorkflowRequest,::minknow_api::protocol::AddEpi2meWorkflowResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_list_protocol_group_ids : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_list_protocol_group_ids() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::protocol::ListProtocolGroupIdsRequest, ::minknow_api::protocol::ListProtocolGroupIdsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::protocol::ListProtocolGroupIdsRequest, ::minknow_api::protocol::ListProtocolGroupIdsResponse>* streamer) {
                       return this->Streamedlist_protocol_group_ids(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_list_protocol_group_ids() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status list_protocol_group_ids(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::ListProtocolGroupIdsRequest* /*request*/, ::minknow_api::protocol::ListProtocolGroupIdsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedlist_protocol_group_ids(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::protocol::ListProtocolGroupIdsRequest,::minknow_api::protocol::ListProtocolGroupIdsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_begin_hardware_check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_begin_hardware_check() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::protocol::BeginHardwareCheckRequest, ::minknow_api::protocol::BeginHardwareCheckResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::protocol::BeginHardwareCheckRequest, ::minknow_api::protocol::BeginHardwareCheckResponse>* streamer) {
                       return this->Streamedbegin_hardware_check(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_begin_hardware_check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status begin_hardware_check(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::BeginHardwareCheckRequest* /*request*/, ::minknow_api::protocol::BeginHardwareCheckResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedbegin_hardware_check(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::protocol::BeginHardwareCheckRequest,::minknow_api::protocol::BeginHardwareCheckResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_begin_platform_qc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_begin_platform_qc() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::protocol::BeginPlatformQcRequest, ::minknow_api::protocol::BeginPlatformQcResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::protocol::BeginPlatformQcRequest, ::minknow_api::protocol::BeginPlatformQcResponse>* streamer) {
                       return this->Streamedbegin_platform_qc(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_begin_platform_qc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status begin_platform_qc(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::BeginPlatformQcRequest* /*request*/, ::minknow_api::protocol::BeginPlatformQcResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedbegin_platform_qc(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::protocol::BeginPlatformQcRequest,::minknow_api::protocol::BeginPlatformQcResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_set_platform_qc_result : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_set_platform_qc_result() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::protocol::SetPlatformQcResultRequest, ::minknow_api::protocol::SetPlatformQcResultResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::protocol::SetPlatformQcResultRequest, ::minknow_api::protocol::SetPlatformQcResultResponse>* streamer) {
                       return this->Streamedset_platform_qc_result(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_set_platform_qc_result() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status set_platform_qc_result(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::SetPlatformQcResultRequest* /*request*/, ::minknow_api::protocol::SetPlatformQcResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedset_platform_qc_result(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::protocol::SetPlatformQcResultRequest,::minknow_api::protocol::SetPlatformQcResultResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_list_settings_for_protocol : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_list_settings_for_protocol() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::protocol::ListSettingsForProtocolRequest, ::minknow_api::protocol::ListSettingsForProtocolResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::protocol::ListSettingsForProtocolRequest, ::minknow_api::protocol::ListSettingsForProtocolResponse>* streamer) {
                       return this->Streamedlist_settings_for_protocol(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_list_settings_for_protocol() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status list_settings_for_protocol(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::ListSettingsForProtocolRequest* /*request*/, ::minknow_api::protocol::ListSettingsForProtocolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedlist_settings_for_protocol(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::protocol::ListSettingsForProtocolRequest,::minknow_api::protocol::ListSettingsForProtocolResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_associate_post_processing_analysis_for_protocol : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_associate_post_processing_analysis_for_protocol() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::protocol::AssociatePostProcessingAnalysisRequest, ::minknow_api::protocol::AssociatePostProcessingAnalysisResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::protocol::AssociatePostProcessingAnalysisRequest, ::minknow_api::protocol::AssociatePostProcessingAnalysisResponse>* streamer) {
                       return this->Streamedassociate_post_processing_analysis_for_protocol(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_associate_post_processing_analysis_for_protocol() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status associate_post_processing_analysis_for_protocol(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::AssociatePostProcessingAnalysisRequest* /*request*/, ::minknow_api::protocol::AssociatePostProcessingAnalysisResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedassociate_post_processing_analysis_for_protocol(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::protocol::AssociatePostProcessingAnalysisRequest,::minknow_api::protocol::AssociatePostProcessingAnalysisResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_clear_protocol_history_data : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_clear_protocol_history_data() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::protocol::ClearProtocolHistoryDataRequest, ::minknow_api::protocol::ClearProtocolHistoryDataResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::protocol::ClearProtocolHistoryDataRequest, ::minknow_api::protocol::ClearProtocolHistoryDataResponse>* streamer) {
                       return this->Streamedclear_protocol_history_data(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_clear_protocol_history_data() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status clear_protocol_history_data(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::ClearProtocolHistoryDataRequest* /*request*/, ::minknow_api::protocol::ClearProtocolHistoryDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedclear_protocol_history_data(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::protocol::ClearProtocolHistoryDataRequest,::minknow_api::protocol::ClearProtocolHistoryDataResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_start_protocol<WithStreamedUnaryMethod_stop_protocol<WithStreamedUnaryMethod_pause_protocol<WithStreamedUnaryMethod_resume_protocol<WithStreamedUnaryMethod_trigger_mux_scan<WithStreamedUnaryMethod_wait_for_finished<WithStreamedUnaryMethod_get_run_info<WithStreamedUnaryMethod_list_protocol_runs<WithStreamedUnaryMethod_get_current_protocol_run<WithStreamedUnaryMethod_list_protocols<WithStreamedUnaryMethod_get_context_info<WithStreamedUnaryMethod_set_context_info<WithStreamedUnaryMethod_get_protocol_purpose<WithStreamedUnaryMethod_set_protocol_purpose<WithStreamedUnaryMethod_add_epi2me_workflow<WithStreamedUnaryMethod_list_protocol_group_ids<WithStreamedUnaryMethod_begin_hardware_check<WithStreamedUnaryMethod_begin_platform_qc<WithStreamedUnaryMethod_set_platform_qc_result<WithStreamedUnaryMethod_list_settings_for_protocol<WithStreamedUnaryMethod_associate_post_processing_analysis_for_protocol<WithStreamedUnaryMethod_clear_protocol_history_data<Service > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_watch_current_protocol_run : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_watch_current_protocol_run() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::minknow_api::protocol::WatchCurrentProtocolRunRequest, ::minknow_api::protocol::ProtocolRunInfo>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::minknow_api::protocol::WatchCurrentProtocolRunRequest, ::minknow_api::protocol::ProtocolRunInfo>* streamer) {
                       return this->Streamedwatch_current_protocol_run(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_watch_current_protocol_run() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status watch_current_protocol_run(::grpc::ServerContext* /*context*/, const ::minknow_api::protocol::WatchCurrentProtocolRunRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::protocol::ProtocolRunInfo>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status Streamedwatch_current_protocol_run(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::minknow_api::protocol::WatchCurrentProtocolRunRequest,::minknow_api::protocol::ProtocolRunInfo>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_watch_current_protocol_run<Service > SplitStreamedService;
  typedef WithStreamedUnaryMethod_start_protocol<WithStreamedUnaryMethod_stop_protocol<WithStreamedUnaryMethod_pause_protocol<WithStreamedUnaryMethod_resume_protocol<WithStreamedUnaryMethod_trigger_mux_scan<WithStreamedUnaryMethod_wait_for_finished<WithStreamedUnaryMethod_get_run_info<WithStreamedUnaryMethod_list_protocol_runs<WithStreamedUnaryMethod_get_current_protocol_run<WithSplitStreamingMethod_watch_current_protocol_run<WithStreamedUnaryMethod_list_protocols<WithStreamedUnaryMethod_get_context_info<WithStreamedUnaryMethod_set_context_info<WithStreamedUnaryMethod_get_protocol_purpose<WithStreamedUnaryMethod_set_protocol_purpose<WithStreamedUnaryMethod_add_epi2me_workflow<WithStreamedUnaryMethod_list_protocol_group_ids<WithStreamedUnaryMethod_begin_hardware_check<WithStreamedUnaryMethod_begin_platform_qc<WithStreamedUnaryMethod_set_platform_qc_result<WithStreamedUnaryMethod_list_settings_for_protocol<WithStreamedUnaryMethod_associate_post_processing_analysis_for_protocol<WithStreamedUnaryMethod_clear_protocol_history_data<Service > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace protocol
}  // namespace minknow_api


#endif  // GRPC_minknow_5fapi_2fprotocol_2eproto__INCLUDED
