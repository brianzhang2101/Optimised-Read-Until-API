// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: minknow_api/device.proto
#ifndef GRPC_minknow_5fapi_2fdevice_2eproto__INCLUDED
#define GRPC_minknow_5fapi_2fdevice_2eproto__INCLUDED

#include "minknow_api/device.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace minknow_api {
namespace device {

class DeviceService final {
 public:
  static constexpr char const* service_full_name() {
    return "minknow_api.device.DeviceService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Get information about the device this MinKNOW instance was started for.
    //
    // In normal circumstances (ie: when using the manager service), a new MinKNOW instance
    // is started for each available device. This call provides information about this device.
    //
    // The information returned by this call will not change (providing the MinKNOW instance
    // was started by the manager service).
    virtual ::grpc::Status get_device_info(::grpc::ClientContext* context, const ::minknow_api::device::GetDeviceInfoRequest& request, ::minknow_api::device::GetDeviceInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetDeviceInfoResponse>> Asyncget_device_info(::grpc::ClientContext* context, const ::minknow_api::device::GetDeviceInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetDeviceInfoResponse>>(Asyncget_device_infoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetDeviceInfoResponse>> PrepareAsyncget_device_info(::grpc::ClientContext* context, const ::minknow_api::device::GetDeviceInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetDeviceInfoResponse>>(PrepareAsyncget_device_infoRaw(context, request, cq));
    }
    // Get information about the current device state.
    //
    // Information in this call may change as the device is used with MinKNOW, for example,
    // by unplugging or plugging in the device.
    //
    // It includes information about whether the hardware is actually attached (in the case of
    // MinIONs, which can be unplugged), as well as what types of flow cells can be inserted (which
    // may be affected by flow cell adapters).
    //
    // Since 1.12
    virtual ::grpc::Status get_device_state(::grpc::ClientContext* context, const ::minknow_api::device::GetDeviceStateRequest& request, ::minknow_api::device::GetDeviceStateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetDeviceStateResponse>> Asyncget_device_state(::grpc::ClientContext* context, const ::minknow_api::device::GetDeviceStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetDeviceStateResponse>>(Asyncget_device_stateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetDeviceStateResponse>> PrepareAsyncget_device_state(::grpc::ClientContext* context, const ::minknow_api::device::GetDeviceStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetDeviceStateResponse>>(PrepareAsyncget_device_stateRaw(context, request, cq));
    }
    // Streaming version of get_device_state
    //
    // Since 1.13
    std::unique_ptr< ::grpc::ClientReaderInterface< ::minknow_api::device::GetDeviceStateResponse>> stream_device_state(::grpc::ClientContext* context, const ::minknow_api::device::StreamDeviceStateRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::minknow_api::device::GetDeviceStateResponse>>(stream_device_stateRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::device::GetDeviceStateResponse>> Asyncstream_device_state(::grpc::ClientContext* context, const ::minknow_api::device::StreamDeviceStateRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::device::GetDeviceStateResponse>>(Asyncstream_device_stateRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::device::GetDeviceStateResponse>> PrepareAsyncstream_device_state(::grpc::ClientContext* context, const ::minknow_api::device::StreamDeviceStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::device::GetDeviceStateResponse>>(PrepareAsyncstream_device_stateRaw(context, request, cq));
    }
    // Get information about the flow cell (if any).
    //
    // This provides information about the flow_cell attached to the device (described by
    // get_device_info()), if any.
    virtual ::grpc::Status get_flow_cell_info(::grpc::ClientContext* context, const ::minknow_api::device::GetFlowCellInfoRequest& request, ::minknow_api::device::GetFlowCellInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetFlowCellInfoResponse>> Asyncget_flow_cell_info(::grpc::ClientContext* context, const ::minknow_api::device::GetFlowCellInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetFlowCellInfoResponse>>(Asyncget_flow_cell_infoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetFlowCellInfoResponse>> PrepareAsyncget_flow_cell_info(::grpc::ClientContext* context, const ::minknow_api::device::GetFlowCellInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetFlowCellInfoResponse>>(PrepareAsyncget_flow_cell_infoRaw(context, request, cq));
    }
    // Streaming version of get_flow_cell_info
    //
    // Since 1.13
    std::unique_ptr< ::grpc::ClientReaderInterface< ::minknow_api::device::GetFlowCellInfoResponse>> stream_flow_cell_info(::grpc::ClientContext* context, const ::minknow_api::device::StreamFlowCellInfoRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::minknow_api::device::GetFlowCellInfoResponse>>(stream_flow_cell_infoRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::device::GetFlowCellInfoResponse>> Asyncstream_flow_cell_info(::grpc::ClientContext* context, const ::minknow_api::device::StreamFlowCellInfoRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::device::GetFlowCellInfoResponse>>(Asyncstream_flow_cell_infoRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::device::GetFlowCellInfoResponse>> PrepareAsyncstream_flow_cell_info(::grpc::ClientContext* context, const ::minknow_api::device::StreamFlowCellInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::device::GetFlowCellInfoResponse>>(PrepareAsyncstream_flow_cell_infoRaw(context, request, cq));
    }
    // Set the user specified flow cell id.
    //
    // This changes the user specified flow cell id.
    // MinKNOW will use this id in place of the id read from the eeprom, if no eeprom data
    // is available.
    //
    // This data is reset when the flow cell is disconnected.
    //
    // Since 1.12
    virtual ::grpc::Status set_user_specified_flow_cell_id(::grpc::ClientContext* context, const ::minknow_api::device::SetUserSpecifiedFlowCellIdRequest& request, ::minknow_api::device::SetUserSpecifiedFlowCellIdResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetUserSpecifiedFlowCellIdResponse>> Asyncset_user_specified_flow_cell_id(::grpc::ClientContext* context, const ::minknow_api::device::SetUserSpecifiedFlowCellIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetUserSpecifiedFlowCellIdResponse>>(Asyncset_user_specified_flow_cell_idRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetUserSpecifiedFlowCellIdResponse>> PrepareAsyncset_user_specified_flow_cell_id(::grpc::ClientContext* context, const ::minknow_api::device::SetUserSpecifiedFlowCellIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetUserSpecifiedFlowCellIdResponse>>(PrepareAsyncset_user_specified_flow_cell_idRaw(context, request, cq));
    }
    // Set the user specified product code.
    //
    // This changes the user specified product code.
    //
    // MinKNOW does not use the product code, it is intended for use in MinKNOW's clients.
    //
    // This data is reset when the flow cell is disconnected.
    //
    // Since 1.12
    virtual ::grpc::Status set_user_specified_product_code(::grpc::ClientContext* context, const ::minknow_api::device::SetUserSpecifiedProductCodeRequest& request, ::minknow_api::device::SetUserSpecifiedProductCodeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetUserSpecifiedProductCodeResponse>> Asyncset_user_specified_product_code(::grpc::ClientContext* context, const ::minknow_api::device::SetUserSpecifiedProductCodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetUserSpecifiedProductCodeResponse>>(Asyncset_user_specified_product_codeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetUserSpecifiedProductCodeResponse>> PrepareAsyncset_user_specified_product_code(::grpc::ClientContext* context, const ::minknow_api::device::SetUserSpecifiedProductCodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetUserSpecifiedProductCodeResponse>>(PrepareAsyncset_user_specified_product_codeRaw(context, request, cq));
    }
    // Get information about the channel layout
    //
    // Since 1.14
    virtual ::grpc::Status get_channels_layout(::grpc::ClientContext* context, const ::minknow_api::device::GetChannelsLayoutRequest& request, ::minknow_api::device::GetChannelsLayoutResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetChannelsLayoutResponse>> Asyncget_channels_layout(::grpc::ClientContext* context, const ::minknow_api::device::GetChannelsLayoutRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetChannelsLayoutResponse>>(Asyncget_channels_layoutRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetChannelsLayoutResponse>> PrepareAsyncget_channels_layout(::grpc::ClientContext* context, const ::minknow_api::device::GetChannelsLayoutRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetChannelsLayoutResponse>>(PrepareAsyncget_channels_layoutRaw(context, request, cq));
    }
    // Reset all settings associate with the current device.
    //
    // This call will initialise all settings to their default state, ie the same as when MinKNOW boots.
    virtual ::grpc::Status reset_device_settings(::grpc::ClientContext* context, const ::minknow_api::device::ResetDeviceSettingsRequest& request, ::minknow_api::device::ResetDeviceSettingsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::ResetDeviceSettingsResponse>> Asyncreset_device_settings(::grpc::ClientContext* context, const ::minknow_api::device::ResetDeviceSettingsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::ResetDeviceSettingsResponse>>(Asyncreset_device_settingsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::ResetDeviceSettingsResponse>> PrepareAsyncreset_device_settings(::grpc::ClientContext* context, const ::minknow_api::device::ResetDeviceSettingsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::ResetDeviceSettingsResponse>>(PrepareAsyncreset_device_settingsRaw(context, request, cq));
    }
    // Set the calibration measurements to be used by MinKNOW.
    //
    // Calibration describes how to convert from the raw ADC (analog-to-digital converter) values
    // from the device into picoamps (pA).
    //
    // Note that calibration depends on the device, flow cell and some of the device settings
    // (including sampling frequency and the capacitance used in the integratation circuit). If
    // any of these are changed, the calibration will no longer be used. Instead, a previously-saved
    // calibration (for that combination of flow cell and settings) might be used, or the identity
    // calibration might be used.
    //
    // On a MinION, the settings that a calibration depends on are sampling frequency and
    // integration capacitor.
    virtual ::grpc::Status set_calibration(::grpc::ClientContext* context, const ::minknow_api::device::SetCalibrationRequest& request, ::minknow_api::device::SetCalibrationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetCalibrationResponse>> Asyncset_calibration(::grpc::ClientContext* context, const ::minknow_api::device::SetCalibrationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetCalibrationResponse>>(Asyncset_calibrationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetCalibrationResponse>> PrepareAsyncset_calibration(::grpc::ClientContext* context, const ::minknow_api::device::SetCalibrationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetCalibrationResponse>>(PrepareAsyncset_calibrationRaw(context, request, cq));
    }
    // Clear the current calibration.
    //
    // This is the same as setting the calibration to be the identity function (setting all offsets
    // to 0, and all pA ranges to the digitisation value).
    virtual ::grpc::Status clear_calibration(::grpc::ClientContext* context, const ::minknow_api::device::ClearCalibrationRequest& request, ::minknow_api::device::ClearCalibrationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::ClearCalibrationResponse>> Asyncclear_calibration(::grpc::ClientContext* context, const ::minknow_api::device::ClearCalibrationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::ClearCalibrationResponse>>(Asyncclear_calibrationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::ClearCalibrationResponse>> PrepareAsyncclear_calibration(::grpc::ClientContext* context, const ::minknow_api::device::ClearCalibrationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::ClearCalibrationResponse>>(PrepareAsyncclear_calibrationRaw(context, request, cq));
    }
    // The calibration measurements being used by MinKNOW.
    //
    // Calibration describes how to convert from the raw ADC (analog-to-digital converter) values
    // from the device into picoamps (pA).
    //
    // To get a pA value from an ADC value the following function is applied::
    //
    //      pA_current = (adc_current + offset) / (digitisation / pA_range)
    //
    // The digitisation is the range of possible ADC values. It is the same for all channels.
    //
    // If there is no calibration (including if it was cleared with ``clear_calibration()`` or
    // invalidated because of device settings changes), this will return the identity calibration:
    // all offsets will be 0, and the pA ranges will be the same as the digitisation.
    virtual ::grpc::Status get_calibration(::grpc::ClientContext* context, const ::minknow_api::device::GetCalibrationRequest& request, ::minknow_api::device::GetCalibrationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetCalibrationResponse>> Asyncget_calibration(::grpc::ClientContext* context, const ::minknow_api::device::GetCalibrationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetCalibrationResponse>>(Asyncget_calibrationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetCalibrationResponse>> PrepareAsyncget_calibration(::grpc::ClientContext* context, const ::minknow_api::device::GetCalibrationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetCalibrationResponse>>(PrepareAsyncget_calibrationRaw(context, request, cq));
    }
    // If the device is capable (see GetDeviceInfoResponse.temperature_controllable)
    // then this sets the minimum and maximum temperatures of the flow-cell.
    virtual ::grpc::Status set_temperature(::grpc::ClientContext* context, const ::minknow_api::device::SetTemperatureRequest& request, ::minknow_api::device::SetTemperatureResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetTemperatureResponse>> Asyncset_temperature(::grpc::ClientContext* context, const ::minknow_api::device::SetTemperatureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetTemperatureResponse>>(Asyncset_temperatureRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetTemperatureResponse>> PrepareAsyncset_temperature(::grpc::ClientContext* context, const ::minknow_api::device::SetTemperatureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetTemperatureResponse>>(PrepareAsyncset_temperatureRaw(context, request, cq));
    }
    // Get the current temperature of the device.
    //
    // Since 1.11
    virtual ::grpc::Status get_temperature(::grpc::ClientContext* context, const ::minknow_api::device::GetTemperatureRequest& request, ::minknow_api::device::GetTemperatureResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetTemperatureResponse>> Asyncget_temperature(::grpc::ClientContext* context, const ::minknow_api::device::GetTemperatureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetTemperatureResponse>>(Asyncget_temperatureRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetTemperatureResponse>> PrepareAsyncget_temperature(::grpc::ClientContext* context, const ::minknow_api::device::GetTemperatureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetTemperatureResponse>>(PrepareAsyncget_temperatureRaw(context, request, cq));
    }
    // Stream the current temperature of the device.
    //
    // Since 4.3
    std::unique_ptr< ::grpc::ClientReaderInterface< ::minknow_api::device::GetTemperatureResponse>> stream_temperature(::grpc::ClientContext* context, const ::minknow_api::device::StreamTemperatureRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::minknow_api::device::GetTemperatureResponse>>(stream_temperatureRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::device::GetTemperatureResponse>> Asyncstream_temperature(::grpc::ClientContext* context, const ::minknow_api::device::StreamTemperatureRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::device::GetTemperatureResponse>>(Asyncstream_temperatureRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::device::GetTemperatureResponse>> PrepareAsyncstream_temperature(::grpc::ClientContext* context, const ::minknow_api::device::StreamTemperatureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::device::GetTemperatureResponse>>(PrepareAsyncstream_temperatureRaw(context, request, cq));
    }
    // Triggers an unblock for a list of channels for a given duration (Please see UnblockRequest).
    // It will start an unblock for every channel received as a parameter, then this RPC returns.
    // After the timeout expires (the duration in seconds given in the request), the return from
    // unblock is automatically triggered, which resets the channel configuration (mux) to the
    // value preceding the unblock.
    //
    // Notes!!
    //
    // During the unblock the user should NOT do any mux changes, as the unblock will be interrupted.
    // On Promethion this would be even more complicated, as an unblock would normally restore
    // hardware saturation. If an unblock is interrupted it will not restore the state to the original
    // one.
    //
    // The user should NOT change the overload mode during an unblock - this will confuse the return from
    // unblock, which tries to reset the overload mode to the state preceeding the unblock.
    //
    // The unblock can fail if the channel is not in a valid well state (this means a channel needs to be
    // in one of pore1-4, not test current, regen pore or unblock). If a mux is not valid, the unblock grpc
    // will try to continue for the rest of the channels, ignoring the one with the wrong mux.
    virtual ::grpc::Status unblock(::grpc::ClientContext* context, const ::minknow_api::device::UnblockRequest& request, ::minknow_api::device::UnblockResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::UnblockResponse>> Asyncunblock(::grpc::ClientContext* context, const ::minknow_api::device::UnblockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::UnblockResponse>>(AsyncunblockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::UnblockResponse>> PrepareAsyncunblock(::grpc::ClientContext* context, const ::minknow_api::device::UnblockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::UnblockResponse>>(PrepareAsyncunblockRaw(context, request, cq));
    }
    // Cancel in progress unblocks.
    //
    // Any unblocks registered with `device.unblock` will be stopped before this command returns.
    // Unblocks are stopped by applying any actions required to return from unblock (mux changes, or hardware configuration).
    //
    // Since 1.15
    virtual ::grpc::Status cancel_unblocks(::grpc::ClientContext* context, const ::minknow_api::device::CancelUnblocksRequest& request, ::minknow_api::device::CancelUnblocksResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::CancelUnblocksResponse>> Asynccancel_unblocks(::grpc::ClientContext* context, const ::minknow_api::device::CancelUnblocksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::CancelUnblocksResponse>>(Asynccancel_unblocksRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::CancelUnblocksResponse>> PrepareAsynccancel_unblocks(::grpc::ClientContext* context, const ::minknow_api::device::CancelUnblocksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::CancelUnblocksResponse>>(PrepareAsynccancel_unblocksRaw(context, request, cq));
    }
    // Get the channel configuration for any number of channels
    //
    // The maximum addressable channel will depend on the device. Currently this will be 512 on a MinION/GridION
    // and 3000 on a PromethION
    virtual ::grpc::Status get_channel_configuration(::grpc::ClientContext* context, const ::minknow_api::device::GetChannelConfigurationRequest& request, ::minknow_api::device::GetChannelConfigurationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetChannelConfigurationResponse>> Asyncget_channel_configuration(::grpc::ClientContext* context, const ::minknow_api::device::GetChannelConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetChannelConfigurationResponse>>(Asyncget_channel_configurationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetChannelConfigurationResponse>> PrepareAsyncget_channel_configuration(::grpc::ClientContext* context, const ::minknow_api::device::GetChannelConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetChannelConfigurationResponse>>(PrepareAsyncget_channel_configurationRaw(context, request, cq));
    }
    // Set the channel configuration for any number of channels
    //
    // The maximum addressable channel will depend on the device. Currently this will be 512 on a MinION/GridION
    // and 3000 on a PromethION.
    virtual ::grpc::Status set_channel_configuration(::grpc::ClientContext* context, const ::minknow_api::device::SetChannelConfigurationRequest& request, ::minknow_api::device::SetChannelConfigurationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetChannelConfigurationResponse>> Asyncset_channel_configuration(::grpc::ClientContext* context, const ::minknow_api::device::SetChannelConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetChannelConfigurationResponse>>(Asyncset_channel_configurationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetChannelConfigurationResponse>> PrepareAsyncset_channel_configuration(::grpc::ClientContext* context, const ::minknow_api::device::SetChannelConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetChannelConfigurationResponse>>(PrepareAsyncset_channel_configurationRaw(context, request, cq));
    }
    virtual ::grpc::Status set_channel_configuration_all(::grpc::ClientContext* context, const ::minknow_api::device::SetChannelConfigurationAllRequest& request, ::minknow_api::device::SetChannelConfigurationAllResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetChannelConfigurationAllResponse>> Asyncset_channel_configuration_all(::grpc::ClientContext* context, const ::minknow_api::device::SetChannelConfigurationAllRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetChannelConfigurationAllResponse>>(Asyncset_channel_configuration_allRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetChannelConfigurationAllResponse>> PrepareAsyncset_channel_configuration_all(::grpc::ClientContext* context, const ::minknow_api::device::SetChannelConfigurationAllRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetChannelConfigurationAllResponse>>(PrepareAsyncset_channel_configuration_allRaw(context, request, cq));
    }
    // Set the saturation control configuration.
    //
    // The request is immediately sent to the data acquisition module, and applied. All settings can be changed
    // whilst the experiment is running.
    //
    // If any keys are not specified when this method is called (see the message for specific optional parameters),
    // the previously applied parameters are kept; initially, when this method has never been called, defaults from the
    // application config are used.
    //
    // note: calling this method resets anu in-progress saturations when it is called, causing them to need to start
    // saturation counts again, this may mean any saturations may take longer to occur.
    virtual ::grpc::Status set_saturation_config(::grpc::ClientContext* context, const ::minknow_api::device::SetSaturationConfigRequest& request, ::minknow_api::device::SetSaturationConfigResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetSaturationConfigResponse>> Asyncset_saturation_config(::grpc::ClientContext* context, const ::minknow_api::device::SetSaturationConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetSaturationConfigResponse>>(Asyncset_saturation_configRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetSaturationConfigResponse>> PrepareAsyncset_saturation_config(::grpc::ClientContext* context, const ::minknow_api::device::SetSaturationConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetSaturationConfigResponse>>(PrepareAsyncset_saturation_configRaw(context, request, cq));
    }
    // Get the saturation control configuration.
    //
    // The default configuration is specifed by the MinKNOW application configuration, the command returns the most
    // recently applied saturation config.
    virtual ::grpc::Status get_saturation_config(::grpc::ClientContext* context, const ::minknow_api::device::GetSaturationConfigRequest& request, ::minknow_api::device::GetSaturationConfigResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetSaturationConfigResponse>> Asyncget_saturation_config(::grpc::ClientContext* context, const ::minknow_api::device::GetSaturationConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetSaturationConfigResponse>>(Asyncget_saturation_configRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetSaturationConfigResponse>> PrepareAsyncget_saturation_config(::grpc::ClientContext* context, const ::minknow_api::device::GetSaturationConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetSaturationConfigResponse>>(PrepareAsyncget_saturation_configRaw(context, request, cq));
    }
    // Get the sample rate of the device
    //
    // Please refer to MinionDeviceService and PromethionDeviceService for the expected
    // return value for a minion and promethion respectively
    virtual ::grpc::Status get_sample_rate(::grpc::ClientContext* context, const ::minknow_api::device::GetSampleRateRequest& request, ::minknow_api::device::GetSampleRateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetSampleRateResponse>> Asyncget_sample_rate(::grpc::ClientContext* context, const ::minknow_api::device::GetSampleRateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetSampleRateResponse>>(Asyncget_sample_rateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetSampleRateResponse>> PrepareAsyncget_sample_rate(::grpc::ClientContext* context, const ::minknow_api::device::GetSampleRateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetSampleRateResponse>>(PrepareAsyncget_sample_rateRaw(context, request, cq));
    }
    // Set the sample rate of the device, and returns the actual value set on the device
    //
    // Please refer to MinionDeviceService and PromethionDeviceService to see
    // how the value set here will be used to determine the real sample rate for a
    // minion and promethion respectively
    //
    // Trying to set the sample rate during an acquisition period will result in an error
    virtual ::grpc::Status set_sample_rate(::grpc::ClientContext* context, const ::minknow_api::device::SetSampleRateRequest& request, ::minknow_api::device::SetSampleRateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetSampleRateResponse>> Asyncset_sample_rate(::grpc::ClientContext* context, const ::minknow_api::device::SetSampleRateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetSampleRateResponse>>(Asyncset_sample_rateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetSampleRateResponse>> PrepareAsyncset_sample_rate(::grpc::ClientContext* context, const ::minknow_api::device::SetSampleRateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetSampleRateResponse>>(PrepareAsyncset_sample_rateRaw(context, request, cq));
    }
    virtual ::grpc::Status get_bias_voltage(::grpc::ClientContext* context, const ::minknow_api::device::GetBiasVoltageRequest& request, ::minknow_api::device::GetBiasVoltageResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetBiasVoltageResponse>> Asyncget_bias_voltage(::grpc::ClientContext* context, const ::minknow_api::device::GetBiasVoltageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetBiasVoltageResponse>>(Asyncget_bias_voltageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetBiasVoltageResponse>> PrepareAsyncget_bias_voltage(::grpc::ClientContext* context, const ::minknow_api::device::GetBiasVoltageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetBiasVoltageResponse>>(PrepareAsyncget_bias_voltageRaw(context, request, cq));
    }
    virtual ::grpc::Status set_bias_voltage(::grpc::ClientContext* context, const ::minknow_api::device::SetBiasVoltageRequest& request, ::minknow_api::device::SetBiasVoltageResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetBiasVoltageResponse>> Asyncset_bias_voltage(::grpc::ClientContext* context, const ::minknow_api::device::SetBiasVoltageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetBiasVoltageResponse>>(Asyncset_bias_voltageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetBiasVoltageResponse>> PrepareAsyncset_bias_voltage(::grpc::ClientContext* context, const ::minknow_api::device::SetBiasVoltageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetBiasVoltageResponse>>(PrepareAsyncset_bias_voltageRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // Get information about the device this MinKNOW instance was started for.
      //
      // In normal circumstances (ie: when using the manager service), a new MinKNOW instance
      // is started for each available device. This call provides information about this device.
      //
      // The information returned by this call will not change (providing the MinKNOW instance
      // was started by the manager service).
      virtual void get_device_info(::grpc::ClientContext* context, const ::minknow_api::device::GetDeviceInfoRequest* request, ::minknow_api::device::GetDeviceInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_device_info(::grpc::ClientContext* context, const ::minknow_api::device::GetDeviceInfoRequest* request, ::minknow_api::device::GetDeviceInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Get information about the current device state.
      //
      // Information in this call may change as the device is used with MinKNOW, for example,
      // by unplugging or plugging in the device.
      //
      // It includes information about whether the hardware is actually attached (in the case of
      // MinIONs, which can be unplugged), as well as what types of flow cells can be inserted (which
      // may be affected by flow cell adapters).
      //
      // Since 1.12
      virtual void get_device_state(::grpc::ClientContext* context, const ::minknow_api::device::GetDeviceStateRequest* request, ::minknow_api::device::GetDeviceStateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_device_state(::grpc::ClientContext* context, const ::minknow_api::device::GetDeviceStateRequest* request, ::minknow_api::device::GetDeviceStateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Streaming version of get_device_state
      //
      // Since 1.13
      virtual void stream_device_state(::grpc::ClientContext* context, const ::minknow_api::device::StreamDeviceStateRequest* request, ::grpc::ClientReadReactor< ::minknow_api::device::GetDeviceStateResponse>* reactor) = 0;
      // Get information about the flow cell (if any).
      //
      // This provides information about the flow_cell attached to the device (described by
      // get_device_info()), if any.
      virtual void get_flow_cell_info(::grpc::ClientContext* context, const ::minknow_api::device::GetFlowCellInfoRequest* request, ::minknow_api::device::GetFlowCellInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_flow_cell_info(::grpc::ClientContext* context, const ::minknow_api::device::GetFlowCellInfoRequest* request, ::minknow_api::device::GetFlowCellInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Streaming version of get_flow_cell_info
      //
      // Since 1.13
      virtual void stream_flow_cell_info(::grpc::ClientContext* context, const ::minknow_api::device::StreamFlowCellInfoRequest* request, ::grpc::ClientReadReactor< ::minknow_api::device::GetFlowCellInfoResponse>* reactor) = 0;
      // Set the user specified flow cell id.
      //
      // This changes the user specified flow cell id.
      // MinKNOW will use this id in place of the id read from the eeprom, if no eeprom data
      // is available.
      //
      // This data is reset when the flow cell is disconnected.
      //
      // Since 1.12
      virtual void set_user_specified_flow_cell_id(::grpc::ClientContext* context, const ::minknow_api::device::SetUserSpecifiedFlowCellIdRequest* request, ::minknow_api::device::SetUserSpecifiedFlowCellIdResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void set_user_specified_flow_cell_id(::grpc::ClientContext* context, const ::minknow_api::device::SetUserSpecifiedFlowCellIdRequest* request, ::minknow_api::device::SetUserSpecifiedFlowCellIdResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Set the user specified product code.
      //
      // This changes the user specified product code.
      //
      // MinKNOW does not use the product code, it is intended for use in MinKNOW's clients.
      //
      // This data is reset when the flow cell is disconnected.
      //
      // Since 1.12
      virtual void set_user_specified_product_code(::grpc::ClientContext* context, const ::minknow_api::device::SetUserSpecifiedProductCodeRequest* request, ::minknow_api::device::SetUserSpecifiedProductCodeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void set_user_specified_product_code(::grpc::ClientContext* context, const ::minknow_api::device::SetUserSpecifiedProductCodeRequest* request, ::minknow_api::device::SetUserSpecifiedProductCodeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Get information about the channel layout
      //
      // Since 1.14
      virtual void get_channels_layout(::grpc::ClientContext* context, const ::minknow_api::device::GetChannelsLayoutRequest* request, ::minknow_api::device::GetChannelsLayoutResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_channels_layout(::grpc::ClientContext* context, const ::minknow_api::device::GetChannelsLayoutRequest* request, ::minknow_api::device::GetChannelsLayoutResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Reset all settings associate with the current device.
      //
      // This call will initialise all settings to their default state, ie the same as when MinKNOW boots.
      virtual void reset_device_settings(::grpc::ClientContext* context, const ::minknow_api::device::ResetDeviceSettingsRequest* request, ::minknow_api::device::ResetDeviceSettingsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void reset_device_settings(::grpc::ClientContext* context, const ::minknow_api::device::ResetDeviceSettingsRequest* request, ::minknow_api::device::ResetDeviceSettingsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Set the calibration measurements to be used by MinKNOW.
      //
      // Calibration describes how to convert from the raw ADC (analog-to-digital converter) values
      // from the device into picoamps (pA).
      //
      // Note that calibration depends on the device, flow cell and some of the device settings
      // (including sampling frequency and the capacitance used in the integratation circuit). If
      // any of these are changed, the calibration will no longer be used. Instead, a previously-saved
      // calibration (for that combination of flow cell and settings) might be used, or the identity
      // calibration might be used.
      //
      // On a MinION, the settings that a calibration depends on are sampling frequency and
      // integration capacitor.
      virtual void set_calibration(::grpc::ClientContext* context, const ::minknow_api::device::SetCalibrationRequest* request, ::minknow_api::device::SetCalibrationResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void set_calibration(::grpc::ClientContext* context, const ::minknow_api::device::SetCalibrationRequest* request, ::minknow_api::device::SetCalibrationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Clear the current calibration.
      //
      // This is the same as setting the calibration to be the identity function (setting all offsets
      // to 0, and all pA ranges to the digitisation value).
      virtual void clear_calibration(::grpc::ClientContext* context, const ::minknow_api::device::ClearCalibrationRequest* request, ::minknow_api::device::ClearCalibrationResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void clear_calibration(::grpc::ClientContext* context, const ::minknow_api::device::ClearCalibrationRequest* request, ::minknow_api::device::ClearCalibrationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // The calibration measurements being used by MinKNOW.
      //
      // Calibration describes how to convert from the raw ADC (analog-to-digital converter) values
      // from the device into picoamps (pA).
      //
      // To get a pA value from an ADC value the following function is applied::
      //
      //      pA_current = (adc_current + offset) / (digitisation / pA_range)
      //
      // The digitisation is the range of possible ADC values. It is the same for all channels.
      //
      // If there is no calibration (including if it was cleared with ``clear_calibration()`` or
      // invalidated because of device settings changes), this will return the identity calibration:
      // all offsets will be 0, and the pA ranges will be the same as the digitisation.
      virtual void get_calibration(::grpc::ClientContext* context, const ::minknow_api::device::GetCalibrationRequest* request, ::minknow_api::device::GetCalibrationResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_calibration(::grpc::ClientContext* context, const ::minknow_api::device::GetCalibrationRequest* request, ::minknow_api::device::GetCalibrationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // If the device is capable (see GetDeviceInfoResponse.temperature_controllable)
      // then this sets the minimum and maximum temperatures of the flow-cell.
      virtual void set_temperature(::grpc::ClientContext* context, const ::minknow_api::device::SetTemperatureRequest* request, ::minknow_api::device::SetTemperatureResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void set_temperature(::grpc::ClientContext* context, const ::minknow_api::device::SetTemperatureRequest* request, ::minknow_api::device::SetTemperatureResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Get the current temperature of the device.
      //
      // Since 1.11
      virtual void get_temperature(::grpc::ClientContext* context, const ::minknow_api::device::GetTemperatureRequest* request, ::minknow_api::device::GetTemperatureResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_temperature(::grpc::ClientContext* context, const ::minknow_api::device::GetTemperatureRequest* request, ::minknow_api::device::GetTemperatureResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Stream the current temperature of the device.
      //
      // Since 4.3
      virtual void stream_temperature(::grpc::ClientContext* context, const ::minknow_api::device::StreamTemperatureRequest* request, ::grpc::ClientReadReactor< ::minknow_api::device::GetTemperatureResponse>* reactor) = 0;
      // Triggers an unblock for a list of channels for a given duration (Please see UnblockRequest).
      // It will start an unblock for every channel received as a parameter, then this RPC returns.
      // After the timeout expires (the duration in seconds given in the request), the return from
      // unblock is automatically triggered, which resets the channel configuration (mux) to the
      // value preceding the unblock.
      //
      // Notes!!
      //
      // During the unblock the user should NOT do any mux changes, as the unblock will be interrupted.
      // On Promethion this would be even more complicated, as an unblock would normally restore
      // hardware saturation. If an unblock is interrupted it will not restore the state to the original
      // one.
      //
      // The user should NOT change the overload mode during an unblock - this will confuse the return from
      // unblock, which tries to reset the overload mode to the state preceeding the unblock.
      //
      // The unblock can fail if the channel is not in a valid well state (this means a channel needs to be
      // in one of pore1-4, not test current, regen pore or unblock). If a mux is not valid, the unblock grpc
      // will try to continue for the rest of the channels, ignoring the one with the wrong mux.
      virtual void unblock(::grpc::ClientContext* context, const ::minknow_api::device::UnblockRequest* request, ::minknow_api::device::UnblockResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void unblock(::grpc::ClientContext* context, const ::minknow_api::device::UnblockRequest* request, ::minknow_api::device::UnblockResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Cancel in progress unblocks.
      //
      // Any unblocks registered with `device.unblock` will be stopped before this command returns.
      // Unblocks are stopped by applying any actions required to return from unblock (mux changes, or hardware configuration).
      //
      // Since 1.15
      virtual void cancel_unblocks(::grpc::ClientContext* context, const ::minknow_api::device::CancelUnblocksRequest* request, ::minknow_api::device::CancelUnblocksResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void cancel_unblocks(::grpc::ClientContext* context, const ::minknow_api::device::CancelUnblocksRequest* request, ::minknow_api::device::CancelUnblocksResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Get the channel configuration for any number of channels
      //
      // The maximum addressable channel will depend on the device. Currently this will be 512 on a MinION/GridION
      // and 3000 on a PromethION
      virtual void get_channel_configuration(::grpc::ClientContext* context, const ::minknow_api::device::GetChannelConfigurationRequest* request, ::minknow_api::device::GetChannelConfigurationResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_channel_configuration(::grpc::ClientContext* context, const ::minknow_api::device::GetChannelConfigurationRequest* request, ::minknow_api::device::GetChannelConfigurationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Set the channel configuration for any number of channels
      //
      // The maximum addressable channel will depend on the device. Currently this will be 512 on a MinION/GridION
      // and 3000 on a PromethION.
      virtual void set_channel_configuration(::grpc::ClientContext* context, const ::minknow_api::device::SetChannelConfigurationRequest* request, ::minknow_api::device::SetChannelConfigurationResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void set_channel_configuration(::grpc::ClientContext* context, const ::minknow_api::device::SetChannelConfigurationRequest* request, ::minknow_api::device::SetChannelConfigurationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void set_channel_configuration_all(::grpc::ClientContext* context, const ::minknow_api::device::SetChannelConfigurationAllRequest* request, ::minknow_api::device::SetChannelConfigurationAllResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void set_channel_configuration_all(::grpc::ClientContext* context, const ::minknow_api::device::SetChannelConfigurationAllRequest* request, ::minknow_api::device::SetChannelConfigurationAllResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Set the saturation control configuration.
      //
      // The request is immediately sent to the data acquisition module, and applied. All settings can be changed
      // whilst the experiment is running.
      //
      // If any keys are not specified when this method is called (see the message for specific optional parameters),
      // the previously applied parameters are kept; initially, when this method has never been called, defaults from the
      // application config are used.
      //
      // note: calling this method resets anu in-progress saturations when it is called, causing them to need to start
      // saturation counts again, this may mean any saturations may take longer to occur.
      virtual void set_saturation_config(::grpc::ClientContext* context, const ::minknow_api::device::SetSaturationConfigRequest* request, ::minknow_api::device::SetSaturationConfigResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void set_saturation_config(::grpc::ClientContext* context, const ::minknow_api::device::SetSaturationConfigRequest* request, ::minknow_api::device::SetSaturationConfigResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Get the saturation control configuration.
      //
      // The default configuration is specifed by the MinKNOW application configuration, the command returns the most
      // recently applied saturation config.
      virtual void get_saturation_config(::grpc::ClientContext* context, const ::minknow_api::device::GetSaturationConfigRequest* request, ::minknow_api::device::GetSaturationConfigResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_saturation_config(::grpc::ClientContext* context, const ::minknow_api::device::GetSaturationConfigRequest* request, ::minknow_api::device::GetSaturationConfigResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Get the sample rate of the device
      //
      // Please refer to MinionDeviceService and PromethionDeviceService for the expected
      // return value for a minion and promethion respectively
      virtual void get_sample_rate(::grpc::ClientContext* context, const ::minknow_api::device::GetSampleRateRequest* request, ::minknow_api::device::GetSampleRateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_sample_rate(::grpc::ClientContext* context, const ::minknow_api::device::GetSampleRateRequest* request, ::minknow_api::device::GetSampleRateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Set the sample rate of the device, and returns the actual value set on the device
      //
      // Please refer to MinionDeviceService and PromethionDeviceService to see
      // how the value set here will be used to determine the real sample rate for a
      // minion and promethion respectively
      //
      // Trying to set the sample rate during an acquisition period will result in an error
      virtual void set_sample_rate(::grpc::ClientContext* context, const ::minknow_api::device::SetSampleRateRequest* request, ::minknow_api::device::SetSampleRateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void set_sample_rate(::grpc::ClientContext* context, const ::minknow_api::device::SetSampleRateRequest* request, ::minknow_api::device::SetSampleRateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void get_bias_voltage(::grpc::ClientContext* context, const ::minknow_api::device::GetBiasVoltageRequest* request, ::minknow_api::device::GetBiasVoltageResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_bias_voltage(::grpc::ClientContext* context, const ::minknow_api::device::GetBiasVoltageRequest* request, ::minknow_api::device::GetBiasVoltageResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void set_bias_voltage(::grpc::ClientContext* context, const ::minknow_api::device::SetBiasVoltageRequest* request, ::minknow_api::device::SetBiasVoltageResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void set_bias_voltage(::grpc::ClientContext* context, const ::minknow_api::device::SetBiasVoltageRequest* request, ::minknow_api::device::SetBiasVoltageResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetDeviceInfoResponse>* Asyncget_device_infoRaw(::grpc::ClientContext* context, const ::minknow_api::device::GetDeviceInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetDeviceInfoResponse>* PrepareAsyncget_device_infoRaw(::grpc::ClientContext* context, const ::minknow_api::device::GetDeviceInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetDeviceStateResponse>* Asyncget_device_stateRaw(::grpc::ClientContext* context, const ::minknow_api::device::GetDeviceStateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetDeviceStateResponse>* PrepareAsyncget_device_stateRaw(::grpc::ClientContext* context, const ::minknow_api::device::GetDeviceStateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::minknow_api::device::GetDeviceStateResponse>* stream_device_stateRaw(::grpc::ClientContext* context, const ::minknow_api::device::StreamDeviceStateRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::minknow_api::device::GetDeviceStateResponse>* Asyncstream_device_stateRaw(::grpc::ClientContext* context, const ::minknow_api::device::StreamDeviceStateRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::minknow_api::device::GetDeviceStateResponse>* PrepareAsyncstream_device_stateRaw(::grpc::ClientContext* context, const ::minknow_api::device::StreamDeviceStateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetFlowCellInfoResponse>* Asyncget_flow_cell_infoRaw(::grpc::ClientContext* context, const ::minknow_api::device::GetFlowCellInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetFlowCellInfoResponse>* PrepareAsyncget_flow_cell_infoRaw(::grpc::ClientContext* context, const ::minknow_api::device::GetFlowCellInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::minknow_api::device::GetFlowCellInfoResponse>* stream_flow_cell_infoRaw(::grpc::ClientContext* context, const ::minknow_api::device::StreamFlowCellInfoRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::minknow_api::device::GetFlowCellInfoResponse>* Asyncstream_flow_cell_infoRaw(::grpc::ClientContext* context, const ::minknow_api::device::StreamFlowCellInfoRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::minknow_api::device::GetFlowCellInfoResponse>* PrepareAsyncstream_flow_cell_infoRaw(::grpc::ClientContext* context, const ::minknow_api::device::StreamFlowCellInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetUserSpecifiedFlowCellIdResponse>* Asyncset_user_specified_flow_cell_idRaw(::grpc::ClientContext* context, const ::minknow_api::device::SetUserSpecifiedFlowCellIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetUserSpecifiedFlowCellIdResponse>* PrepareAsyncset_user_specified_flow_cell_idRaw(::grpc::ClientContext* context, const ::minknow_api::device::SetUserSpecifiedFlowCellIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetUserSpecifiedProductCodeResponse>* Asyncset_user_specified_product_codeRaw(::grpc::ClientContext* context, const ::minknow_api::device::SetUserSpecifiedProductCodeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetUserSpecifiedProductCodeResponse>* PrepareAsyncset_user_specified_product_codeRaw(::grpc::ClientContext* context, const ::minknow_api::device::SetUserSpecifiedProductCodeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetChannelsLayoutResponse>* Asyncget_channels_layoutRaw(::grpc::ClientContext* context, const ::minknow_api::device::GetChannelsLayoutRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetChannelsLayoutResponse>* PrepareAsyncget_channels_layoutRaw(::grpc::ClientContext* context, const ::minknow_api::device::GetChannelsLayoutRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::ResetDeviceSettingsResponse>* Asyncreset_device_settingsRaw(::grpc::ClientContext* context, const ::minknow_api::device::ResetDeviceSettingsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::ResetDeviceSettingsResponse>* PrepareAsyncreset_device_settingsRaw(::grpc::ClientContext* context, const ::minknow_api::device::ResetDeviceSettingsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetCalibrationResponse>* Asyncset_calibrationRaw(::grpc::ClientContext* context, const ::minknow_api::device::SetCalibrationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetCalibrationResponse>* PrepareAsyncset_calibrationRaw(::grpc::ClientContext* context, const ::minknow_api::device::SetCalibrationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::ClearCalibrationResponse>* Asyncclear_calibrationRaw(::grpc::ClientContext* context, const ::minknow_api::device::ClearCalibrationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::ClearCalibrationResponse>* PrepareAsyncclear_calibrationRaw(::grpc::ClientContext* context, const ::minknow_api::device::ClearCalibrationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetCalibrationResponse>* Asyncget_calibrationRaw(::grpc::ClientContext* context, const ::minknow_api::device::GetCalibrationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetCalibrationResponse>* PrepareAsyncget_calibrationRaw(::grpc::ClientContext* context, const ::minknow_api::device::GetCalibrationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetTemperatureResponse>* Asyncset_temperatureRaw(::grpc::ClientContext* context, const ::minknow_api::device::SetTemperatureRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetTemperatureResponse>* PrepareAsyncset_temperatureRaw(::grpc::ClientContext* context, const ::minknow_api::device::SetTemperatureRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetTemperatureResponse>* Asyncget_temperatureRaw(::grpc::ClientContext* context, const ::minknow_api::device::GetTemperatureRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetTemperatureResponse>* PrepareAsyncget_temperatureRaw(::grpc::ClientContext* context, const ::minknow_api::device::GetTemperatureRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::minknow_api::device::GetTemperatureResponse>* stream_temperatureRaw(::grpc::ClientContext* context, const ::minknow_api::device::StreamTemperatureRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::minknow_api::device::GetTemperatureResponse>* Asyncstream_temperatureRaw(::grpc::ClientContext* context, const ::minknow_api::device::StreamTemperatureRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::minknow_api::device::GetTemperatureResponse>* PrepareAsyncstream_temperatureRaw(::grpc::ClientContext* context, const ::minknow_api::device::StreamTemperatureRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::UnblockResponse>* AsyncunblockRaw(::grpc::ClientContext* context, const ::minknow_api::device::UnblockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::UnblockResponse>* PrepareAsyncunblockRaw(::grpc::ClientContext* context, const ::minknow_api::device::UnblockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::CancelUnblocksResponse>* Asynccancel_unblocksRaw(::grpc::ClientContext* context, const ::minknow_api::device::CancelUnblocksRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::CancelUnblocksResponse>* PrepareAsynccancel_unblocksRaw(::grpc::ClientContext* context, const ::minknow_api::device::CancelUnblocksRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetChannelConfigurationResponse>* Asyncget_channel_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::device::GetChannelConfigurationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetChannelConfigurationResponse>* PrepareAsyncget_channel_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::device::GetChannelConfigurationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetChannelConfigurationResponse>* Asyncset_channel_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::device::SetChannelConfigurationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetChannelConfigurationResponse>* PrepareAsyncset_channel_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::device::SetChannelConfigurationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetChannelConfigurationAllResponse>* Asyncset_channel_configuration_allRaw(::grpc::ClientContext* context, const ::minknow_api::device::SetChannelConfigurationAllRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetChannelConfigurationAllResponse>* PrepareAsyncset_channel_configuration_allRaw(::grpc::ClientContext* context, const ::minknow_api::device::SetChannelConfigurationAllRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetSaturationConfigResponse>* Asyncset_saturation_configRaw(::grpc::ClientContext* context, const ::minknow_api::device::SetSaturationConfigRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetSaturationConfigResponse>* PrepareAsyncset_saturation_configRaw(::grpc::ClientContext* context, const ::minknow_api::device::SetSaturationConfigRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetSaturationConfigResponse>* Asyncget_saturation_configRaw(::grpc::ClientContext* context, const ::minknow_api::device::GetSaturationConfigRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetSaturationConfigResponse>* PrepareAsyncget_saturation_configRaw(::grpc::ClientContext* context, const ::minknow_api::device::GetSaturationConfigRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetSampleRateResponse>* Asyncget_sample_rateRaw(::grpc::ClientContext* context, const ::minknow_api::device::GetSampleRateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetSampleRateResponse>* PrepareAsyncget_sample_rateRaw(::grpc::ClientContext* context, const ::minknow_api::device::GetSampleRateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetSampleRateResponse>* Asyncset_sample_rateRaw(::grpc::ClientContext* context, const ::minknow_api::device::SetSampleRateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetSampleRateResponse>* PrepareAsyncset_sample_rateRaw(::grpc::ClientContext* context, const ::minknow_api::device::SetSampleRateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetBiasVoltageResponse>* Asyncget_bias_voltageRaw(::grpc::ClientContext* context, const ::minknow_api::device::GetBiasVoltageRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::GetBiasVoltageResponse>* PrepareAsyncget_bias_voltageRaw(::grpc::ClientContext* context, const ::minknow_api::device::GetBiasVoltageRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetBiasVoltageResponse>* Asyncset_bias_voltageRaw(::grpc::ClientContext* context, const ::minknow_api::device::SetBiasVoltageRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::device::SetBiasVoltageResponse>* PrepareAsyncset_bias_voltageRaw(::grpc::ClientContext* context, const ::minknow_api::device::SetBiasVoltageRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status get_device_info(::grpc::ClientContext* context, const ::minknow_api::device::GetDeviceInfoRequest& request, ::minknow_api::device::GetDeviceInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetDeviceInfoResponse>> Asyncget_device_info(::grpc::ClientContext* context, const ::minknow_api::device::GetDeviceInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetDeviceInfoResponse>>(Asyncget_device_infoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetDeviceInfoResponse>> PrepareAsyncget_device_info(::grpc::ClientContext* context, const ::minknow_api::device::GetDeviceInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetDeviceInfoResponse>>(PrepareAsyncget_device_infoRaw(context, request, cq));
    }
    ::grpc::Status get_device_state(::grpc::ClientContext* context, const ::minknow_api::device::GetDeviceStateRequest& request, ::minknow_api::device::GetDeviceStateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetDeviceStateResponse>> Asyncget_device_state(::grpc::ClientContext* context, const ::minknow_api::device::GetDeviceStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetDeviceStateResponse>>(Asyncget_device_stateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetDeviceStateResponse>> PrepareAsyncget_device_state(::grpc::ClientContext* context, const ::minknow_api::device::GetDeviceStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetDeviceStateResponse>>(PrepareAsyncget_device_stateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::minknow_api::device::GetDeviceStateResponse>> stream_device_state(::grpc::ClientContext* context, const ::minknow_api::device::StreamDeviceStateRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::minknow_api::device::GetDeviceStateResponse>>(stream_device_stateRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::device::GetDeviceStateResponse>> Asyncstream_device_state(::grpc::ClientContext* context, const ::minknow_api::device::StreamDeviceStateRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::device::GetDeviceStateResponse>>(Asyncstream_device_stateRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::device::GetDeviceStateResponse>> PrepareAsyncstream_device_state(::grpc::ClientContext* context, const ::minknow_api::device::StreamDeviceStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::device::GetDeviceStateResponse>>(PrepareAsyncstream_device_stateRaw(context, request, cq));
    }
    ::grpc::Status get_flow_cell_info(::grpc::ClientContext* context, const ::minknow_api::device::GetFlowCellInfoRequest& request, ::minknow_api::device::GetFlowCellInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetFlowCellInfoResponse>> Asyncget_flow_cell_info(::grpc::ClientContext* context, const ::minknow_api::device::GetFlowCellInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetFlowCellInfoResponse>>(Asyncget_flow_cell_infoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetFlowCellInfoResponse>> PrepareAsyncget_flow_cell_info(::grpc::ClientContext* context, const ::minknow_api::device::GetFlowCellInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetFlowCellInfoResponse>>(PrepareAsyncget_flow_cell_infoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::minknow_api::device::GetFlowCellInfoResponse>> stream_flow_cell_info(::grpc::ClientContext* context, const ::minknow_api::device::StreamFlowCellInfoRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::minknow_api::device::GetFlowCellInfoResponse>>(stream_flow_cell_infoRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::device::GetFlowCellInfoResponse>> Asyncstream_flow_cell_info(::grpc::ClientContext* context, const ::minknow_api::device::StreamFlowCellInfoRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::device::GetFlowCellInfoResponse>>(Asyncstream_flow_cell_infoRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::device::GetFlowCellInfoResponse>> PrepareAsyncstream_flow_cell_info(::grpc::ClientContext* context, const ::minknow_api::device::StreamFlowCellInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::device::GetFlowCellInfoResponse>>(PrepareAsyncstream_flow_cell_infoRaw(context, request, cq));
    }
    ::grpc::Status set_user_specified_flow_cell_id(::grpc::ClientContext* context, const ::minknow_api::device::SetUserSpecifiedFlowCellIdRequest& request, ::minknow_api::device::SetUserSpecifiedFlowCellIdResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetUserSpecifiedFlowCellIdResponse>> Asyncset_user_specified_flow_cell_id(::grpc::ClientContext* context, const ::minknow_api::device::SetUserSpecifiedFlowCellIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetUserSpecifiedFlowCellIdResponse>>(Asyncset_user_specified_flow_cell_idRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetUserSpecifiedFlowCellIdResponse>> PrepareAsyncset_user_specified_flow_cell_id(::grpc::ClientContext* context, const ::minknow_api::device::SetUserSpecifiedFlowCellIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetUserSpecifiedFlowCellIdResponse>>(PrepareAsyncset_user_specified_flow_cell_idRaw(context, request, cq));
    }
    ::grpc::Status set_user_specified_product_code(::grpc::ClientContext* context, const ::minknow_api::device::SetUserSpecifiedProductCodeRequest& request, ::minknow_api::device::SetUserSpecifiedProductCodeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetUserSpecifiedProductCodeResponse>> Asyncset_user_specified_product_code(::grpc::ClientContext* context, const ::minknow_api::device::SetUserSpecifiedProductCodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetUserSpecifiedProductCodeResponse>>(Asyncset_user_specified_product_codeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetUserSpecifiedProductCodeResponse>> PrepareAsyncset_user_specified_product_code(::grpc::ClientContext* context, const ::minknow_api::device::SetUserSpecifiedProductCodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetUserSpecifiedProductCodeResponse>>(PrepareAsyncset_user_specified_product_codeRaw(context, request, cq));
    }
    ::grpc::Status get_channels_layout(::grpc::ClientContext* context, const ::minknow_api::device::GetChannelsLayoutRequest& request, ::minknow_api::device::GetChannelsLayoutResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetChannelsLayoutResponse>> Asyncget_channels_layout(::grpc::ClientContext* context, const ::minknow_api::device::GetChannelsLayoutRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetChannelsLayoutResponse>>(Asyncget_channels_layoutRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetChannelsLayoutResponse>> PrepareAsyncget_channels_layout(::grpc::ClientContext* context, const ::minknow_api::device::GetChannelsLayoutRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetChannelsLayoutResponse>>(PrepareAsyncget_channels_layoutRaw(context, request, cq));
    }
    ::grpc::Status reset_device_settings(::grpc::ClientContext* context, const ::minknow_api::device::ResetDeviceSettingsRequest& request, ::minknow_api::device::ResetDeviceSettingsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::ResetDeviceSettingsResponse>> Asyncreset_device_settings(::grpc::ClientContext* context, const ::minknow_api::device::ResetDeviceSettingsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::ResetDeviceSettingsResponse>>(Asyncreset_device_settingsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::ResetDeviceSettingsResponse>> PrepareAsyncreset_device_settings(::grpc::ClientContext* context, const ::minknow_api::device::ResetDeviceSettingsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::ResetDeviceSettingsResponse>>(PrepareAsyncreset_device_settingsRaw(context, request, cq));
    }
    ::grpc::Status set_calibration(::grpc::ClientContext* context, const ::minknow_api::device::SetCalibrationRequest& request, ::minknow_api::device::SetCalibrationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetCalibrationResponse>> Asyncset_calibration(::grpc::ClientContext* context, const ::minknow_api::device::SetCalibrationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetCalibrationResponse>>(Asyncset_calibrationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetCalibrationResponse>> PrepareAsyncset_calibration(::grpc::ClientContext* context, const ::minknow_api::device::SetCalibrationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetCalibrationResponse>>(PrepareAsyncset_calibrationRaw(context, request, cq));
    }
    ::grpc::Status clear_calibration(::grpc::ClientContext* context, const ::minknow_api::device::ClearCalibrationRequest& request, ::minknow_api::device::ClearCalibrationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::ClearCalibrationResponse>> Asyncclear_calibration(::grpc::ClientContext* context, const ::minknow_api::device::ClearCalibrationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::ClearCalibrationResponse>>(Asyncclear_calibrationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::ClearCalibrationResponse>> PrepareAsyncclear_calibration(::grpc::ClientContext* context, const ::minknow_api::device::ClearCalibrationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::ClearCalibrationResponse>>(PrepareAsyncclear_calibrationRaw(context, request, cq));
    }
    ::grpc::Status get_calibration(::grpc::ClientContext* context, const ::minknow_api::device::GetCalibrationRequest& request, ::minknow_api::device::GetCalibrationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetCalibrationResponse>> Asyncget_calibration(::grpc::ClientContext* context, const ::minknow_api::device::GetCalibrationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetCalibrationResponse>>(Asyncget_calibrationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetCalibrationResponse>> PrepareAsyncget_calibration(::grpc::ClientContext* context, const ::minknow_api::device::GetCalibrationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetCalibrationResponse>>(PrepareAsyncget_calibrationRaw(context, request, cq));
    }
    ::grpc::Status set_temperature(::grpc::ClientContext* context, const ::minknow_api::device::SetTemperatureRequest& request, ::minknow_api::device::SetTemperatureResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetTemperatureResponse>> Asyncset_temperature(::grpc::ClientContext* context, const ::minknow_api::device::SetTemperatureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetTemperatureResponse>>(Asyncset_temperatureRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetTemperatureResponse>> PrepareAsyncset_temperature(::grpc::ClientContext* context, const ::minknow_api::device::SetTemperatureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetTemperatureResponse>>(PrepareAsyncset_temperatureRaw(context, request, cq));
    }
    ::grpc::Status get_temperature(::grpc::ClientContext* context, const ::minknow_api::device::GetTemperatureRequest& request, ::minknow_api::device::GetTemperatureResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetTemperatureResponse>> Asyncget_temperature(::grpc::ClientContext* context, const ::minknow_api::device::GetTemperatureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetTemperatureResponse>>(Asyncget_temperatureRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetTemperatureResponse>> PrepareAsyncget_temperature(::grpc::ClientContext* context, const ::minknow_api::device::GetTemperatureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetTemperatureResponse>>(PrepareAsyncget_temperatureRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::minknow_api::device::GetTemperatureResponse>> stream_temperature(::grpc::ClientContext* context, const ::minknow_api::device::StreamTemperatureRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::minknow_api::device::GetTemperatureResponse>>(stream_temperatureRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::device::GetTemperatureResponse>> Asyncstream_temperature(::grpc::ClientContext* context, const ::minknow_api::device::StreamTemperatureRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::device::GetTemperatureResponse>>(Asyncstream_temperatureRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::device::GetTemperatureResponse>> PrepareAsyncstream_temperature(::grpc::ClientContext* context, const ::minknow_api::device::StreamTemperatureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::device::GetTemperatureResponse>>(PrepareAsyncstream_temperatureRaw(context, request, cq));
    }
    ::grpc::Status unblock(::grpc::ClientContext* context, const ::minknow_api::device::UnblockRequest& request, ::minknow_api::device::UnblockResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::UnblockResponse>> Asyncunblock(::grpc::ClientContext* context, const ::minknow_api::device::UnblockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::UnblockResponse>>(AsyncunblockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::UnblockResponse>> PrepareAsyncunblock(::grpc::ClientContext* context, const ::minknow_api::device::UnblockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::UnblockResponse>>(PrepareAsyncunblockRaw(context, request, cq));
    }
    ::grpc::Status cancel_unblocks(::grpc::ClientContext* context, const ::minknow_api::device::CancelUnblocksRequest& request, ::minknow_api::device::CancelUnblocksResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::CancelUnblocksResponse>> Asynccancel_unblocks(::grpc::ClientContext* context, const ::minknow_api::device::CancelUnblocksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::CancelUnblocksResponse>>(Asynccancel_unblocksRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::CancelUnblocksResponse>> PrepareAsynccancel_unblocks(::grpc::ClientContext* context, const ::minknow_api::device::CancelUnblocksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::CancelUnblocksResponse>>(PrepareAsynccancel_unblocksRaw(context, request, cq));
    }
    ::grpc::Status get_channel_configuration(::grpc::ClientContext* context, const ::minknow_api::device::GetChannelConfigurationRequest& request, ::minknow_api::device::GetChannelConfigurationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetChannelConfigurationResponse>> Asyncget_channel_configuration(::grpc::ClientContext* context, const ::minknow_api::device::GetChannelConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetChannelConfigurationResponse>>(Asyncget_channel_configurationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetChannelConfigurationResponse>> PrepareAsyncget_channel_configuration(::grpc::ClientContext* context, const ::minknow_api::device::GetChannelConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetChannelConfigurationResponse>>(PrepareAsyncget_channel_configurationRaw(context, request, cq));
    }
    ::grpc::Status set_channel_configuration(::grpc::ClientContext* context, const ::minknow_api::device::SetChannelConfigurationRequest& request, ::minknow_api::device::SetChannelConfigurationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetChannelConfigurationResponse>> Asyncset_channel_configuration(::grpc::ClientContext* context, const ::minknow_api::device::SetChannelConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetChannelConfigurationResponse>>(Asyncset_channel_configurationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetChannelConfigurationResponse>> PrepareAsyncset_channel_configuration(::grpc::ClientContext* context, const ::minknow_api::device::SetChannelConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetChannelConfigurationResponse>>(PrepareAsyncset_channel_configurationRaw(context, request, cq));
    }
    ::grpc::Status set_channel_configuration_all(::grpc::ClientContext* context, const ::minknow_api::device::SetChannelConfigurationAllRequest& request, ::minknow_api::device::SetChannelConfigurationAllResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetChannelConfigurationAllResponse>> Asyncset_channel_configuration_all(::grpc::ClientContext* context, const ::minknow_api::device::SetChannelConfigurationAllRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetChannelConfigurationAllResponse>>(Asyncset_channel_configuration_allRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetChannelConfigurationAllResponse>> PrepareAsyncset_channel_configuration_all(::grpc::ClientContext* context, const ::minknow_api::device::SetChannelConfigurationAllRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetChannelConfigurationAllResponse>>(PrepareAsyncset_channel_configuration_allRaw(context, request, cq));
    }
    ::grpc::Status set_saturation_config(::grpc::ClientContext* context, const ::minknow_api::device::SetSaturationConfigRequest& request, ::minknow_api::device::SetSaturationConfigResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetSaturationConfigResponse>> Asyncset_saturation_config(::grpc::ClientContext* context, const ::minknow_api::device::SetSaturationConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetSaturationConfigResponse>>(Asyncset_saturation_configRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetSaturationConfigResponse>> PrepareAsyncset_saturation_config(::grpc::ClientContext* context, const ::minknow_api::device::SetSaturationConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetSaturationConfigResponse>>(PrepareAsyncset_saturation_configRaw(context, request, cq));
    }
    ::grpc::Status get_saturation_config(::grpc::ClientContext* context, const ::minknow_api::device::GetSaturationConfigRequest& request, ::minknow_api::device::GetSaturationConfigResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetSaturationConfigResponse>> Asyncget_saturation_config(::grpc::ClientContext* context, const ::minknow_api::device::GetSaturationConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetSaturationConfigResponse>>(Asyncget_saturation_configRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetSaturationConfigResponse>> PrepareAsyncget_saturation_config(::grpc::ClientContext* context, const ::minknow_api::device::GetSaturationConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetSaturationConfigResponse>>(PrepareAsyncget_saturation_configRaw(context, request, cq));
    }
    ::grpc::Status get_sample_rate(::grpc::ClientContext* context, const ::minknow_api::device::GetSampleRateRequest& request, ::minknow_api::device::GetSampleRateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetSampleRateResponse>> Asyncget_sample_rate(::grpc::ClientContext* context, const ::minknow_api::device::GetSampleRateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetSampleRateResponse>>(Asyncget_sample_rateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetSampleRateResponse>> PrepareAsyncget_sample_rate(::grpc::ClientContext* context, const ::minknow_api::device::GetSampleRateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetSampleRateResponse>>(PrepareAsyncget_sample_rateRaw(context, request, cq));
    }
    ::grpc::Status set_sample_rate(::grpc::ClientContext* context, const ::minknow_api::device::SetSampleRateRequest& request, ::minknow_api::device::SetSampleRateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetSampleRateResponse>> Asyncset_sample_rate(::grpc::ClientContext* context, const ::minknow_api::device::SetSampleRateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetSampleRateResponse>>(Asyncset_sample_rateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetSampleRateResponse>> PrepareAsyncset_sample_rate(::grpc::ClientContext* context, const ::minknow_api::device::SetSampleRateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetSampleRateResponse>>(PrepareAsyncset_sample_rateRaw(context, request, cq));
    }
    ::grpc::Status get_bias_voltage(::grpc::ClientContext* context, const ::minknow_api::device::GetBiasVoltageRequest& request, ::minknow_api::device::GetBiasVoltageResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetBiasVoltageResponse>> Asyncget_bias_voltage(::grpc::ClientContext* context, const ::minknow_api::device::GetBiasVoltageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetBiasVoltageResponse>>(Asyncget_bias_voltageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetBiasVoltageResponse>> PrepareAsyncget_bias_voltage(::grpc::ClientContext* context, const ::minknow_api::device::GetBiasVoltageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetBiasVoltageResponse>>(PrepareAsyncget_bias_voltageRaw(context, request, cq));
    }
    ::grpc::Status set_bias_voltage(::grpc::ClientContext* context, const ::minknow_api::device::SetBiasVoltageRequest& request, ::minknow_api::device::SetBiasVoltageResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetBiasVoltageResponse>> Asyncset_bias_voltage(::grpc::ClientContext* context, const ::minknow_api::device::SetBiasVoltageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetBiasVoltageResponse>>(Asyncset_bias_voltageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetBiasVoltageResponse>> PrepareAsyncset_bias_voltage(::grpc::ClientContext* context, const ::minknow_api::device::SetBiasVoltageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetBiasVoltageResponse>>(PrepareAsyncset_bias_voltageRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void get_device_info(::grpc::ClientContext* context, const ::minknow_api::device::GetDeviceInfoRequest* request, ::minknow_api::device::GetDeviceInfoResponse* response, std::function<void(::grpc::Status)>) override;
      void get_device_info(::grpc::ClientContext* context, const ::minknow_api::device::GetDeviceInfoRequest* request, ::minknow_api::device::GetDeviceInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_device_state(::grpc::ClientContext* context, const ::minknow_api::device::GetDeviceStateRequest* request, ::minknow_api::device::GetDeviceStateResponse* response, std::function<void(::grpc::Status)>) override;
      void get_device_state(::grpc::ClientContext* context, const ::minknow_api::device::GetDeviceStateRequest* request, ::minknow_api::device::GetDeviceStateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void stream_device_state(::grpc::ClientContext* context, const ::minknow_api::device::StreamDeviceStateRequest* request, ::grpc::ClientReadReactor< ::minknow_api::device::GetDeviceStateResponse>* reactor) override;
      void get_flow_cell_info(::grpc::ClientContext* context, const ::minknow_api::device::GetFlowCellInfoRequest* request, ::minknow_api::device::GetFlowCellInfoResponse* response, std::function<void(::grpc::Status)>) override;
      void get_flow_cell_info(::grpc::ClientContext* context, const ::minknow_api::device::GetFlowCellInfoRequest* request, ::minknow_api::device::GetFlowCellInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void stream_flow_cell_info(::grpc::ClientContext* context, const ::minknow_api::device::StreamFlowCellInfoRequest* request, ::grpc::ClientReadReactor< ::minknow_api::device::GetFlowCellInfoResponse>* reactor) override;
      void set_user_specified_flow_cell_id(::grpc::ClientContext* context, const ::minknow_api::device::SetUserSpecifiedFlowCellIdRequest* request, ::minknow_api::device::SetUserSpecifiedFlowCellIdResponse* response, std::function<void(::grpc::Status)>) override;
      void set_user_specified_flow_cell_id(::grpc::ClientContext* context, const ::minknow_api::device::SetUserSpecifiedFlowCellIdRequest* request, ::minknow_api::device::SetUserSpecifiedFlowCellIdResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void set_user_specified_product_code(::grpc::ClientContext* context, const ::minknow_api::device::SetUserSpecifiedProductCodeRequest* request, ::minknow_api::device::SetUserSpecifiedProductCodeResponse* response, std::function<void(::grpc::Status)>) override;
      void set_user_specified_product_code(::grpc::ClientContext* context, const ::minknow_api::device::SetUserSpecifiedProductCodeRequest* request, ::minknow_api::device::SetUserSpecifiedProductCodeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_channels_layout(::grpc::ClientContext* context, const ::minknow_api::device::GetChannelsLayoutRequest* request, ::minknow_api::device::GetChannelsLayoutResponse* response, std::function<void(::grpc::Status)>) override;
      void get_channels_layout(::grpc::ClientContext* context, const ::minknow_api::device::GetChannelsLayoutRequest* request, ::minknow_api::device::GetChannelsLayoutResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void reset_device_settings(::grpc::ClientContext* context, const ::minknow_api::device::ResetDeviceSettingsRequest* request, ::minknow_api::device::ResetDeviceSettingsResponse* response, std::function<void(::grpc::Status)>) override;
      void reset_device_settings(::grpc::ClientContext* context, const ::minknow_api::device::ResetDeviceSettingsRequest* request, ::minknow_api::device::ResetDeviceSettingsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void set_calibration(::grpc::ClientContext* context, const ::minknow_api::device::SetCalibrationRequest* request, ::minknow_api::device::SetCalibrationResponse* response, std::function<void(::grpc::Status)>) override;
      void set_calibration(::grpc::ClientContext* context, const ::minknow_api::device::SetCalibrationRequest* request, ::minknow_api::device::SetCalibrationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void clear_calibration(::grpc::ClientContext* context, const ::minknow_api::device::ClearCalibrationRequest* request, ::minknow_api::device::ClearCalibrationResponse* response, std::function<void(::grpc::Status)>) override;
      void clear_calibration(::grpc::ClientContext* context, const ::minknow_api::device::ClearCalibrationRequest* request, ::minknow_api::device::ClearCalibrationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_calibration(::grpc::ClientContext* context, const ::minknow_api::device::GetCalibrationRequest* request, ::minknow_api::device::GetCalibrationResponse* response, std::function<void(::grpc::Status)>) override;
      void get_calibration(::grpc::ClientContext* context, const ::minknow_api::device::GetCalibrationRequest* request, ::minknow_api::device::GetCalibrationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void set_temperature(::grpc::ClientContext* context, const ::minknow_api::device::SetTemperatureRequest* request, ::minknow_api::device::SetTemperatureResponse* response, std::function<void(::grpc::Status)>) override;
      void set_temperature(::grpc::ClientContext* context, const ::minknow_api::device::SetTemperatureRequest* request, ::minknow_api::device::SetTemperatureResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_temperature(::grpc::ClientContext* context, const ::minknow_api::device::GetTemperatureRequest* request, ::minknow_api::device::GetTemperatureResponse* response, std::function<void(::grpc::Status)>) override;
      void get_temperature(::grpc::ClientContext* context, const ::minknow_api::device::GetTemperatureRequest* request, ::minknow_api::device::GetTemperatureResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void stream_temperature(::grpc::ClientContext* context, const ::minknow_api::device::StreamTemperatureRequest* request, ::grpc::ClientReadReactor< ::minknow_api::device::GetTemperatureResponse>* reactor) override;
      void unblock(::grpc::ClientContext* context, const ::minknow_api::device::UnblockRequest* request, ::minknow_api::device::UnblockResponse* response, std::function<void(::grpc::Status)>) override;
      void unblock(::grpc::ClientContext* context, const ::minknow_api::device::UnblockRequest* request, ::minknow_api::device::UnblockResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void cancel_unblocks(::grpc::ClientContext* context, const ::minknow_api::device::CancelUnblocksRequest* request, ::minknow_api::device::CancelUnblocksResponse* response, std::function<void(::grpc::Status)>) override;
      void cancel_unblocks(::grpc::ClientContext* context, const ::minknow_api::device::CancelUnblocksRequest* request, ::minknow_api::device::CancelUnblocksResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_channel_configuration(::grpc::ClientContext* context, const ::minknow_api::device::GetChannelConfigurationRequest* request, ::minknow_api::device::GetChannelConfigurationResponse* response, std::function<void(::grpc::Status)>) override;
      void get_channel_configuration(::grpc::ClientContext* context, const ::minknow_api::device::GetChannelConfigurationRequest* request, ::minknow_api::device::GetChannelConfigurationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void set_channel_configuration(::grpc::ClientContext* context, const ::minknow_api::device::SetChannelConfigurationRequest* request, ::minknow_api::device::SetChannelConfigurationResponse* response, std::function<void(::grpc::Status)>) override;
      void set_channel_configuration(::grpc::ClientContext* context, const ::minknow_api::device::SetChannelConfigurationRequest* request, ::minknow_api::device::SetChannelConfigurationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void set_channel_configuration_all(::grpc::ClientContext* context, const ::minknow_api::device::SetChannelConfigurationAllRequest* request, ::minknow_api::device::SetChannelConfigurationAllResponse* response, std::function<void(::grpc::Status)>) override;
      void set_channel_configuration_all(::grpc::ClientContext* context, const ::minknow_api::device::SetChannelConfigurationAllRequest* request, ::minknow_api::device::SetChannelConfigurationAllResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void set_saturation_config(::grpc::ClientContext* context, const ::minknow_api::device::SetSaturationConfigRequest* request, ::minknow_api::device::SetSaturationConfigResponse* response, std::function<void(::grpc::Status)>) override;
      void set_saturation_config(::grpc::ClientContext* context, const ::minknow_api::device::SetSaturationConfigRequest* request, ::minknow_api::device::SetSaturationConfigResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_saturation_config(::grpc::ClientContext* context, const ::minknow_api::device::GetSaturationConfigRequest* request, ::minknow_api::device::GetSaturationConfigResponse* response, std::function<void(::grpc::Status)>) override;
      void get_saturation_config(::grpc::ClientContext* context, const ::minknow_api::device::GetSaturationConfigRequest* request, ::minknow_api::device::GetSaturationConfigResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_sample_rate(::grpc::ClientContext* context, const ::minknow_api::device::GetSampleRateRequest* request, ::minknow_api::device::GetSampleRateResponse* response, std::function<void(::grpc::Status)>) override;
      void get_sample_rate(::grpc::ClientContext* context, const ::minknow_api::device::GetSampleRateRequest* request, ::minknow_api::device::GetSampleRateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void set_sample_rate(::grpc::ClientContext* context, const ::minknow_api::device::SetSampleRateRequest* request, ::minknow_api::device::SetSampleRateResponse* response, std::function<void(::grpc::Status)>) override;
      void set_sample_rate(::grpc::ClientContext* context, const ::minknow_api::device::SetSampleRateRequest* request, ::minknow_api::device::SetSampleRateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_bias_voltage(::grpc::ClientContext* context, const ::minknow_api::device::GetBiasVoltageRequest* request, ::minknow_api::device::GetBiasVoltageResponse* response, std::function<void(::grpc::Status)>) override;
      void get_bias_voltage(::grpc::ClientContext* context, const ::minknow_api::device::GetBiasVoltageRequest* request, ::minknow_api::device::GetBiasVoltageResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void set_bias_voltage(::grpc::ClientContext* context, const ::minknow_api::device::SetBiasVoltageRequest* request, ::minknow_api::device::SetBiasVoltageResponse* response, std::function<void(::grpc::Status)>) override;
      void set_bias_voltage(::grpc::ClientContext* context, const ::minknow_api::device::SetBiasVoltageRequest* request, ::minknow_api::device::SetBiasVoltageResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetDeviceInfoResponse>* Asyncget_device_infoRaw(::grpc::ClientContext* context, const ::minknow_api::device::GetDeviceInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetDeviceInfoResponse>* PrepareAsyncget_device_infoRaw(::grpc::ClientContext* context, const ::minknow_api::device::GetDeviceInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetDeviceStateResponse>* Asyncget_device_stateRaw(::grpc::ClientContext* context, const ::minknow_api::device::GetDeviceStateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetDeviceStateResponse>* PrepareAsyncget_device_stateRaw(::grpc::ClientContext* context, const ::minknow_api::device::GetDeviceStateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::minknow_api::device::GetDeviceStateResponse>* stream_device_stateRaw(::grpc::ClientContext* context, const ::minknow_api::device::StreamDeviceStateRequest& request) override;
    ::grpc::ClientAsyncReader< ::minknow_api::device::GetDeviceStateResponse>* Asyncstream_device_stateRaw(::grpc::ClientContext* context, const ::minknow_api::device::StreamDeviceStateRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::minknow_api::device::GetDeviceStateResponse>* PrepareAsyncstream_device_stateRaw(::grpc::ClientContext* context, const ::minknow_api::device::StreamDeviceStateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetFlowCellInfoResponse>* Asyncget_flow_cell_infoRaw(::grpc::ClientContext* context, const ::minknow_api::device::GetFlowCellInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetFlowCellInfoResponse>* PrepareAsyncget_flow_cell_infoRaw(::grpc::ClientContext* context, const ::minknow_api::device::GetFlowCellInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::minknow_api::device::GetFlowCellInfoResponse>* stream_flow_cell_infoRaw(::grpc::ClientContext* context, const ::minknow_api::device::StreamFlowCellInfoRequest& request) override;
    ::grpc::ClientAsyncReader< ::minknow_api::device::GetFlowCellInfoResponse>* Asyncstream_flow_cell_infoRaw(::grpc::ClientContext* context, const ::minknow_api::device::StreamFlowCellInfoRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::minknow_api::device::GetFlowCellInfoResponse>* PrepareAsyncstream_flow_cell_infoRaw(::grpc::ClientContext* context, const ::minknow_api::device::StreamFlowCellInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetUserSpecifiedFlowCellIdResponse>* Asyncset_user_specified_flow_cell_idRaw(::grpc::ClientContext* context, const ::minknow_api::device::SetUserSpecifiedFlowCellIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetUserSpecifiedFlowCellIdResponse>* PrepareAsyncset_user_specified_flow_cell_idRaw(::grpc::ClientContext* context, const ::minknow_api::device::SetUserSpecifiedFlowCellIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetUserSpecifiedProductCodeResponse>* Asyncset_user_specified_product_codeRaw(::grpc::ClientContext* context, const ::minknow_api::device::SetUserSpecifiedProductCodeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetUserSpecifiedProductCodeResponse>* PrepareAsyncset_user_specified_product_codeRaw(::grpc::ClientContext* context, const ::minknow_api::device::SetUserSpecifiedProductCodeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetChannelsLayoutResponse>* Asyncget_channels_layoutRaw(::grpc::ClientContext* context, const ::minknow_api::device::GetChannelsLayoutRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetChannelsLayoutResponse>* PrepareAsyncget_channels_layoutRaw(::grpc::ClientContext* context, const ::minknow_api::device::GetChannelsLayoutRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::ResetDeviceSettingsResponse>* Asyncreset_device_settingsRaw(::grpc::ClientContext* context, const ::minknow_api::device::ResetDeviceSettingsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::ResetDeviceSettingsResponse>* PrepareAsyncreset_device_settingsRaw(::grpc::ClientContext* context, const ::minknow_api::device::ResetDeviceSettingsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetCalibrationResponse>* Asyncset_calibrationRaw(::grpc::ClientContext* context, const ::minknow_api::device::SetCalibrationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetCalibrationResponse>* PrepareAsyncset_calibrationRaw(::grpc::ClientContext* context, const ::minknow_api::device::SetCalibrationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::ClearCalibrationResponse>* Asyncclear_calibrationRaw(::grpc::ClientContext* context, const ::minknow_api::device::ClearCalibrationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::ClearCalibrationResponse>* PrepareAsyncclear_calibrationRaw(::grpc::ClientContext* context, const ::minknow_api::device::ClearCalibrationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetCalibrationResponse>* Asyncget_calibrationRaw(::grpc::ClientContext* context, const ::minknow_api::device::GetCalibrationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetCalibrationResponse>* PrepareAsyncget_calibrationRaw(::grpc::ClientContext* context, const ::minknow_api::device::GetCalibrationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetTemperatureResponse>* Asyncset_temperatureRaw(::grpc::ClientContext* context, const ::minknow_api::device::SetTemperatureRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetTemperatureResponse>* PrepareAsyncset_temperatureRaw(::grpc::ClientContext* context, const ::minknow_api::device::SetTemperatureRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetTemperatureResponse>* Asyncget_temperatureRaw(::grpc::ClientContext* context, const ::minknow_api::device::GetTemperatureRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetTemperatureResponse>* PrepareAsyncget_temperatureRaw(::grpc::ClientContext* context, const ::minknow_api::device::GetTemperatureRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::minknow_api::device::GetTemperatureResponse>* stream_temperatureRaw(::grpc::ClientContext* context, const ::minknow_api::device::StreamTemperatureRequest& request) override;
    ::grpc::ClientAsyncReader< ::minknow_api::device::GetTemperatureResponse>* Asyncstream_temperatureRaw(::grpc::ClientContext* context, const ::minknow_api::device::StreamTemperatureRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::minknow_api::device::GetTemperatureResponse>* PrepareAsyncstream_temperatureRaw(::grpc::ClientContext* context, const ::minknow_api::device::StreamTemperatureRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::UnblockResponse>* AsyncunblockRaw(::grpc::ClientContext* context, const ::minknow_api::device::UnblockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::UnblockResponse>* PrepareAsyncunblockRaw(::grpc::ClientContext* context, const ::minknow_api::device::UnblockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::CancelUnblocksResponse>* Asynccancel_unblocksRaw(::grpc::ClientContext* context, const ::minknow_api::device::CancelUnblocksRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::CancelUnblocksResponse>* PrepareAsynccancel_unblocksRaw(::grpc::ClientContext* context, const ::minknow_api::device::CancelUnblocksRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetChannelConfigurationResponse>* Asyncget_channel_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::device::GetChannelConfigurationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetChannelConfigurationResponse>* PrepareAsyncget_channel_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::device::GetChannelConfigurationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetChannelConfigurationResponse>* Asyncset_channel_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::device::SetChannelConfigurationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetChannelConfigurationResponse>* PrepareAsyncset_channel_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::device::SetChannelConfigurationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetChannelConfigurationAllResponse>* Asyncset_channel_configuration_allRaw(::grpc::ClientContext* context, const ::minknow_api::device::SetChannelConfigurationAllRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetChannelConfigurationAllResponse>* PrepareAsyncset_channel_configuration_allRaw(::grpc::ClientContext* context, const ::minknow_api::device::SetChannelConfigurationAllRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetSaturationConfigResponse>* Asyncset_saturation_configRaw(::grpc::ClientContext* context, const ::minknow_api::device::SetSaturationConfigRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetSaturationConfigResponse>* PrepareAsyncset_saturation_configRaw(::grpc::ClientContext* context, const ::minknow_api::device::SetSaturationConfigRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetSaturationConfigResponse>* Asyncget_saturation_configRaw(::grpc::ClientContext* context, const ::minknow_api::device::GetSaturationConfigRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetSaturationConfigResponse>* PrepareAsyncget_saturation_configRaw(::grpc::ClientContext* context, const ::minknow_api::device::GetSaturationConfigRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetSampleRateResponse>* Asyncget_sample_rateRaw(::grpc::ClientContext* context, const ::minknow_api::device::GetSampleRateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetSampleRateResponse>* PrepareAsyncget_sample_rateRaw(::grpc::ClientContext* context, const ::minknow_api::device::GetSampleRateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetSampleRateResponse>* Asyncset_sample_rateRaw(::grpc::ClientContext* context, const ::minknow_api::device::SetSampleRateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetSampleRateResponse>* PrepareAsyncset_sample_rateRaw(::grpc::ClientContext* context, const ::minknow_api::device::SetSampleRateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetBiasVoltageResponse>* Asyncget_bias_voltageRaw(::grpc::ClientContext* context, const ::minknow_api::device::GetBiasVoltageRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::GetBiasVoltageResponse>* PrepareAsyncget_bias_voltageRaw(::grpc::ClientContext* context, const ::minknow_api::device::GetBiasVoltageRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetBiasVoltageResponse>* Asyncset_bias_voltageRaw(::grpc::ClientContext* context, const ::minknow_api::device::SetBiasVoltageRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::device::SetBiasVoltageResponse>* PrepareAsyncset_bias_voltageRaw(::grpc::ClientContext* context, const ::minknow_api::device::SetBiasVoltageRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_get_device_info_;
    const ::grpc::internal::RpcMethod rpcmethod_get_device_state_;
    const ::grpc::internal::RpcMethod rpcmethod_stream_device_state_;
    const ::grpc::internal::RpcMethod rpcmethod_get_flow_cell_info_;
    const ::grpc::internal::RpcMethod rpcmethod_stream_flow_cell_info_;
    const ::grpc::internal::RpcMethod rpcmethod_set_user_specified_flow_cell_id_;
    const ::grpc::internal::RpcMethod rpcmethod_set_user_specified_product_code_;
    const ::grpc::internal::RpcMethod rpcmethod_get_channels_layout_;
    const ::grpc::internal::RpcMethod rpcmethod_reset_device_settings_;
    const ::grpc::internal::RpcMethod rpcmethod_set_calibration_;
    const ::grpc::internal::RpcMethod rpcmethod_clear_calibration_;
    const ::grpc::internal::RpcMethod rpcmethod_get_calibration_;
    const ::grpc::internal::RpcMethod rpcmethod_set_temperature_;
    const ::grpc::internal::RpcMethod rpcmethod_get_temperature_;
    const ::grpc::internal::RpcMethod rpcmethod_stream_temperature_;
    const ::grpc::internal::RpcMethod rpcmethod_unblock_;
    const ::grpc::internal::RpcMethod rpcmethod_cancel_unblocks_;
    const ::grpc::internal::RpcMethod rpcmethod_get_channel_configuration_;
    const ::grpc::internal::RpcMethod rpcmethod_set_channel_configuration_;
    const ::grpc::internal::RpcMethod rpcmethod_set_channel_configuration_all_;
    const ::grpc::internal::RpcMethod rpcmethod_set_saturation_config_;
    const ::grpc::internal::RpcMethod rpcmethod_get_saturation_config_;
    const ::grpc::internal::RpcMethod rpcmethod_get_sample_rate_;
    const ::grpc::internal::RpcMethod rpcmethod_set_sample_rate_;
    const ::grpc::internal::RpcMethod rpcmethod_get_bias_voltage_;
    const ::grpc::internal::RpcMethod rpcmethod_set_bias_voltage_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Get information about the device this MinKNOW instance was started for.
    //
    // In normal circumstances (ie: when using the manager service), a new MinKNOW instance
    // is started for each available device. This call provides information about this device.
    //
    // The information returned by this call will not change (providing the MinKNOW instance
    // was started by the manager service).
    virtual ::grpc::Status get_device_info(::grpc::ServerContext* context, const ::minknow_api::device::GetDeviceInfoRequest* request, ::minknow_api::device::GetDeviceInfoResponse* response);
    // Get information about the current device state.
    //
    // Information in this call may change as the device is used with MinKNOW, for example,
    // by unplugging or plugging in the device.
    //
    // It includes information about whether the hardware is actually attached (in the case of
    // MinIONs, which can be unplugged), as well as what types of flow cells can be inserted (which
    // may be affected by flow cell adapters).
    //
    // Since 1.12
    virtual ::grpc::Status get_device_state(::grpc::ServerContext* context, const ::minknow_api::device::GetDeviceStateRequest* request, ::minknow_api::device::GetDeviceStateResponse* response);
    // Streaming version of get_device_state
    //
    // Since 1.13
    virtual ::grpc::Status stream_device_state(::grpc::ServerContext* context, const ::minknow_api::device::StreamDeviceStateRequest* request, ::grpc::ServerWriter< ::minknow_api::device::GetDeviceStateResponse>* writer);
    // Get information about the flow cell (if any).
    //
    // This provides information about the flow_cell attached to the device (described by
    // get_device_info()), if any.
    virtual ::grpc::Status get_flow_cell_info(::grpc::ServerContext* context, const ::minknow_api::device::GetFlowCellInfoRequest* request, ::minknow_api::device::GetFlowCellInfoResponse* response);
    // Streaming version of get_flow_cell_info
    //
    // Since 1.13
    virtual ::grpc::Status stream_flow_cell_info(::grpc::ServerContext* context, const ::minknow_api::device::StreamFlowCellInfoRequest* request, ::grpc::ServerWriter< ::minknow_api::device::GetFlowCellInfoResponse>* writer);
    // Set the user specified flow cell id.
    //
    // This changes the user specified flow cell id.
    // MinKNOW will use this id in place of the id read from the eeprom, if no eeprom data
    // is available.
    //
    // This data is reset when the flow cell is disconnected.
    //
    // Since 1.12
    virtual ::grpc::Status set_user_specified_flow_cell_id(::grpc::ServerContext* context, const ::minknow_api::device::SetUserSpecifiedFlowCellIdRequest* request, ::minknow_api::device::SetUserSpecifiedFlowCellIdResponse* response);
    // Set the user specified product code.
    //
    // This changes the user specified product code.
    //
    // MinKNOW does not use the product code, it is intended for use in MinKNOW's clients.
    //
    // This data is reset when the flow cell is disconnected.
    //
    // Since 1.12
    virtual ::grpc::Status set_user_specified_product_code(::grpc::ServerContext* context, const ::minknow_api::device::SetUserSpecifiedProductCodeRequest* request, ::minknow_api::device::SetUserSpecifiedProductCodeResponse* response);
    // Get information about the channel layout
    //
    // Since 1.14
    virtual ::grpc::Status get_channels_layout(::grpc::ServerContext* context, const ::minknow_api::device::GetChannelsLayoutRequest* request, ::minknow_api::device::GetChannelsLayoutResponse* response);
    // Reset all settings associate with the current device.
    //
    // This call will initialise all settings to their default state, ie the same as when MinKNOW boots.
    virtual ::grpc::Status reset_device_settings(::grpc::ServerContext* context, const ::minknow_api::device::ResetDeviceSettingsRequest* request, ::minknow_api::device::ResetDeviceSettingsResponse* response);
    // Set the calibration measurements to be used by MinKNOW.
    //
    // Calibration describes how to convert from the raw ADC (analog-to-digital converter) values
    // from the device into picoamps (pA).
    //
    // Note that calibration depends on the device, flow cell and some of the device settings
    // (including sampling frequency and the capacitance used in the integratation circuit). If
    // any of these are changed, the calibration will no longer be used. Instead, a previously-saved
    // calibration (for that combination of flow cell and settings) might be used, or the identity
    // calibration might be used.
    //
    // On a MinION, the settings that a calibration depends on are sampling frequency and
    // integration capacitor.
    virtual ::grpc::Status set_calibration(::grpc::ServerContext* context, const ::minknow_api::device::SetCalibrationRequest* request, ::minknow_api::device::SetCalibrationResponse* response);
    // Clear the current calibration.
    //
    // This is the same as setting the calibration to be the identity function (setting all offsets
    // to 0, and all pA ranges to the digitisation value).
    virtual ::grpc::Status clear_calibration(::grpc::ServerContext* context, const ::minknow_api::device::ClearCalibrationRequest* request, ::minknow_api::device::ClearCalibrationResponse* response);
    // The calibration measurements being used by MinKNOW.
    //
    // Calibration describes how to convert from the raw ADC (analog-to-digital converter) values
    // from the device into picoamps (pA).
    //
    // To get a pA value from an ADC value the following function is applied::
    //
    //      pA_current = (adc_current + offset) / (digitisation / pA_range)
    //
    // The digitisation is the range of possible ADC values. It is the same for all channels.
    //
    // If there is no calibration (including if it was cleared with ``clear_calibration()`` or
    // invalidated because of device settings changes), this will return the identity calibration:
    // all offsets will be 0, and the pA ranges will be the same as the digitisation.
    virtual ::grpc::Status get_calibration(::grpc::ServerContext* context, const ::minknow_api::device::GetCalibrationRequest* request, ::minknow_api::device::GetCalibrationResponse* response);
    // If the device is capable (see GetDeviceInfoResponse.temperature_controllable)
    // then this sets the minimum and maximum temperatures of the flow-cell.
    virtual ::grpc::Status set_temperature(::grpc::ServerContext* context, const ::minknow_api::device::SetTemperatureRequest* request, ::minknow_api::device::SetTemperatureResponse* response);
    // Get the current temperature of the device.
    //
    // Since 1.11
    virtual ::grpc::Status get_temperature(::grpc::ServerContext* context, const ::minknow_api::device::GetTemperatureRequest* request, ::minknow_api::device::GetTemperatureResponse* response);
    // Stream the current temperature of the device.
    //
    // Since 4.3
    virtual ::grpc::Status stream_temperature(::grpc::ServerContext* context, const ::minknow_api::device::StreamTemperatureRequest* request, ::grpc::ServerWriter< ::minknow_api::device::GetTemperatureResponse>* writer);
    // Triggers an unblock for a list of channels for a given duration (Please see UnblockRequest).
    // It will start an unblock for every channel received as a parameter, then this RPC returns.
    // After the timeout expires (the duration in seconds given in the request), the return from
    // unblock is automatically triggered, which resets the channel configuration (mux) to the
    // value preceding the unblock.
    //
    // Notes!!
    //
    // During the unblock the user should NOT do any mux changes, as the unblock will be interrupted.
    // On Promethion this would be even more complicated, as an unblock would normally restore
    // hardware saturation. If an unblock is interrupted it will not restore the state to the original
    // one.
    //
    // The user should NOT change the overload mode during an unblock - this will confuse the return from
    // unblock, which tries to reset the overload mode to the state preceeding the unblock.
    //
    // The unblock can fail if the channel is not in a valid well state (this means a channel needs to be
    // in one of pore1-4, not test current, regen pore or unblock). If a mux is not valid, the unblock grpc
    // will try to continue for the rest of the channels, ignoring the one with the wrong mux.
    virtual ::grpc::Status unblock(::grpc::ServerContext* context, const ::minknow_api::device::UnblockRequest* request, ::minknow_api::device::UnblockResponse* response);
    // Cancel in progress unblocks.
    //
    // Any unblocks registered with `device.unblock` will be stopped before this command returns.
    // Unblocks are stopped by applying any actions required to return from unblock (mux changes, or hardware configuration).
    //
    // Since 1.15
    virtual ::grpc::Status cancel_unblocks(::grpc::ServerContext* context, const ::minknow_api::device::CancelUnblocksRequest* request, ::minknow_api::device::CancelUnblocksResponse* response);
    // Get the channel configuration for any number of channels
    //
    // The maximum addressable channel will depend on the device. Currently this will be 512 on a MinION/GridION
    // and 3000 on a PromethION
    virtual ::grpc::Status get_channel_configuration(::grpc::ServerContext* context, const ::minknow_api::device::GetChannelConfigurationRequest* request, ::minknow_api::device::GetChannelConfigurationResponse* response);
    // Set the channel configuration for any number of channels
    //
    // The maximum addressable channel will depend on the device. Currently this will be 512 on a MinION/GridION
    // and 3000 on a PromethION.
    virtual ::grpc::Status set_channel_configuration(::grpc::ServerContext* context, const ::minknow_api::device::SetChannelConfigurationRequest* request, ::minknow_api::device::SetChannelConfigurationResponse* response);
    virtual ::grpc::Status set_channel_configuration_all(::grpc::ServerContext* context, const ::minknow_api::device::SetChannelConfigurationAllRequest* request, ::minknow_api::device::SetChannelConfigurationAllResponse* response);
    // Set the saturation control configuration.
    //
    // The request is immediately sent to the data acquisition module, and applied. All settings can be changed
    // whilst the experiment is running.
    //
    // If any keys are not specified when this method is called (see the message for specific optional parameters),
    // the previously applied parameters are kept; initially, when this method has never been called, defaults from the
    // application config are used.
    //
    // note: calling this method resets anu in-progress saturations when it is called, causing them to need to start
    // saturation counts again, this may mean any saturations may take longer to occur.
    virtual ::grpc::Status set_saturation_config(::grpc::ServerContext* context, const ::minknow_api::device::SetSaturationConfigRequest* request, ::minknow_api::device::SetSaturationConfigResponse* response);
    // Get the saturation control configuration.
    //
    // The default configuration is specifed by the MinKNOW application configuration, the command returns the most
    // recently applied saturation config.
    virtual ::grpc::Status get_saturation_config(::grpc::ServerContext* context, const ::minknow_api::device::GetSaturationConfigRequest* request, ::minknow_api::device::GetSaturationConfigResponse* response);
    // Get the sample rate of the device
    //
    // Please refer to MinionDeviceService and PromethionDeviceService for the expected
    // return value for a minion and promethion respectively
    virtual ::grpc::Status get_sample_rate(::grpc::ServerContext* context, const ::minknow_api::device::GetSampleRateRequest* request, ::minknow_api::device::GetSampleRateResponse* response);
    // Set the sample rate of the device, and returns the actual value set on the device
    //
    // Please refer to MinionDeviceService and PromethionDeviceService to see
    // how the value set here will be used to determine the real sample rate for a
    // minion and promethion respectively
    //
    // Trying to set the sample rate during an acquisition period will result in an error
    virtual ::grpc::Status set_sample_rate(::grpc::ServerContext* context, const ::minknow_api::device::SetSampleRateRequest* request, ::minknow_api::device::SetSampleRateResponse* response);
    virtual ::grpc::Status get_bias_voltage(::grpc::ServerContext* context, const ::minknow_api::device::GetBiasVoltageRequest* request, ::minknow_api::device::GetBiasVoltageResponse* response);
    virtual ::grpc::Status set_bias_voltage(::grpc::ServerContext* context, const ::minknow_api::device::SetBiasVoltageRequest* request, ::minknow_api::device::SetBiasVoltageResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_get_device_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_device_info() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_get_device_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_device_info(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetDeviceInfoRequest* /*request*/, ::minknow_api::device::GetDeviceInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_device_info(::grpc::ServerContext* context, ::minknow_api::device::GetDeviceInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::device::GetDeviceInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_device_state : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_device_state() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_get_device_state() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_device_state(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetDeviceStateRequest* /*request*/, ::minknow_api::device::GetDeviceStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_device_state(::grpc::ServerContext* context, ::minknow_api::device::GetDeviceStateRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::device::GetDeviceStateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_stream_device_state : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_stream_device_state() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_stream_device_state() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stream_device_state(::grpc::ServerContext* /*context*/, const ::minknow_api::device::StreamDeviceStateRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::device::GetDeviceStateResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requeststream_device_state(::grpc::ServerContext* context, ::minknow_api::device::StreamDeviceStateRequest* request, ::grpc::ServerAsyncWriter< ::minknow_api::device::GetDeviceStateResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(2, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_flow_cell_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_flow_cell_info() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_get_flow_cell_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_flow_cell_info(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetFlowCellInfoRequest* /*request*/, ::minknow_api::device::GetFlowCellInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_flow_cell_info(::grpc::ServerContext* context, ::minknow_api::device::GetFlowCellInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::device::GetFlowCellInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_stream_flow_cell_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_stream_flow_cell_info() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_stream_flow_cell_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stream_flow_cell_info(::grpc::ServerContext* /*context*/, const ::minknow_api::device::StreamFlowCellInfoRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::device::GetFlowCellInfoResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requeststream_flow_cell_info(::grpc::ServerContext* context, ::minknow_api::device::StreamFlowCellInfoRequest* request, ::grpc::ServerAsyncWriter< ::minknow_api::device::GetFlowCellInfoResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(4, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_set_user_specified_flow_cell_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_set_user_specified_flow_cell_id() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_set_user_specified_flow_cell_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_user_specified_flow_cell_id(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetUserSpecifiedFlowCellIdRequest* /*request*/, ::minknow_api::device::SetUserSpecifiedFlowCellIdResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_user_specified_flow_cell_id(::grpc::ServerContext* context, ::minknow_api::device::SetUserSpecifiedFlowCellIdRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::device::SetUserSpecifiedFlowCellIdResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_set_user_specified_product_code : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_set_user_specified_product_code() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_set_user_specified_product_code() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_user_specified_product_code(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetUserSpecifiedProductCodeRequest* /*request*/, ::minknow_api::device::SetUserSpecifiedProductCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_user_specified_product_code(::grpc::ServerContext* context, ::minknow_api::device::SetUserSpecifiedProductCodeRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::device::SetUserSpecifiedProductCodeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_channels_layout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_channels_layout() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_get_channels_layout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_channels_layout(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetChannelsLayoutRequest* /*request*/, ::minknow_api::device::GetChannelsLayoutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_channels_layout(::grpc::ServerContext* context, ::minknow_api::device::GetChannelsLayoutRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::device::GetChannelsLayoutResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_reset_device_settings : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_reset_device_settings() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_reset_device_settings() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status reset_device_settings(::grpc::ServerContext* /*context*/, const ::minknow_api::device::ResetDeviceSettingsRequest* /*request*/, ::minknow_api::device::ResetDeviceSettingsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestreset_device_settings(::grpc::ServerContext* context, ::minknow_api::device::ResetDeviceSettingsRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::device::ResetDeviceSettingsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_set_calibration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_set_calibration() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_set_calibration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_calibration(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetCalibrationRequest* /*request*/, ::minknow_api::device::SetCalibrationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_calibration(::grpc::ServerContext* context, ::minknow_api::device::SetCalibrationRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::device::SetCalibrationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_clear_calibration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_clear_calibration() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_clear_calibration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clear_calibration(::grpc::ServerContext* /*context*/, const ::minknow_api::device::ClearCalibrationRequest* /*request*/, ::minknow_api::device::ClearCalibrationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestclear_calibration(::grpc::ServerContext* context, ::minknow_api::device::ClearCalibrationRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::device::ClearCalibrationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_calibration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_calibration() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_get_calibration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_calibration(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetCalibrationRequest* /*request*/, ::minknow_api::device::GetCalibrationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_calibration(::grpc::ServerContext* context, ::minknow_api::device::GetCalibrationRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::device::GetCalibrationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_set_temperature : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_set_temperature() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_set_temperature() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_temperature(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetTemperatureRequest* /*request*/, ::minknow_api::device::SetTemperatureResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_temperature(::grpc::ServerContext* context, ::minknow_api::device::SetTemperatureRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::device::SetTemperatureResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_temperature : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_temperature() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_get_temperature() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_temperature(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetTemperatureRequest* /*request*/, ::minknow_api::device::GetTemperatureResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_temperature(::grpc::ServerContext* context, ::minknow_api::device::GetTemperatureRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::device::GetTemperatureResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_stream_temperature : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_stream_temperature() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_stream_temperature() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stream_temperature(::grpc::ServerContext* /*context*/, const ::minknow_api::device::StreamTemperatureRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::device::GetTemperatureResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requeststream_temperature(::grpc::ServerContext* context, ::minknow_api::device::StreamTemperatureRequest* request, ::grpc::ServerAsyncWriter< ::minknow_api::device::GetTemperatureResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(14, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_unblock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_unblock() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_unblock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status unblock(::grpc::ServerContext* /*context*/, const ::minknow_api::device::UnblockRequest* /*request*/, ::minknow_api::device::UnblockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestunblock(::grpc::ServerContext* context, ::minknow_api::device::UnblockRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::device::UnblockResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_cancel_unblocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_cancel_unblocks() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_cancel_unblocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status cancel_unblocks(::grpc::ServerContext* /*context*/, const ::minknow_api::device::CancelUnblocksRequest* /*request*/, ::minknow_api::device::CancelUnblocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestcancel_unblocks(::grpc::ServerContext* context, ::minknow_api::device::CancelUnblocksRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::device::CancelUnblocksResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_channel_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_channel_configuration() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_get_channel_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_channel_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetChannelConfigurationRequest* /*request*/, ::minknow_api::device::GetChannelConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_channel_configuration(::grpc::ServerContext* context, ::minknow_api::device::GetChannelConfigurationRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::device::GetChannelConfigurationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_set_channel_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_set_channel_configuration() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_set_channel_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_channel_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetChannelConfigurationRequest* /*request*/, ::minknow_api::device::SetChannelConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_channel_configuration(::grpc::ServerContext* context, ::minknow_api::device::SetChannelConfigurationRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::device::SetChannelConfigurationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_set_channel_configuration_all : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_set_channel_configuration_all() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_set_channel_configuration_all() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_channel_configuration_all(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetChannelConfigurationAllRequest* /*request*/, ::minknow_api::device::SetChannelConfigurationAllResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_channel_configuration_all(::grpc::ServerContext* context, ::minknow_api::device::SetChannelConfigurationAllRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::device::SetChannelConfigurationAllResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_set_saturation_config : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_set_saturation_config() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_set_saturation_config() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_saturation_config(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetSaturationConfigRequest* /*request*/, ::minknow_api::device::SetSaturationConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_saturation_config(::grpc::ServerContext* context, ::minknow_api::device::SetSaturationConfigRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::device::SetSaturationConfigResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_saturation_config : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_saturation_config() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_get_saturation_config() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_saturation_config(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetSaturationConfigRequest* /*request*/, ::minknow_api::device::GetSaturationConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_saturation_config(::grpc::ServerContext* context, ::minknow_api::device::GetSaturationConfigRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::device::GetSaturationConfigResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_sample_rate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_sample_rate() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_get_sample_rate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_sample_rate(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetSampleRateRequest* /*request*/, ::minknow_api::device::GetSampleRateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_sample_rate(::grpc::ServerContext* context, ::minknow_api::device::GetSampleRateRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::device::GetSampleRateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_set_sample_rate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_set_sample_rate() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_set_sample_rate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_sample_rate(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetSampleRateRequest* /*request*/, ::minknow_api::device::SetSampleRateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_sample_rate(::grpc::ServerContext* context, ::minknow_api::device::SetSampleRateRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::device::SetSampleRateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_bias_voltage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_bias_voltage() {
      ::grpc::Service::MarkMethodAsync(24);
    }
    ~WithAsyncMethod_get_bias_voltage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_bias_voltage(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetBiasVoltageRequest* /*request*/, ::minknow_api::device::GetBiasVoltageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_bias_voltage(::grpc::ServerContext* context, ::minknow_api::device::GetBiasVoltageRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::device::GetBiasVoltageResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_set_bias_voltage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_set_bias_voltage() {
      ::grpc::Service::MarkMethodAsync(25);
    }
    ~WithAsyncMethod_set_bias_voltage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_bias_voltage(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetBiasVoltageRequest* /*request*/, ::minknow_api::device::SetBiasVoltageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_bias_voltage(::grpc::ServerContext* context, ::minknow_api::device::SetBiasVoltageRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::device::SetBiasVoltageResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_get_device_info<WithAsyncMethod_get_device_state<WithAsyncMethod_stream_device_state<WithAsyncMethod_get_flow_cell_info<WithAsyncMethod_stream_flow_cell_info<WithAsyncMethod_set_user_specified_flow_cell_id<WithAsyncMethod_set_user_specified_product_code<WithAsyncMethod_get_channels_layout<WithAsyncMethod_reset_device_settings<WithAsyncMethod_set_calibration<WithAsyncMethod_clear_calibration<WithAsyncMethod_get_calibration<WithAsyncMethod_set_temperature<WithAsyncMethod_get_temperature<WithAsyncMethod_stream_temperature<WithAsyncMethod_unblock<WithAsyncMethod_cancel_unblocks<WithAsyncMethod_get_channel_configuration<WithAsyncMethod_set_channel_configuration<WithAsyncMethod_set_channel_configuration_all<WithAsyncMethod_set_saturation_config<WithAsyncMethod_get_saturation_config<WithAsyncMethod_get_sample_rate<WithAsyncMethod_set_sample_rate<WithAsyncMethod_get_bias_voltage<WithAsyncMethod_set_bias_voltage<Service > > > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_get_device_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_device_info() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::GetDeviceInfoRequest, ::minknow_api::device::GetDeviceInfoResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::device::GetDeviceInfoRequest* request, ::minknow_api::device::GetDeviceInfoResponse* response) { return this->get_device_info(context, request, response); }));}
    void SetMessageAllocatorFor_get_device_info(
        ::grpc::MessageAllocator< ::minknow_api::device::GetDeviceInfoRequest, ::minknow_api::device::GetDeviceInfoResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::GetDeviceInfoRequest, ::minknow_api::device::GetDeviceInfoResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_device_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_device_info(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetDeviceInfoRequest* /*request*/, ::minknow_api::device::GetDeviceInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_device_info(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::device::GetDeviceInfoRequest* /*request*/, ::minknow_api::device::GetDeviceInfoResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_device_state : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_device_state() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::GetDeviceStateRequest, ::minknow_api::device::GetDeviceStateResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::device::GetDeviceStateRequest* request, ::minknow_api::device::GetDeviceStateResponse* response) { return this->get_device_state(context, request, response); }));}
    void SetMessageAllocatorFor_get_device_state(
        ::grpc::MessageAllocator< ::minknow_api::device::GetDeviceStateRequest, ::minknow_api::device::GetDeviceStateResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::GetDeviceStateRequest, ::minknow_api::device::GetDeviceStateResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_device_state() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_device_state(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetDeviceStateRequest* /*request*/, ::minknow_api::device::GetDeviceStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_device_state(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::device::GetDeviceStateRequest* /*request*/, ::minknow_api::device::GetDeviceStateResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_stream_device_state : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_stream_device_state() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackServerStreamingHandler< ::minknow_api::device::StreamDeviceStateRequest, ::minknow_api::device::GetDeviceStateResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::device::StreamDeviceStateRequest* request) { return this->stream_device_state(context, request); }));
    }
    ~WithCallbackMethod_stream_device_state() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stream_device_state(::grpc::ServerContext* /*context*/, const ::minknow_api::device::StreamDeviceStateRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::device::GetDeviceStateResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::minknow_api::device::GetDeviceStateResponse>* stream_device_state(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::device::StreamDeviceStateRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_flow_cell_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_flow_cell_info() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::GetFlowCellInfoRequest, ::minknow_api::device::GetFlowCellInfoResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::device::GetFlowCellInfoRequest* request, ::minknow_api::device::GetFlowCellInfoResponse* response) { return this->get_flow_cell_info(context, request, response); }));}
    void SetMessageAllocatorFor_get_flow_cell_info(
        ::grpc::MessageAllocator< ::minknow_api::device::GetFlowCellInfoRequest, ::minknow_api::device::GetFlowCellInfoResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::GetFlowCellInfoRequest, ::minknow_api::device::GetFlowCellInfoResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_flow_cell_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_flow_cell_info(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetFlowCellInfoRequest* /*request*/, ::minknow_api::device::GetFlowCellInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_flow_cell_info(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::device::GetFlowCellInfoRequest* /*request*/, ::minknow_api::device::GetFlowCellInfoResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_stream_flow_cell_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_stream_flow_cell_info() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackServerStreamingHandler< ::minknow_api::device::StreamFlowCellInfoRequest, ::minknow_api::device::GetFlowCellInfoResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::device::StreamFlowCellInfoRequest* request) { return this->stream_flow_cell_info(context, request); }));
    }
    ~WithCallbackMethod_stream_flow_cell_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stream_flow_cell_info(::grpc::ServerContext* /*context*/, const ::minknow_api::device::StreamFlowCellInfoRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::device::GetFlowCellInfoResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::minknow_api::device::GetFlowCellInfoResponse>* stream_flow_cell_info(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::device::StreamFlowCellInfoRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_set_user_specified_flow_cell_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_set_user_specified_flow_cell_id() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::SetUserSpecifiedFlowCellIdRequest, ::minknow_api::device::SetUserSpecifiedFlowCellIdResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::device::SetUserSpecifiedFlowCellIdRequest* request, ::minknow_api::device::SetUserSpecifiedFlowCellIdResponse* response) { return this->set_user_specified_flow_cell_id(context, request, response); }));}
    void SetMessageAllocatorFor_set_user_specified_flow_cell_id(
        ::grpc::MessageAllocator< ::minknow_api::device::SetUserSpecifiedFlowCellIdRequest, ::minknow_api::device::SetUserSpecifiedFlowCellIdResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::SetUserSpecifiedFlowCellIdRequest, ::minknow_api::device::SetUserSpecifiedFlowCellIdResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_set_user_specified_flow_cell_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_user_specified_flow_cell_id(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetUserSpecifiedFlowCellIdRequest* /*request*/, ::minknow_api::device::SetUserSpecifiedFlowCellIdResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_user_specified_flow_cell_id(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::device::SetUserSpecifiedFlowCellIdRequest* /*request*/, ::minknow_api::device::SetUserSpecifiedFlowCellIdResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_set_user_specified_product_code : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_set_user_specified_product_code() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::SetUserSpecifiedProductCodeRequest, ::minknow_api::device::SetUserSpecifiedProductCodeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::device::SetUserSpecifiedProductCodeRequest* request, ::minknow_api::device::SetUserSpecifiedProductCodeResponse* response) { return this->set_user_specified_product_code(context, request, response); }));}
    void SetMessageAllocatorFor_set_user_specified_product_code(
        ::grpc::MessageAllocator< ::minknow_api::device::SetUserSpecifiedProductCodeRequest, ::minknow_api::device::SetUserSpecifiedProductCodeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::SetUserSpecifiedProductCodeRequest, ::minknow_api::device::SetUserSpecifiedProductCodeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_set_user_specified_product_code() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_user_specified_product_code(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetUserSpecifiedProductCodeRequest* /*request*/, ::minknow_api::device::SetUserSpecifiedProductCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_user_specified_product_code(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::device::SetUserSpecifiedProductCodeRequest* /*request*/, ::minknow_api::device::SetUserSpecifiedProductCodeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_channels_layout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_channels_layout() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::GetChannelsLayoutRequest, ::minknow_api::device::GetChannelsLayoutResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::device::GetChannelsLayoutRequest* request, ::minknow_api::device::GetChannelsLayoutResponse* response) { return this->get_channels_layout(context, request, response); }));}
    void SetMessageAllocatorFor_get_channels_layout(
        ::grpc::MessageAllocator< ::minknow_api::device::GetChannelsLayoutRequest, ::minknow_api::device::GetChannelsLayoutResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::GetChannelsLayoutRequest, ::minknow_api::device::GetChannelsLayoutResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_channels_layout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_channels_layout(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetChannelsLayoutRequest* /*request*/, ::minknow_api::device::GetChannelsLayoutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_channels_layout(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::device::GetChannelsLayoutRequest* /*request*/, ::minknow_api::device::GetChannelsLayoutResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_reset_device_settings : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_reset_device_settings() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::ResetDeviceSettingsRequest, ::minknow_api::device::ResetDeviceSettingsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::device::ResetDeviceSettingsRequest* request, ::minknow_api::device::ResetDeviceSettingsResponse* response) { return this->reset_device_settings(context, request, response); }));}
    void SetMessageAllocatorFor_reset_device_settings(
        ::grpc::MessageAllocator< ::minknow_api::device::ResetDeviceSettingsRequest, ::minknow_api::device::ResetDeviceSettingsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::ResetDeviceSettingsRequest, ::minknow_api::device::ResetDeviceSettingsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_reset_device_settings() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status reset_device_settings(::grpc::ServerContext* /*context*/, const ::minknow_api::device::ResetDeviceSettingsRequest* /*request*/, ::minknow_api::device::ResetDeviceSettingsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* reset_device_settings(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::device::ResetDeviceSettingsRequest* /*request*/, ::minknow_api::device::ResetDeviceSettingsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_set_calibration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_set_calibration() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::SetCalibrationRequest, ::minknow_api::device::SetCalibrationResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::device::SetCalibrationRequest* request, ::minknow_api::device::SetCalibrationResponse* response) { return this->set_calibration(context, request, response); }));}
    void SetMessageAllocatorFor_set_calibration(
        ::grpc::MessageAllocator< ::minknow_api::device::SetCalibrationRequest, ::minknow_api::device::SetCalibrationResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::SetCalibrationRequest, ::minknow_api::device::SetCalibrationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_set_calibration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_calibration(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetCalibrationRequest* /*request*/, ::minknow_api::device::SetCalibrationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_calibration(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::device::SetCalibrationRequest* /*request*/, ::minknow_api::device::SetCalibrationResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_clear_calibration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_clear_calibration() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::ClearCalibrationRequest, ::minknow_api::device::ClearCalibrationResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::device::ClearCalibrationRequest* request, ::minknow_api::device::ClearCalibrationResponse* response) { return this->clear_calibration(context, request, response); }));}
    void SetMessageAllocatorFor_clear_calibration(
        ::grpc::MessageAllocator< ::minknow_api::device::ClearCalibrationRequest, ::minknow_api::device::ClearCalibrationResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::ClearCalibrationRequest, ::minknow_api::device::ClearCalibrationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_clear_calibration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clear_calibration(::grpc::ServerContext* /*context*/, const ::minknow_api::device::ClearCalibrationRequest* /*request*/, ::minknow_api::device::ClearCalibrationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* clear_calibration(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::device::ClearCalibrationRequest* /*request*/, ::minknow_api::device::ClearCalibrationResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_calibration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_calibration() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::GetCalibrationRequest, ::minknow_api::device::GetCalibrationResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::device::GetCalibrationRequest* request, ::minknow_api::device::GetCalibrationResponse* response) { return this->get_calibration(context, request, response); }));}
    void SetMessageAllocatorFor_get_calibration(
        ::grpc::MessageAllocator< ::minknow_api::device::GetCalibrationRequest, ::minknow_api::device::GetCalibrationResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::GetCalibrationRequest, ::minknow_api::device::GetCalibrationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_calibration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_calibration(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetCalibrationRequest* /*request*/, ::minknow_api::device::GetCalibrationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_calibration(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::device::GetCalibrationRequest* /*request*/, ::minknow_api::device::GetCalibrationResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_set_temperature : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_set_temperature() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::SetTemperatureRequest, ::minknow_api::device::SetTemperatureResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::device::SetTemperatureRequest* request, ::minknow_api::device::SetTemperatureResponse* response) { return this->set_temperature(context, request, response); }));}
    void SetMessageAllocatorFor_set_temperature(
        ::grpc::MessageAllocator< ::minknow_api::device::SetTemperatureRequest, ::minknow_api::device::SetTemperatureResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::SetTemperatureRequest, ::minknow_api::device::SetTemperatureResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_set_temperature() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_temperature(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetTemperatureRequest* /*request*/, ::minknow_api::device::SetTemperatureResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_temperature(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::device::SetTemperatureRequest* /*request*/, ::minknow_api::device::SetTemperatureResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_temperature : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_temperature() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::GetTemperatureRequest, ::minknow_api::device::GetTemperatureResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::device::GetTemperatureRequest* request, ::minknow_api::device::GetTemperatureResponse* response) { return this->get_temperature(context, request, response); }));}
    void SetMessageAllocatorFor_get_temperature(
        ::grpc::MessageAllocator< ::minknow_api::device::GetTemperatureRequest, ::minknow_api::device::GetTemperatureResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::GetTemperatureRequest, ::minknow_api::device::GetTemperatureResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_temperature() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_temperature(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetTemperatureRequest* /*request*/, ::minknow_api::device::GetTemperatureResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_temperature(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::device::GetTemperatureRequest* /*request*/, ::minknow_api::device::GetTemperatureResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_stream_temperature : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_stream_temperature() {
      ::grpc::Service::MarkMethodCallback(14,
          new ::grpc::internal::CallbackServerStreamingHandler< ::minknow_api::device::StreamTemperatureRequest, ::minknow_api::device::GetTemperatureResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::device::StreamTemperatureRequest* request) { return this->stream_temperature(context, request); }));
    }
    ~WithCallbackMethod_stream_temperature() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stream_temperature(::grpc::ServerContext* /*context*/, const ::minknow_api::device::StreamTemperatureRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::device::GetTemperatureResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::minknow_api::device::GetTemperatureResponse>* stream_temperature(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::device::StreamTemperatureRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_unblock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_unblock() {
      ::grpc::Service::MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::UnblockRequest, ::minknow_api::device::UnblockResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::device::UnblockRequest* request, ::minknow_api::device::UnblockResponse* response) { return this->unblock(context, request, response); }));}
    void SetMessageAllocatorFor_unblock(
        ::grpc::MessageAllocator< ::minknow_api::device::UnblockRequest, ::minknow_api::device::UnblockResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::UnblockRequest, ::minknow_api::device::UnblockResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_unblock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status unblock(::grpc::ServerContext* /*context*/, const ::minknow_api::device::UnblockRequest* /*request*/, ::minknow_api::device::UnblockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* unblock(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::device::UnblockRequest* /*request*/, ::minknow_api::device::UnblockResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_cancel_unblocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_cancel_unblocks() {
      ::grpc::Service::MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::CancelUnblocksRequest, ::minknow_api::device::CancelUnblocksResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::device::CancelUnblocksRequest* request, ::minknow_api::device::CancelUnblocksResponse* response) { return this->cancel_unblocks(context, request, response); }));}
    void SetMessageAllocatorFor_cancel_unblocks(
        ::grpc::MessageAllocator< ::minknow_api::device::CancelUnblocksRequest, ::minknow_api::device::CancelUnblocksResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::CancelUnblocksRequest, ::minknow_api::device::CancelUnblocksResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_cancel_unblocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status cancel_unblocks(::grpc::ServerContext* /*context*/, const ::minknow_api::device::CancelUnblocksRequest* /*request*/, ::minknow_api::device::CancelUnblocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* cancel_unblocks(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::device::CancelUnblocksRequest* /*request*/, ::minknow_api::device::CancelUnblocksResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_channel_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_channel_configuration() {
      ::grpc::Service::MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::GetChannelConfigurationRequest, ::minknow_api::device::GetChannelConfigurationResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::device::GetChannelConfigurationRequest* request, ::minknow_api::device::GetChannelConfigurationResponse* response) { return this->get_channel_configuration(context, request, response); }));}
    void SetMessageAllocatorFor_get_channel_configuration(
        ::grpc::MessageAllocator< ::minknow_api::device::GetChannelConfigurationRequest, ::minknow_api::device::GetChannelConfigurationResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::GetChannelConfigurationRequest, ::minknow_api::device::GetChannelConfigurationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_channel_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_channel_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetChannelConfigurationRequest* /*request*/, ::minknow_api::device::GetChannelConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_channel_configuration(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::device::GetChannelConfigurationRequest* /*request*/, ::minknow_api::device::GetChannelConfigurationResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_set_channel_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_set_channel_configuration() {
      ::grpc::Service::MarkMethodCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::SetChannelConfigurationRequest, ::minknow_api::device::SetChannelConfigurationResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::device::SetChannelConfigurationRequest* request, ::minknow_api::device::SetChannelConfigurationResponse* response) { return this->set_channel_configuration(context, request, response); }));}
    void SetMessageAllocatorFor_set_channel_configuration(
        ::grpc::MessageAllocator< ::minknow_api::device::SetChannelConfigurationRequest, ::minknow_api::device::SetChannelConfigurationResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::SetChannelConfigurationRequest, ::minknow_api::device::SetChannelConfigurationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_set_channel_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_channel_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetChannelConfigurationRequest* /*request*/, ::minknow_api::device::SetChannelConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_channel_configuration(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::device::SetChannelConfigurationRequest* /*request*/, ::minknow_api::device::SetChannelConfigurationResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_set_channel_configuration_all : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_set_channel_configuration_all() {
      ::grpc::Service::MarkMethodCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::SetChannelConfigurationAllRequest, ::minknow_api::device::SetChannelConfigurationAllResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::device::SetChannelConfigurationAllRequest* request, ::minknow_api::device::SetChannelConfigurationAllResponse* response) { return this->set_channel_configuration_all(context, request, response); }));}
    void SetMessageAllocatorFor_set_channel_configuration_all(
        ::grpc::MessageAllocator< ::minknow_api::device::SetChannelConfigurationAllRequest, ::minknow_api::device::SetChannelConfigurationAllResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(19);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::SetChannelConfigurationAllRequest, ::minknow_api::device::SetChannelConfigurationAllResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_set_channel_configuration_all() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_channel_configuration_all(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetChannelConfigurationAllRequest* /*request*/, ::minknow_api::device::SetChannelConfigurationAllResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_channel_configuration_all(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::device::SetChannelConfigurationAllRequest* /*request*/, ::minknow_api::device::SetChannelConfigurationAllResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_set_saturation_config : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_set_saturation_config() {
      ::grpc::Service::MarkMethodCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::SetSaturationConfigRequest, ::minknow_api::device::SetSaturationConfigResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::device::SetSaturationConfigRequest* request, ::minknow_api::device::SetSaturationConfigResponse* response) { return this->set_saturation_config(context, request, response); }));}
    void SetMessageAllocatorFor_set_saturation_config(
        ::grpc::MessageAllocator< ::minknow_api::device::SetSaturationConfigRequest, ::minknow_api::device::SetSaturationConfigResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(20);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::SetSaturationConfigRequest, ::minknow_api::device::SetSaturationConfigResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_set_saturation_config() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_saturation_config(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetSaturationConfigRequest* /*request*/, ::minknow_api::device::SetSaturationConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_saturation_config(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::device::SetSaturationConfigRequest* /*request*/, ::minknow_api::device::SetSaturationConfigResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_saturation_config : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_saturation_config() {
      ::grpc::Service::MarkMethodCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::GetSaturationConfigRequest, ::minknow_api::device::GetSaturationConfigResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::device::GetSaturationConfigRequest* request, ::minknow_api::device::GetSaturationConfigResponse* response) { return this->get_saturation_config(context, request, response); }));}
    void SetMessageAllocatorFor_get_saturation_config(
        ::grpc::MessageAllocator< ::minknow_api::device::GetSaturationConfigRequest, ::minknow_api::device::GetSaturationConfigResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(21);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::GetSaturationConfigRequest, ::minknow_api::device::GetSaturationConfigResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_saturation_config() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_saturation_config(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetSaturationConfigRequest* /*request*/, ::minknow_api::device::GetSaturationConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_saturation_config(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::device::GetSaturationConfigRequest* /*request*/, ::minknow_api::device::GetSaturationConfigResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_sample_rate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_sample_rate() {
      ::grpc::Service::MarkMethodCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::GetSampleRateRequest, ::minknow_api::device::GetSampleRateResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::device::GetSampleRateRequest* request, ::minknow_api::device::GetSampleRateResponse* response) { return this->get_sample_rate(context, request, response); }));}
    void SetMessageAllocatorFor_get_sample_rate(
        ::grpc::MessageAllocator< ::minknow_api::device::GetSampleRateRequest, ::minknow_api::device::GetSampleRateResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(22);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::GetSampleRateRequest, ::minknow_api::device::GetSampleRateResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_sample_rate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_sample_rate(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetSampleRateRequest* /*request*/, ::minknow_api::device::GetSampleRateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_sample_rate(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::device::GetSampleRateRequest* /*request*/, ::minknow_api::device::GetSampleRateResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_set_sample_rate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_set_sample_rate() {
      ::grpc::Service::MarkMethodCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::SetSampleRateRequest, ::minknow_api::device::SetSampleRateResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::device::SetSampleRateRequest* request, ::minknow_api::device::SetSampleRateResponse* response) { return this->set_sample_rate(context, request, response); }));}
    void SetMessageAllocatorFor_set_sample_rate(
        ::grpc::MessageAllocator< ::minknow_api::device::SetSampleRateRequest, ::minknow_api::device::SetSampleRateResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(23);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::SetSampleRateRequest, ::minknow_api::device::SetSampleRateResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_set_sample_rate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_sample_rate(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetSampleRateRequest* /*request*/, ::minknow_api::device::SetSampleRateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_sample_rate(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::device::SetSampleRateRequest* /*request*/, ::minknow_api::device::SetSampleRateResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_bias_voltage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_bias_voltage() {
      ::grpc::Service::MarkMethodCallback(24,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::GetBiasVoltageRequest, ::minknow_api::device::GetBiasVoltageResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::device::GetBiasVoltageRequest* request, ::minknow_api::device::GetBiasVoltageResponse* response) { return this->get_bias_voltage(context, request, response); }));}
    void SetMessageAllocatorFor_get_bias_voltage(
        ::grpc::MessageAllocator< ::minknow_api::device::GetBiasVoltageRequest, ::minknow_api::device::GetBiasVoltageResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(24);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::GetBiasVoltageRequest, ::minknow_api::device::GetBiasVoltageResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_bias_voltage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_bias_voltage(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetBiasVoltageRequest* /*request*/, ::minknow_api::device::GetBiasVoltageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_bias_voltage(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::device::GetBiasVoltageRequest* /*request*/, ::minknow_api::device::GetBiasVoltageResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_set_bias_voltage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_set_bias_voltage() {
      ::grpc::Service::MarkMethodCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::SetBiasVoltageRequest, ::minknow_api::device::SetBiasVoltageResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::device::SetBiasVoltageRequest* request, ::minknow_api::device::SetBiasVoltageResponse* response) { return this->set_bias_voltage(context, request, response); }));}
    void SetMessageAllocatorFor_set_bias_voltage(
        ::grpc::MessageAllocator< ::minknow_api::device::SetBiasVoltageRequest, ::minknow_api::device::SetBiasVoltageResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(25);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::device::SetBiasVoltageRequest, ::minknow_api::device::SetBiasVoltageResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_set_bias_voltage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_bias_voltage(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetBiasVoltageRequest* /*request*/, ::minknow_api::device::SetBiasVoltageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_bias_voltage(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::device::SetBiasVoltageRequest* /*request*/, ::minknow_api::device::SetBiasVoltageResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_get_device_info<WithCallbackMethod_get_device_state<WithCallbackMethod_stream_device_state<WithCallbackMethod_get_flow_cell_info<WithCallbackMethod_stream_flow_cell_info<WithCallbackMethod_set_user_specified_flow_cell_id<WithCallbackMethod_set_user_specified_product_code<WithCallbackMethod_get_channels_layout<WithCallbackMethod_reset_device_settings<WithCallbackMethod_set_calibration<WithCallbackMethod_clear_calibration<WithCallbackMethod_get_calibration<WithCallbackMethod_set_temperature<WithCallbackMethod_get_temperature<WithCallbackMethod_stream_temperature<WithCallbackMethod_unblock<WithCallbackMethod_cancel_unblocks<WithCallbackMethod_get_channel_configuration<WithCallbackMethod_set_channel_configuration<WithCallbackMethod_set_channel_configuration_all<WithCallbackMethod_set_saturation_config<WithCallbackMethod_get_saturation_config<WithCallbackMethod_get_sample_rate<WithCallbackMethod_set_sample_rate<WithCallbackMethod_get_bias_voltage<WithCallbackMethod_set_bias_voltage<Service > > > > > > > > > > > > > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_get_device_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_device_info() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_get_device_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_device_info(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetDeviceInfoRequest* /*request*/, ::minknow_api::device::GetDeviceInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_device_state : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_device_state() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_get_device_state() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_device_state(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetDeviceStateRequest* /*request*/, ::minknow_api::device::GetDeviceStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_stream_device_state : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_stream_device_state() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_stream_device_state() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stream_device_state(::grpc::ServerContext* /*context*/, const ::minknow_api::device::StreamDeviceStateRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::device::GetDeviceStateResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_flow_cell_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_flow_cell_info() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_get_flow_cell_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_flow_cell_info(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetFlowCellInfoRequest* /*request*/, ::minknow_api::device::GetFlowCellInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_stream_flow_cell_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_stream_flow_cell_info() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_stream_flow_cell_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stream_flow_cell_info(::grpc::ServerContext* /*context*/, const ::minknow_api::device::StreamFlowCellInfoRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::device::GetFlowCellInfoResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_set_user_specified_flow_cell_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_set_user_specified_flow_cell_id() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_set_user_specified_flow_cell_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_user_specified_flow_cell_id(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetUserSpecifiedFlowCellIdRequest* /*request*/, ::minknow_api::device::SetUserSpecifiedFlowCellIdResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_set_user_specified_product_code : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_set_user_specified_product_code() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_set_user_specified_product_code() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_user_specified_product_code(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetUserSpecifiedProductCodeRequest* /*request*/, ::minknow_api::device::SetUserSpecifiedProductCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_channels_layout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_channels_layout() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_get_channels_layout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_channels_layout(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetChannelsLayoutRequest* /*request*/, ::minknow_api::device::GetChannelsLayoutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_reset_device_settings : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_reset_device_settings() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_reset_device_settings() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status reset_device_settings(::grpc::ServerContext* /*context*/, const ::minknow_api::device::ResetDeviceSettingsRequest* /*request*/, ::minknow_api::device::ResetDeviceSettingsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_set_calibration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_set_calibration() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_set_calibration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_calibration(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetCalibrationRequest* /*request*/, ::minknow_api::device::SetCalibrationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_clear_calibration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_clear_calibration() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_clear_calibration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clear_calibration(::grpc::ServerContext* /*context*/, const ::minknow_api::device::ClearCalibrationRequest* /*request*/, ::minknow_api::device::ClearCalibrationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_calibration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_calibration() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_get_calibration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_calibration(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetCalibrationRequest* /*request*/, ::minknow_api::device::GetCalibrationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_set_temperature : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_set_temperature() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_set_temperature() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_temperature(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetTemperatureRequest* /*request*/, ::minknow_api::device::SetTemperatureResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_temperature : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_temperature() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_get_temperature() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_temperature(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetTemperatureRequest* /*request*/, ::minknow_api::device::GetTemperatureResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_stream_temperature : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_stream_temperature() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_stream_temperature() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stream_temperature(::grpc::ServerContext* /*context*/, const ::minknow_api::device::StreamTemperatureRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::device::GetTemperatureResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_unblock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_unblock() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_unblock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status unblock(::grpc::ServerContext* /*context*/, const ::minknow_api::device::UnblockRequest* /*request*/, ::minknow_api::device::UnblockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_cancel_unblocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_cancel_unblocks() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_cancel_unblocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status cancel_unblocks(::grpc::ServerContext* /*context*/, const ::minknow_api::device::CancelUnblocksRequest* /*request*/, ::minknow_api::device::CancelUnblocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_channel_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_channel_configuration() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_get_channel_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_channel_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetChannelConfigurationRequest* /*request*/, ::minknow_api::device::GetChannelConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_set_channel_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_set_channel_configuration() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_set_channel_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_channel_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetChannelConfigurationRequest* /*request*/, ::minknow_api::device::SetChannelConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_set_channel_configuration_all : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_set_channel_configuration_all() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_set_channel_configuration_all() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_channel_configuration_all(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetChannelConfigurationAllRequest* /*request*/, ::minknow_api::device::SetChannelConfigurationAllResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_set_saturation_config : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_set_saturation_config() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_set_saturation_config() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_saturation_config(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetSaturationConfigRequest* /*request*/, ::minknow_api::device::SetSaturationConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_saturation_config : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_saturation_config() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_get_saturation_config() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_saturation_config(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetSaturationConfigRequest* /*request*/, ::minknow_api::device::GetSaturationConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_sample_rate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_sample_rate() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_get_sample_rate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_sample_rate(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetSampleRateRequest* /*request*/, ::minknow_api::device::GetSampleRateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_set_sample_rate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_set_sample_rate() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_set_sample_rate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_sample_rate(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetSampleRateRequest* /*request*/, ::minknow_api::device::SetSampleRateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_bias_voltage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_bias_voltage() {
      ::grpc::Service::MarkMethodGeneric(24);
    }
    ~WithGenericMethod_get_bias_voltage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_bias_voltage(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetBiasVoltageRequest* /*request*/, ::minknow_api::device::GetBiasVoltageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_set_bias_voltage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_set_bias_voltage() {
      ::grpc::Service::MarkMethodGeneric(25);
    }
    ~WithGenericMethod_set_bias_voltage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_bias_voltage(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetBiasVoltageRequest* /*request*/, ::minknow_api::device::SetBiasVoltageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_device_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_device_info() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_get_device_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_device_info(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetDeviceInfoRequest* /*request*/, ::minknow_api::device::GetDeviceInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_device_info(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_device_state : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_device_state() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_get_device_state() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_device_state(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetDeviceStateRequest* /*request*/, ::minknow_api::device::GetDeviceStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_device_state(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_stream_device_state : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_stream_device_state() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_stream_device_state() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stream_device_state(::grpc::ServerContext* /*context*/, const ::minknow_api::device::StreamDeviceStateRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::device::GetDeviceStateResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requeststream_device_state(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(2, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_flow_cell_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_flow_cell_info() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_get_flow_cell_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_flow_cell_info(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetFlowCellInfoRequest* /*request*/, ::minknow_api::device::GetFlowCellInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_flow_cell_info(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_stream_flow_cell_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_stream_flow_cell_info() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_stream_flow_cell_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stream_flow_cell_info(::grpc::ServerContext* /*context*/, const ::minknow_api::device::StreamFlowCellInfoRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::device::GetFlowCellInfoResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requeststream_flow_cell_info(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(4, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_set_user_specified_flow_cell_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_set_user_specified_flow_cell_id() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_set_user_specified_flow_cell_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_user_specified_flow_cell_id(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetUserSpecifiedFlowCellIdRequest* /*request*/, ::minknow_api::device::SetUserSpecifiedFlowCellIdResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_user_specified_flow_cell_id(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_set_user_specified_product_code : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_set_user_specified_product_code() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_set_user_specified_product_code() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_user_specified_product_code(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetUserSpecifiedProductCodeRequest* /*request*/, ::minknow_api::device::SetUserSpecifiedProductCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_user_specified_product_code(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_channels_layout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_channels_layout() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_get_channels_layout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_channels_layout(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetChannelsLayoutRequest* /*request*/, ::minknow_api::device::GetChannelsLayoutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_channels_layout(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_reset_device_settings : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_reset_device_settings() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_reset_device_settings() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status reset_device_settings(::grpc::ServerContext* /*context*/, const ::minknow_api::device::ResetDeviceSettingsRequest* /*request*/, ::minknow_api::device::ResetDeviceSettingsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestreset_device_settings(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_set_calibration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_set_calibration() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_set_calibration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_calibration(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetCalibrationRequest* /*request*/, ::minknow_api::device::SetCalibrationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_calibration(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_clear_calibration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_clear_calibration() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_clear_calibration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clear_calibration(::grpc::ServerContext* /*context*/, const ::minknow_api::device::ClearCalibrationRequest* /*request*/, ::minknow_api::device::ClearCalibrationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestclear_calibration(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_calibration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_calibration() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_get_calibration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_calibration(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetCalibrationRequest* /*request*/, ::minknow_api::device::GetCalibrationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_calibration(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_set_temperature : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_set_temperature() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_set_temperature() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_temperature(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetTemperatureRequest* /*request*/, ::minknow_api::device::SetTemperatureResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_temperature(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_temperature : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_temperature() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_get_temperature() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_temperature(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetTemperatureRequest* /*request*/, ::minknow_api::device::GetTemperatureResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_temperature(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_stream_temperature : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_stream_temperature() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_stream_temperature() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stream_temperature(::grpc::ServerContext* /*context*/, const ::minknow_api::device::StreamTemperatureRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::device::GetTemperatureResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requeststream_temperature(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(14, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_unblock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_unblock() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_unblock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status unblock(::grpc::ServerContext* /*context*/, const ::minknow_api::device::UnblockRequest* /*request*/, ::minknow_api::device::UnblockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestunblock(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_cancel_unblocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_cancel_unblocks() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_cancel_unblocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status cancel_unblocks(::grpc::ServerContext* /*context*/, const ::minknow_api::device::CancelUnblocksRequest* /*request*/, ::minknow_api::device::CancelUnblocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestcancel_unblocks(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_channel_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_channel_configuration() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_get_channel_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_channel_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetChannelConfigurationRequest* /*request*/, ::minknow_api::device::GetChannelConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_channel_configuration(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_set_channel_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_set_channel_configuration() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_set_channel_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_channel_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetChannelConfigurationRequest* /*request*/, ::minknow_api::device::SetChannelConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_channel_configuration(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_set_channel_configuration_all : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_set_channel_configuration_all() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_set_channel_configuration_all() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_channel_configuration_all(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetChannelConfigurationAllRequest* /*request*/, ::minknow_api::device::SetChannelConfigurationAllResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_channel_configuration_all(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_set_saturation_config : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_set_saturation_config() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_set_saturation_config() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_saturation_config(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetSaturationConfigRequest* /*request*/, ::minknow_api::device::SetSaturationConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_saturation_config(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_saturation_config : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_saturation_config() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_get_saturation_config() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_saturation_config(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetSaturationConfigRequest* /*request*/, ::minknow_api::device::GetSaturationConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_saturation_config(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_sample_rate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_sample_rate() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_get_sample_rate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_sample_rate(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetSampleRateRequest* /*request*/, ::minknow_api::device::GetSampleRateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_sample_rate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_set_sample_rate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_set_sample_rate() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_set_sample_rate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_sample_rate(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetSampleRateRequest* /*request*/, ::minknow_api::device::SetSampleRateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_sample_rate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_bias_voltage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_bias_voltage() {
      ::grpc::Service::MarkMethodRaw(24);
    }
    ~WithRawMethod_get_bias_voltage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_bias_voltage(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetBiasVoltageRequest* /*request*/, ::minknow_api::device::GetBiasVoltageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_bias_voltage(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_set_bias_voltage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_set_bias_voltage() {
      ::grpc::Service::MarkMethodRaw(25);
    }
    ~WithRawMethod_set_bias_voltage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_bias_voltage(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetBiasVoltageRequest* /*request*/, ::minknow_api::device::SetBiasVoltageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_bias_voltage(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_device_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_device_info() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_device_info(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_device_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_device_info(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetDeviceInfoRequest* /*request*/, ::minknow_api::device::GetDeviceInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_device_info(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_device_state : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_device_state() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_device_state(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_device_state() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_device_state(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetDeviceStateRequest* /*request*/, ::minknow_api::device::GetDeviceStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_device_state(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_stream_device_state : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_stream_device_state() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->stream_device_state(context, request); }));
    }
    ~WithRawCallbackMethod_stream_device_state() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stream_device_state(::grpc::ServerContext* /*context*/, const ::minknow_api::device::StreamDeviceStateRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::device::GetDeviceStateResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* stream_device_state(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_flow_cell_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_flow_cell_info() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_flow_cell_info(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_flow_cell_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_flow_cell_info(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetFlowCellInfoRequest* /*request*/, ::minknow_api::device::GetFlowCellInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_flow_cell_info(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_stream_flow_cell_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_stream_flow_cell_info() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->stream_flow_cell_info(context, request); }));
    }
    ~WithRawCallbackMethod_stream_flow_cell_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stream_flow_cell_info(::grpc::ServerContext* /*context*/, const ::minknow_api::device::StreamFlowCellInfoRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::device::GetFlowCellInfoResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* stream_flow_cell_info(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_set_user_specified_flow_cell_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_set_user_specified_flow_cell_id() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->set_user_specified_flow_cell_id(context, request, response); }));
    }
    ~WithRawCallbackMethod_set_user_specified_flow_cell_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_user_specified_flow_cell_id(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetUserSpecifiedFlowCellIdRequest* /*request*/, ::minknow_api::device::SetUserSpecifiedFlowCellIdResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_user_specified_flow_cell_id(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_set_user_specified_product_code : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_set_user_specified_product_code() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->set_user_specified_product_code(context, request, response); }));
    }
    ~WithRawCallbackMethod_set_user_specified_product_code() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_user_specified_product_code(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetUserSpecifiedProductCodeRequest* /*request*/, ::minknow_api::device::SetUserSpecifiedProductCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_user_specified_product_code(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_channels_layout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_channels_layout() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_channels_layout(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_channels_layout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_channels_layout(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetChannelsLayoutRequest* /*request*/, ::minknow_api::device::GetChannelsLayoutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_channels_layout(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_reset_device_settings : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_reset_device_settings() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->reset_device_settings(context, request, response); }));
    }
    ~WithRawCallbackMethod_reset_device_settings() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status reset_device_settings(::grpc::ServerContext* /*context*/, const ::minknow_api::device::ResetDeviceSettingsRequest* /*request*/, ::minknow_api::device::ResetDeviceSettingsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* reset_device_settings(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_set_calibration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_set_calibration() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->set_calibration(context, request, response); }));
    }
    ~WithRawCallbackMethod_set_calibration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_calibration(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetCalibrationRequest* /*request*/, ::minknow_api::device::SetCalibrationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_calibration(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_clear_calibration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_clear_calibration() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->clear_calibration(context, request, response); }));
    }
    ~WithRawCallbackMethod_clear_calibration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clear_calibration(::grpc::ServerContext* /*context*/, const ::minknow_api::device::ClearCalibrationRequest* /*request*/, ::minknow_api::device::ClearCalibrationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* clear_calibration(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_calibration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_calibration() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_calibration(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_calibration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_calibration(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetCalibrationRequest* /*request*/, ::minknow_api::device::GetCalibrationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_calibration(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_set_temperature : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_set_temperature() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->set_temperature(context, request, response); }));
    }
    ~WithRawCallbackMethod_set_temperature() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_temperature(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetTemperatureRequest* /*request*/, ::minknow_api::device::SetTemperatureResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_temperature(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_temperature : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_temperature() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_temperature(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_temperature() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_temperature(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetTemperatureRequest* /*request*/, ::minknow_api::device::GetTemperatureResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_temperature(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_stream_temperature : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_stream_temperature() {
      ::grpc::Service::MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->stream_temperature(context, request); }));
    }
    ~WithRawCallbackMethod_stream_temperature() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stream_temperature(::grpc::ServerContext* /*context*/, const ::minknow_api::device::StreamTemperatureRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::device::GetTemperatureResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* stream_temperature(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_unblock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_unblock() {
      ::grpc::Service::MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->unblock(context, request, response); }));
    }
    ~WithRawCallbackMethod_unblock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status unblock(::grpc::ServerContext* /*context*/, const ::minknow_api::device::UnblockRequest* /*request*/, ::minknow_api::device::UnblockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* unblock(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_cancel_unblocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_cancel_unblocks() {
      ::grpc::Service::MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->cancel_unblocks(context, request, response); }));
    }
    ~WithRawCallbackMethod_cancel_unblocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status cancel_unblocks(::grpc::ServerContext* /*context*/, const ::minknow_api::device::CancelUnblocksRequest* /*request*/, ::minknow_api::device::CancelUnblocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* cancel_unblocks(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_channel_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_channel_configuration() {
      ::grpc::Service::MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_channel_configuration(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_channel_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_channel_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetChannelConfigurationRequest* /*request*/, ::minknow_api::device::GetChannelConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_channel_configuration(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_set_channel_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_set_channel_configuration() {
      ::grpc::Service::MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->set_channel_configuration(context, request, response); }));
    }
    ~WithRawCallbackMethod_set_channel_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_channel_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetChannelConfigurationRequest* /*request*/, ::minknow_api::device::SetChannelConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_channel_configuration(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_set_channel_configuration_all : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_set_channel_configuration_all() {
      ::grpc::Service::MarkMethodRawCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->set_channel_configuration_all(context, request, response); }));
    }
    ~WithRawCallbackMethod_set_channel_configuration_all() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_channel_configuration_all(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetChannelConfigurationAllRequest* /*request*/, ::minknow_api::device::SetChannelConfigurationAllResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_channel_configuration_all(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_set_saturation_config : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_set_saturation_config() {
      ::grpc::Service::MarkMethodRawCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->set_saturation_config(context, request, response); }));
    }
    ~WithRawCallbackMethod_set_saturation_config() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_saturation_config(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetSaturationConfigRequest* /*request*/, ::minknow_api::device::SetSaturationConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_saturation_config(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_saturation_config : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_saturation_config() {
      ::grpc::Service::MarkMethodRawCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_saturation_config(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_saturation_config() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_saturation_config(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetSaturationConfigRequest* /*request*/, ::minknow_api::device::GetSaturationConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_saturation_config(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_sample_rate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_sample_rate() {
      ::grpc::Service::MarkMethodRawCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_sample_rate(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_sample_rate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_sample_rate(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetSampleRateRequest* /*request*/, ::minknow_api::device::GetSampleRateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_sample_rate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_set_sample_rate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_set_sample_rate() {
      ::grpc::Service::MarkMethodRawCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->set_sample_rate(context, request, response); }));
    }
    ~WithRawCallbackMethod_set_sample_rate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_sample_rate(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetSampleRateRequest* /*request*/, ::minknow_api::device::SetSampleRateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_sample_rate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_bias_voltage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_bias_voltage() {
      ::grpc::Service::MarkMethodRawCallback(24,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_bias_voltage(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_bias_voltage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_bias_voltage(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetBiasVoltageRequest* /*request*/, ::minknow_api::device::GetBiasVoltageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_bias_voltage(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_set_bias_voltage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_set_bias_voltage() {
      ::grpc::Service::MarkMethodRawCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->set_bias_voltage(context, request, response); }));
    }
    ~WithRawCallbackMethod_set_bias_voltage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_bias_voltage(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetBiasVoltageRequest* /*request*/, ::minknow_api::device::SetBiasVoltageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_bias_voltage(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_device_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_device_info() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::device::GetDeviceInfoRequest, ::minknow_api::device::GetDeviceInfoResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::device::GetDeviceInfoRequest, ::minknow_api::device::GetDeviceInfoResponse>* streamer) {
                       return this->Streamedget_device_info(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_device_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_device_info(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetDeviceInfoRequest* /*request*/, ::minknow_api::device::GetDeviceInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_device_info(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::device::GetDeviceInfoRequest,::minknow_api::device::GetDeviceInfoResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_device_state : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_device_state() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::device::GetDeviceStateRequest, ::minknow_api::device::GetDeviceStateResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::device::GetDeviceStateRequest, ::minknow_api::device::GetDeviceStateResponse>* streamer) {
                       return this->Streamedget_device_state(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_device_state() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_device_state(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetDeviceStateRequest* /*request*/, ::minknow_api::device::GetDeviceStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_device_state(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::device::GetDeviceStateRequest,::minknow_api::device::GetDeviceStateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_flow_cell_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_flow_cell_info() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::device::GetFlowCellInfoRequest, ::minknow_api::device::GetFlowCellInfoResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::device::GetFlowCellInfoRequest, ::minknow_api::device::GetFlowCellInfoResponse>* streamer) {
                       return this->Streamedget_flow_cell_info(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_flow_cell_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_flow_cell_info(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetFlowCellInfoRequest* /*request*/, ::minknow_api::device::GetFlowCellInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_flow_cell_info(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::device::GetFlowCellInfoRequest,::minknow_api::device::GetFlowCellInfoResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_set_user_specified_flow_cell_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_set_user_specified_flow_cell_id() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::device::SetUserSpecifiedFlowCellIdRequest, ::minknow_api::device::SetUserSpecifiedFlowCellIdResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::device::SetUserSpecifiedFlowCellIdRequest, ::minknow_api::device::SetUserSpecifiedFlowCellIdResponse>* streamer) {
                       return this->Streamedset_user_specified_flow_cell_id(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_set_user_specified_flow_cell_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status set_user_specified_flow_cell_id(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetUserSpecifiedFlowCellIdRequest* /*request*/, ::minknow_api::device::SetUserSpecifiedFlowCellIdResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedset_user_specified_flow_cell_id(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::device::SetUserSpecifiedFlowCellIdRequest,::minknow_api::device::SetUserSpecifiedFlowCellIdResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_set_user_specified_product_code : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_set_user_specified_product_code() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::device::SetUserSpecifiedProductCodeRequest, ::minknow_api::device::SetUserSpecifiedProductCodeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::device::SetUserSpecifiedProductCodeRequest, ::minknow_api::device::SetUserSpecifiedProductCodeResponse>* streamer) {
                       return this->Streamedset_user_specified_product_code(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_set_user_specified_product_code() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status set_user_specified_product_code(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetUserSpecifiedProductCodeRequest* /*request*/, ::minknow_api::device::SetUserSpecifiedProductCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedset_user_specified_product_code(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::device::SetUserSpecifiedProductCodeRequest,::minknow_api::device::SetUserSpecifiedProductCodeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_channels_layout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_channels_layout() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::device::GetChannelsLayoutRequest, ::minknow_api::device::GetChannelsLayoutResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::device::GetChannelsLayoutRequest, ::minknow_api::device::GetChannelsLayoutResponse>* streamer) {
                       return this->Streamedget_channels_layout(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_channels_layout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_channels_layout(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetChannelsLayoutRequest* /*request*/, ::minknow_api::device::GetChannelsLayoutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_channels_layout(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::device::GetChannelsLayoutRequest,::minknow_api::device::GetChannelsLayoutResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_reset_device_settings : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_reset_device_settings() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::device::ResetDeviceSettingsRequest, ::minknow_api::device::ResetDeviceSettingsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::device::ResetDeviceSettingsRequest, ::minknow_api::device::ResetDeviceSettingsResponse>* streamer) {
                       return this->Streamedreset_device_settings(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_reset_device_settings() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status reset_device_settings(::grpc::ServerContext* /*context*/, const ::minknow_api::device::ResetDeviceSettingsRequest* /*request*/, ::minknow_api::device::ResetDeviceSettingsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedreset_device_settings(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::device::ResetDeviceSettingsRequest,::minknow_api::device::ResetDeviceSettingsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_set_calibration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_set_calibration() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::device::SetCalibrationRequest, ::minknow_api::device::SetCalibrationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::device::SetCalibrationRequest, ::minknow_api::device::SetCalibrationResponse>* streamer) {
                       return this->Streamedset_calibration(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_set_calibration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status set_calibration(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetCalibrationRequest* /*request*/, ::minknow_api::device::SetCalibrationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedset_calibration(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::device::SetCalibrationRequest,::minknow_api::device::SetCalibrationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_clear_calibration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_clear_calibration() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::device::ClearCalibrationRequest, ::minknow_api::device::ClearCalibrationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::device::ClearCalibrationRequest, ::minknow_api::device::ClearCalibrationResponse>* streamer) {
                       return this->Streamedclear_calibration(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_clear_calibration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status clear_calibration(::grpc::ServerContext* /*context*/, const ::minknow_api::device::ClearCalibrationRequest* /*request*/, ::minknow_api::device::ClearCalibrationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedclear_calibration(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::device::ClearCalibrationRequest,::minknow_api::device::ClearCalibrationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_calibration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_calibration() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::device::GetCalibrationRequest, ::minknow_api::device::GetCalibrationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::device::GetCalibrationRequest, ::minknow_api::device::GetCalibrationResponse>* streamer) {
                       return this->Streamedget_calibration(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_calibration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_calibration(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetCalibrationRequest* /*request*/, ::minknow_api::device::GetCalibrationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_calibration(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::device::GetCalibrationRequest,::minknow_api::device::GetCalibrationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_set_temperature : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_set_temperature() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::device::SetTemperatureRequest, ::minknow_api::device::SetTemperatureResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::device::SetTemperatureRequest, ::minknow_api::device::SetTemperatureResponse>* streamer) {
                       return this->Streamedset_temperature(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_set_temperature() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status set_temperature(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetTemperatureRequest* /*request*/, ::minknow_api::device::SetTemperatureResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedset_temperature(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::device::SetTemperatureRequest,::minknow_api::device::SetTemperatureResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_temperature : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_temperature() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::device::GetTemperatureRequest, ::minknow_api::device::GetTemperatureResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::device::GetTemperatureRequest, ::minknow_api::device::GetTemperatureResponse>* streamer) {
                       return this->Streamedget_temperature(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_temperature() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_temperature(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetTemperatureRequest* /*request*/, ::minknow_api::device::GetTemperatureResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_temperature(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::device::GetTemperatureRequest,::minknow_api::device::GetTemperatureResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_unblock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_unblock() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::device::UnblockRequest, ::minknow_api::device::UnblockResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::device::UnblockRequest, ::minknow_api::device::UnblockResponse>* streamer) {
                       return this->Streamedunblock(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_unblock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status unblock(::grpc::ServerContext* /*context*/, const ::minknow_api::device::UnblockRequest* /*request*/, ::minknow_api::device::UnblockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedunblock(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::device::UnblockRequest,::minknow_api::device::UnblockResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_cancel_unblocks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_cancel_unblocks() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::device::CancelUnblocksRequest, ::minknow_api::device::CancelUnblocksResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::device::CancelUnblocksRequest, ::minknow_api::device::CancelUnblocksResponse>* streamer) {
                       return this->Streamedcancel_unblocks(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_cancel_unblocks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status cancel_unblocks(::grpc::ServerContext* /*context*/, const ::minknow_api::device::CancelUnblocksRequest* /*request*/, ::minknow_api::device::CancelUnblocksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedcancel_unblocks(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::device::CancelUnblocksRequest,::minknow_api::device::CancelUnblocksResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_channel_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_channel_configuration() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::device::GetChannelConfigurationRequest, ::minknow_api::device::GetChannelConfigurationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::device::GetChannelConfigurationRequest, ::minknow_api::device::GetChannelConfigurationResponse>* streamer) {
                       return this->Streamedget_channel_configuration(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_channel_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_channel_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetChannelConfigurationRequest* /*request*/, ::minknow_api::device::GetChannelConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_channel_configuration(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::device::GetChannelConfigurationRequest,::minknow_api::device::GetChannelConfigurationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_set_channel_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_set_channel_configuration() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::device::SetChannelConfigurationRequest, ::minknow_api::device::SetChannelConfigurationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::device::SetChannelConfigurationRequest, ::minknow_api::device::SetChannelConfigurationResponse>* streamer) {
                       return this->Streamedset_channel_configuration(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_set_channel_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status set_channel_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetChannelConfigurationRequest* /*request*/, ::minknow_api::device::SetChannelConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedset_channel_configuration(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::device::SetChannelConfigurationRequest,::minknow_api::device::SetChannelConfigurationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_set_channel_configuration_all : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_set_channel_configuration_all() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::device::SetChannelConfigurationAllRequest, ::minknow_api::device::SetChannelConfigurationAllResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::device::SetChannelConfigurationAllRequest, ::minknow_api::device::SetChannelConfigurationAllResponse>* streamer) {
                       return this->Streamedset_channel_configuration_all(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_set_channel_configuration_all() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status set_channel_configuration_all(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetChannelConfigurationAllRequest* /*request*/, ::minknow_api::device::SetChannelConfigurationAllResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedset_channel_configuration_all(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::device::SetChannelConfigurationAllRequest,::minknow_api::device::SetChannelConfigurationAllResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_set_saturation_config : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_set_saturation_config() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::device::SetSaturationConfigRequest, ::minknow_api::device::SetSaturationConfigResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::device::SetSaturationConfigRequest, ::minknow_api::device::SetSaturationConfigResponse>* streamer) {
                       return this->Streamedset_saturation_config(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_set_saturation_config() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status set_saturation_config(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetSaturationConfigRequest* /*request*/, ::minknow_api::device::SetSaturationConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedset_saturation_config(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::device::SetSaturationConfigRequest,::minknow_api::device::SetSaturationConfigResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_saturation_config : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_saturation_config() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::device::GetSaturationConfigRequest, ::minknow_api::device::GetSaturationConfigResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::device::GetSaturationConfigRequest, ::minknow_api::device::GetSaturationConfigResponse>* streamer) {
                       return this->Streamedget_saturation_config(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_saturation_config() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_saturation_config(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetSaturationConfigRequest* /*request*/, ::minknow_api::device::GetSaturationConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_saturation_config(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::device::GetSaturationConfigRequest,::minknow_api::device::GetSaturationConfigResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_sample_rate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_sample_rate() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::device::GetSampleRateRequest, ::minknow_api::device::GetSampleRateResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::device::GetSampleRateRequest, ::minknow_api::device::GetSampleRateResponse>* streamer) {
                       return this->Streamedget_sample_rate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_sample_rate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_sample_rate(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetSampleRateRequest* /*request*/, ::minknow_api::device::GetSampleRateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_sample_rate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::device::GetSampleRateRequest,::minknow_api::device::GetSampleRateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_set_sample_rate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_set_sample_rate() {
      ::grpc::Service::MarkMethodStreamed(23,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::device::SetSampleRateRequest, ::minknow_api::device::SetSampleRateResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::device::SetSampleRateRequest, ::minknow_api::device::SetSampleRateResponse>* streamer) {
                       return this->Streamedset_sample_rate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_set_sample_rate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status set_sample_rate(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetSampleRateRequest* /*request*/, ::minknow_api::device::SetSampleRateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedset_sample_rate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::device::SetSampleRateRequest,::minknow_api::device::SetSampleRateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_bias_voltage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_bias_voltage() {
      ::grpc::Service::MarkMethodStreamed(24,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::device::GetBiasVoltageRequest, ::minknow_api::device::GetBiasVoltageResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::device::GetBiasVoltageRequest, ::minknow_api::device::GetBiasVoltageResponse>* streamer) {
                       return this->Streamedget_bias_voltage(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_bias_voltage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_bias_voltage(::grpc::ServerContext* /*context*/, const ::minknow_api::device::GetBiasVoltageRequest* /*request*/, ::minknow_api::device::GetBiasVoltageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_bias_voltage(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::device::GetBiasVoltageRequest,::minknow_api::device::GetBiasVoltageResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_set_bias_voltage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_set_bias_voltage() {
      ::grpc::Service::MarkMethodStreamed(25,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::device::SetBiasVoltageRequest, ::minknow_api::device::SetBiasVoltageResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::device::SetBiasVoltageRequest, ::minknow_api::device::SetBiasVoltageResponse>* streamer) {
                       return this->Streamedset_bias_voltage(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_set_bias_voltage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status set_bias_voltage(::grpc::ServerContext* /*context*/, const ::minknow_api::device::SetBiasVoltageRequest* /*request*/, ::minknow_api::device::SetBiasVoltageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedset_bias_voltage(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::device::SetBiasVoltageRequest,::minknow_api::device::SetBiasVoltageResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_get_device_info<WithStreamedUnaryMethod_get_device_state<WithStreamedUnaryMethod_get_flow_cell_info<WithStreamedUnaryMethod_set_user_specified_flow_cell_id<WithStreamedUnaryMethod_set_user_specified_product_code<WithStreamedUnaryMethod_get_channels_layout<WithStreamedUnaryMethod_reset_device_settings<WithStreamedUnaryMethod_set_calibration<WithStreamedUnaryMethod_clear_calibration<WithStreamedUnaryMethod_get_calibration<WithStreamedUnaryMethod_set_temperature<WithStreamedUnaryMethod_get_temperature<WithStreamedUnaryMethod_unblock<WithStreamedUnaryMethod_cancel_unblocks<WithStreamedUnaryMethod_get_channel_configuration<WithStreamedUnaryMethod_set_channel_configuration<WithStreamedUnaryMethod_set_channel_configuration_all<WithStreamedUnaryMethod_set_saturation_config<WithStreamedUnaryMethod_get_saturation_config<WithStreamedUnaryMethod_get_sample_rate<WithStreamedUnaryMethod_set_sample_rate<WithStreamedUnaryMethod_get_bias_voltage<WithStreamedUnaryMethod_set_bias_voltage<Service > > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_stream_device_state : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_stream_device_state() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::minknow_api::device::StreamDeviceStateRequest, ::minknow_api::device::GetDeviceStateResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::minknow_api::device::StreamDeviceStateRequest, ::minknow_api::device::GetDeviceStateResponse>* streamer) {
                       return this->Streamedstream_device_state(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_stream_device_state() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status stream_device_state(::grpc::ServerContext* /*context*/, const ::minknow_api::device::StreamDeviceStateRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::device::GetDeviceStateResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status Streamedstream_device_state(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::minknow_api::device::StreamDeviceStateRequest,::minknow_api::device::GetDeviceStateResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_stream_flow_cell_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_stream_flow_cell_info() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::minknow_api::device::StreamFlowCellInfoRequest, ::minknow_api::device::GetFlowCellInfoResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::minknow_api::device::StreamFlowCellInfoRequest, ::minknow_api::device::GetFlowCellInfoResponse>* streamer) {
                       return this->Streamedstream_flow_cell_info(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_stream_flow_cell_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status stream_flow_cell_info(::grpc::ServerContext* /*context*/, const ::minknow_api::device::StreamFlowCellInfoRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::device::GetFlowCellInfoResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status Streamedstream_flow_cell_info(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::minknow_api::device::StreamFlowCellInfoRequest,::minknow_api::device::GetFlowCellInfoResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_stream_temperature : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_stream_temperature() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::minknow_api::device::StreamTemperatureRequest, ::minknow_api::device::GetTemperatureResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::minknow_api::device::StreamTemperatureRequest, ::minknow_api::device::GetTemperatureResponse>* streamer) {
                       return this->Streamedstream_temperature(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_stream_temperature() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status stream_temperature(::grpc::ServerContext* /*context*/, const ::minknow_api::device::StreamTemperatureRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::device::GetTemperatureResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status Streamedstream_temperature(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::minknow_api::device::StreamTemperatureRequest,::minknow_api::device::GetTemperatureResponse>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_stream_device_state<WithSplitStreamingMethod_stream_flow_cell_info<WithSplitStreamingMethod_stream_temperature<Service > > > SplitStreamedService;
  typedef WithStreamedUnaryMethod_get_device_info<WithStreamedUnaryMethod_get_device_state<WithSplitStreamingMethod_stream_device_state<WithStreamedUnaryMethod_get_flow_cell_info<WithSplitStreamingMethod_stream_flow_cell_info<WithStreamedUnaryMethod_set_user_specified_flow_cell_id<WithStreamedUnaryMethod_set_user_specified_product_code<WithStreamedUnaryMethod_get_channels_layout<WithStreamedUnaryMethod_reset_device_settings<WithStreamedUnaryMethod_set_calibration<WithStreamedUnaryMethod_clear_calibration<WithStreamedUnaryMethod_get_calibration<WithStreamedUnaryMethod_set_temperature<WithStreamedUnaryMethod_get_temperature<WithSplitStreamingMethod_stream_temperature<WithStreamedUnaryMethod_unblock<WithStreamedUnaryMethod_cancel_unblocks<WithStreamedUnaryMethod_get_channel_configuration<WithStreamedUnaryMethod_set_channel_configuration<WithStreamedUnaryMethod_set_channel_configuration_all<WithStreamedUnaryMethod_set_saturation_config<WithStreamedUnaryMethod_get_saturation_config<WithStreamedUnaryMethod_get_sample_rate<WithStreamedUnaryMethod_set_sample_rate<WithStreamedUnaryMethod_get_bias_voltage<WithStreamedUnaryMethod_set_bias_voltage<Service > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace device
}  // namespace minknow_api


#endif  // GRPC_minknow_5fapi_2fdevice_2eproto__INCLUDED
