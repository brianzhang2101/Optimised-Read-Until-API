// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: minknow_api/acquisition.proto
#ifndef GRPC_minknow_5fapi_2facquisition_2eproto__INCLUDED
#define GRPC_minknow_5fapi_2facquisition_2eproto__INCLUDED

#include "minknow_api/acquisition.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace minknow_api {
namespace acquisition {

class AcquisitionService final {
 public:
  static constexpr char const* service_full_name() {
    return "minknow_api.acquisition.AcquisitionService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Starts reading data from the device
    //
    // Some setup calls will need to be made before starting data acquisition: particularly setting the analysis configuration,
    // calibration, read writer and bulk writer config and some device calls such as setting the sampling frequency
    //
    // If acqusition is already running (even in the FINISHING state), this call will fail.
    //
    // On MinIONs and GridIONs, this will enable the ASIC power supply if it is not already enabled.
    // See StopRequest.keep_power_on for more details about the implications of this.
    //
    // The rpc will return once `current_status` is "PROCESSING" or an error occurs and acqusition fails to start.
    virtual ::grpc::Status start(::grpc::ClientContext* context, const ::minknow_api::acquisition::StartRequest& request, ::minknow_api::acquisition::StartResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::StartResponse>> Asyncstart(::grpc::ClientContext* context, const ::minknow_api::acquisition::StartRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::StartResponse>>(AsyncstartRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::StartResponse>> PrepareAsyncstart(::grpc::ClientContext* context, const ::minknow_api::acquisition::StartRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::StartResponse>>(PrepareAsyncstartRaw(context, request, cq));
    }
    // Stops data acquisition.
    //
    // Can specify a stop mode that handles what is done with the data when data acquisition is stopped. Refer to the enum
    // description for documentation on what each mode does.
    //
    // Be aware that this command will return as soon as Minknow enters the FINISHING state and not the READY state.
    // So if starting a new experiment then you will have to wait for the READY state seperately
    virtual ::grpc::Status stop(::grpc::ClientContext* context, const ::minknow_api::acquisition::StopRequest& request, ::minknow_api::acquisition::StopResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::StopResponse>> Asyncstop(::grpc::ClientContext* context, const ::minknow_api::acquisition::StopRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::StopResponse>>(AsyncstopRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::StopResponse>> PrepareAsyncstop(::grpc::ClientContext* context, const ::minknow_api::acquisition::StopRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::StopResponse>>(PrepareAsyncstopRaw(context, request, cq));
    }
    // Watches for status changes within MinKNOW. Status states are defined from MinknowStatus enum.
    // This is a bi-directional stream where the incoming response stream will return everytime the status has changed
    // and the request stream is used to stop the watcher. Refer to http://www.grpc.io/docs/tutorials/basic/python.html
    // to see how bi-directoional streaming works in grpc, but essentially when calling this function the user will have
    // to pass in a generator that will eventually yield a WatchForStatusChangeRequest(stop=True) to the cpp side.
    // A wrapper class for this is provided in the Python code.
    //
    // The function will first return with the current status that MinKNOW is in. Every response thereafter will be a
    // change from one status to another.
    //
    // The ERROR_STATUS state includes errors during transition between states. If that happens, MinKNOW will
    // try to revert to the READY state. It is up to the user to determine if they wish to try to wait for MinKNOW to
    // correct itself or to try some other course of action
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::minknow_api::acquisition::WatchForStatusChangeRequest, ::minknow_api::acquisition::WatchForStatusChangeResponse>> watch_for_status_change(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::minknow_api::acquisition::WatchForStatusChangeRequest, ::minknow_api::acquisition::WatchForStatusChangeResponse>>(watch_for_status_changeRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::minknow_api::acquisition::WatchForStatusChangeRequest, ::minknow_api::acquisition::WatchForStatusChangeResponse>> Asyncwatch_for_status_change(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::minknow_api::acquisition::WatchForStatusChangeRequest, ::minknow_api::acquisition::WatchForStatusChangeResponse>>(Asyncwatch_for_status_changeRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::minknow_api::acquisition::WatchForStatusChangeRequest, ::minknow_api::acquisition::WatchForStatusChangeResponse>> PrepareAsyncwatch_for_status_change(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::minknow_api::acquisition::WatchForStatusChangeRequest, ::minknow_api::acquisition::WatchForStatusChangeResponse>>(PrepareAsyncwatch_for_status_changeRaw(context, cq));
    }
    // Returns current acquisition run info and streams any changes to the current acquisition
    //
    // This call can be made even if acquisition is not running. In this case, the next streamed
    // response will be the start of a new acquisition and you will receive updates for that acquisition
    // until it finishes.
    //
    // If an acquisition finishes this stream will still continue to run and you will be notified when a new acquisition starts.
    //
    // Note if you begin this stream before any acquisition is started in minknow the state is `ACQUISITION_COMPLETED`.
    //
    // Since 1.13
    std::unique_ptr< ::grpc::ClientReaderInterface< ::minknow_api::acquisition::AcquisitionRunInfo>> watch_current_acquisition_run(::grpc::ClientContext* context, const ::minknow_api::acquisition::WatchCurrentAcquisitionRunRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::minknow_api::acquisition::AcquisitionRunInfo>>(watch_current_acquisition_runRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::acquisition::AcquisitionRunInfo>> Asyncwatch_current_acquisition_run(::grpc::ClientContext* context, const ::minknow_api::acquisition::WatchCurrentAcquisitionRunRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::acquisition::AcquisitionRunInfo>>(Asyncwatch_current_acquisition_runRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::acquisition::AcquisitionRunInfo>> PrepareAsyncwatch_current_acquisition_run(::grpc::ClientContext* context, const ::minknow_api::acquisition::WatchCurrentAcquisitionRunRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::acquisition::AcquisitionRunInfo>>(PrepareAsyncwatch_current_acquisition_runRaw(context, request, cq));
    }
    // Check the current status of MinKNOW.
    virtual ::grpc::Status current_status(::grpc::ClientContext* context, const ::minknow_api::acquisition::CurrentStatusRequest& request, ::minknow_api::acquisition::CurrentStatusResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::CurrentStatusResponse>> Asynccurrent_status(::grpc::ClientContext* context, const ::minknow_api::acquisition::CurrentStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::CurrentStatusResponse>>(Asynccurrent_statusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::CurrentStatusResponse>> PrepareAsynccurrent_status(::grpc::ClientContext* context, const ::minknow_api::acquisition::CurrentStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::CurrentStatusResponse>>(PrepareAsynccurrent_statusRaw(context, request, cq));
    }
    // Information on how much data has been acquired, processed and written.
    virtual ::grpc::Status get_progress(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetProgressRequest& request, ::minknow_api::acquisition::GetProgressResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::GetProgressResponse>> Asyncget_progress(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetProgressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::GetProgressResponse>>(Asyncget_progressRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::GetProgressResponse>> PrepareAsyncget_progress(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetProgressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::GetProgressResponse>>(PrepareAsyncget_progressRaw(context, request, cq));
    }
    // Gets information about an acquisition run, run within this instance on MinKNOW.
    //
    // If no run ID is provided, information about the most recently started acquisition run is
    // provided.
    //
    // Since 1.11
    virtual ::grpc::Status get_acquisition_info(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetAcquisitionRunInfoRequest& request, ::minknow_api::acquisition::AcquisitionRunInfo* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::AcquisitionRunInfo>> Asyncget_acquisition_info(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetAcquisitionRunInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::AcquisitionRunInfo>>(Asyncget_acquisition_infoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::AcquisitionRunInfo>> PrepareAsyncget_acquisition_info(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetAcquisitionRunInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::AcquisitionRunInfo>>(PrepareAsyncget_acquisition_infoRaw(context, request, cq));
    }
    // Gets information about all previous acquisitions.
    //
    // Since 1.11
    virtual ::grpc::Status list_acquisition_runs(::grpc::ClientContext* context, const ::minknow_api::acquisition::ListAcquisitionRunsRequest& request, ::minknow_api::acquisition::ListAcquisitionRunsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::ListAcquisitionRunsResponse>> Asynclist_acquisition_runs(::grpc::ClientContext* context, const ::minknow_api::acquisition::ListAcquisitionRunsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::ListAcquisitionRunsResponse>>(Asynclist_acquisition_runsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::ListAcquisitionRunsResponse>> PrepareAsynclist_acquisition_runs(::grpc::ClientContext* context, const ::minknow_api::acquisition::ListAcquisitionRunsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::ListAcquisitionRunsResponse>>(PrepareAsynclist_acquisition_runsRaw(context, request, cq));
    }
    // Returns the name and run id of the currently running acquisition.
    //
    // Will fail with FAILED_PRECONDITION if there is no acquisition running
    //
    // Since 1.11
    virtual ::grpc::Status get_current_acquisition_run(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetCurrentAcquisitionRunRequest& request, ::minknow_api::acquisition::AcquisitionRunInfo* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::AcquisitionRunInfo>> Asyncget_current_acquisition_run(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetCurrentAcquisitionRunRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::AcquisitionRunInfo>>(Asyncget_current_acquisition_runRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::AcquisitionRunInfo>> PrepareAsyncget_current_acquisition_run(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetCurrentAcquisitionRunRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::AcquisitionRunInfo>>(PrepareAsyncget_current_acquisition_runRaw(context, request, cq));
    }
    // Specify the signal reader to use
    //
    // Since 3.6
    virtual ::grpc::Status set_signal_reader(::grpc::ClientContext* context, const ::minknow_api::acquisition::SetSignalReaderRequest& request, ::minknow_api::acquisition::SetSignalReaderResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::SetSignalReaderResponse>> Asyncset_signal_reader(::grpc::ClientContext* context, const ::minknow_api::acquisition::SetSignalReaderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::SetSignalReaderResponse>>(Asyncset_signal_readerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::SetSignalReaderResponse>> PrepareAsyncset_signal_reader(::grpc::ClientContext* context, const ::minknow_api::acquisition::SetSignalReaderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::SetSignalReaderResponse>>(PrepareAsyncset_signal_readerRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // Starts reading data from the device
      //
      // Some setup calls will need to be made before starting data acquisition: particularly setting the analysis configuration,
      // calibration, read writer and bulk writer config and some device calls such as setting the sampling frequency
      //
      // If acqusition is already running (even in the FINISHING state), this call will fail.
      //
      // On MinIONs and GridIONs, this will enable the ASIC power supply if it is not already enabled.
      // See StopRequest.keep_power_on for more details about the implications of this.
      //
      // The rpc will return once `current_status` is "PROCESSING" or an error occurs and acqusition fails to start.
      virtual void start(::grpc::ClientContext* context, const ::minknow_api::acquisition::StartRequest* request, ::minknow_api::acquisition::StartResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void start(::grpc::ClientContext* context, const ::minknow_api::acquisition::StartRequest* request, ::minknow_api::acquisition::StartResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Stops data acquisition.
      //
      // Can specify a stop mode that handles what is done with the data when data acquisition is stopped. Refer to the enum
      // description for documentation on what each mode does.
      //
      // Be aware that this command will return as soon as Minknow enters the FINISHING state and not the READY state.
      // So if starting a new experiment then you will have to wait for the READY state seperately
      virtual void stop(::grpc::ClientContext* context, const ::minknow_api::acquisition::StopRequest* request, ::minknow_api::acquisition::StopResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void stop(::grpc::ClientContext* context, const ::minknow_api::acquisition::StopRequest* request, ::minknow_api::acquisition::StopResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Watches for status changes within MinKNOW. Status states are defined from MinknowStatus enum.
      // This is a bi-directional stream where the incoming response stream will return everytime the status has changed
      // and the request stream is used to stop the watcher. Refer to http://www.grpc.io/docs/tutorials/basic/python.html
      // to see how bi-directoional streaming works in grpc, but essentially when calling this function the user will have
      // to pass in a generator that will eventually yield a WatchForStatusChangeRequest(stop=True) to the cpp side.
      // A wrapper class for this is provided in the Python code.
      //
      // The function will first return with the current status that MinKNOW is in. Every response thereafter will be a
      // change from one status to another.
      //
      // The ERROR_STATUS state includes errors during transition between states. If that happens, MinKNOW will
      // try to revert to the READY state. It is up to the user to determine if they wish to try to wait for MinKNOW to
      // correct itself or to try some other course of action
      virtual void watch_for_status_change(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::minknow_api::acquisition::WatchForStatusChangeRequest,::minknow_api::acquisition::WatchForStatusChangeResponse>* reactor) = 0;
      // Returns current acquisition run info and streams any changes to the current acquisition
      //
      // This call can be made even if acquisition is not running. In this case, the next streamed
      // response will be the start of a new acquisition and you will receive updates for that acquisition
      // until it finishes.
      //
      // If an acquisition finishes this stream will still continue to run and you will be notified when a new acquisition starts.
      //
      // Note if you begin this stream before any acquisition is started in minknow the state is `ACQUISITION_COMPLETED`.
      //
      // Since 1.13
      virtual void watch_current_acquisition_run(::grpc::ClientContext* context, const ::minknow_api::acquisition::WatchCurrentAcquisitionRunRequest* request, ::grpc::ClientReadReactor< ::minknow_api::acquisition::AcquisitionRunInfo>* reactor) = 0;
      // Check the current status of MinKNOW.
      virtual void current_status(::grpc::ClientContext* context, const ::minknow_api::acquisition::CurrentStatusRequest* request, ::minknow_api::acquisition::CurrentStatusResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void current_status(::grpc::ClientContext* context, const ::minknow_api::acquisition::CurrentStatusRequest* request, ::minknow_api::acquisition::CurrentStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Information on how much data has been acquired, processed and written.
      virtual void get_progress(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetProgressRequest* request, ::minknow_api::acquisition::GetProgressResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_progress(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetProgressRequest* request, ::minknow_api::acquisition::GetProgressResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Gets information about an acquisition run, run within this instance on MinKNOW.
      //
      // If no run ID is provided, information about the most recently started acquisition run is
      // provided.
      //
      // Since 1.11
      virtual void get_acquisition_info(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetAcquisitionRunInfoRequest* request, ::minknow_api::acquisition::AcquisitionRunInfo* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_acquisition_info(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetAcquisitionRunInfoRequest* request, ::minknow_api::acquisition::AcquisitionRunInfo* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Gets information about all previous acquisitions.
      //
      // Since 1.11
      virtual void list_acquisition_runs(::grpc::ClientContext* context, const ::minknow_api::acquisition::ListAcquisitionRunsRequest* request, ::minknow_api::acquisition::ListAcquisitionRunsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void list_acquisition_runs(::grpc::ClientContext* context, const ::minknow_api::acquisition::ListAcquisitionRunsRequest* request, ::minknow_api::acquisition::ListAcquisitionRunsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Returns the name and run id of the currently running acquisition.
      //
      // Will fail with FAILED_PRECONDITION if there is no acquisition running
      //
      // Since 1.11
      virtual void get_current_acquisition_run(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetCurrentAcquisitionRunRequest* request, ::minknow_api::acquisition::AcquisitionRunInfo* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_current_acquisition_run(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetCurrentAcquisitionRunRequest* request, ::minknow_api::acquisition::AcquisitionRunInfo* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Specify the signal reader to use
      //
      // Since 3.6
      virtual void set_signal_reader(::grpc::ClientContext* context, const ::minknow_api::acquisition::SetSignalReaderRequest* request, ::minknow_api::acquisition::SetSignalReaderResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void set_signal_reader(::grpc::ClientContext* context, const ::minknow_api::acquisition::SetSignalReaderRequest* request, ::minknow_api::acquisition::SetSignalReaderResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::StartResponse>* AsyncstartRaw(::grpc::ClientContext* context, const ::minknow_api::acquisition::StartRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::StartResponse>* PrepareAsyncstartRaw(::grpc::ClientContext* context, const ::minknow_api::acquisition::StartRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::StopResponse>* AsyncstopRaw(::grpc::ClientContext* context, const ::minknow_api::acquisition::StopRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::StopResponse>* PrepareAsyncstopRaw(::grpc::ClientContext* context, const ::minknow_api::acquisition::StopRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::minknow_api::acquisition::WatchForStatusChangeRequest, ::minknow_api::acquisition::WatchForStatusChangeResponse>* watch_for_status_changeRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::minknow_api::acquisition::WatchForStatusChangeRequest, ::minknow_api::acquisition::WatchForStatusChangeResponse>* Asyncwatch_for_status_changeRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::minknow_api::acquisition::WatchForStatusChangeRequest, ::minknow_api::acquisition::WatchForStatusChangeResponse>* PrepareAsyncwatch_for_status_changeRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::minknow_api::acquisition::AcquisitionRunInfo>* watch_current_acquisition_runRaw(::grpc::ClientContext* context, const ::minknow_api::acquisition::WatchCurrentAcquisitionRunRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::minknow_api::acquisition::AcquisitionRunInfo>* Asyncwatch_current_acquisition_runRaw(::grpc::ClientContext* context, const ::minknow_api::acquisition::WatchCurrentAcquisitionRunRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::minknow_api::acquisition::AcquisitionRunInfo>* PrepareAsyncwatch_current_acquisition_runRaw(::grpc::ClientContext* context, const ::minknow_api::acquisition::WatchCurrentAcquisitionRunRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::CurrentStatusResponse>* Asynccurrent_statusRaw(::grpc::ClientContext* context, const ::minknow_api::acquisition::CurrentStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::CurrentStatusResponse>* PrepareAsynccurrent_statusRaw(::grpc::ClientContext* context, const ::minknow_api::acquisition::CurrentStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::GetProgressResponse>* Asyncget_progressRaw(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetProgressRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::GetProgressResponse>* PrepareAsyncget_progressRaw(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetProgressRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::AcquisitionRunInfo>* Asyncget_acquisition_infoRaw(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetAcquisitionRunInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::AcquisitionRunInfo>* PrepareAsyncget_acquisition_infoRaw(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetAcquisitionRunInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::ListAcquisitionRunsResponse>* Asynclist_acquisition_runsRaw(::grpc::ClientContext* context, const ::minknow_api::acquisition::ListAcquisitionRunsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::ListAcquisitionRunsResponse>* PrepareAsynclist_acquisition_runsRaw(::grpc::ClientContext* context, const ::minknow_api::acquisition::ListAcquisitionRunsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::AcquisitionRunInfo>* Asyncget_current_acquisition_runRaw(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetCurrentAcquisitionRunRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::AcquisitionRunInfo>* PrepareAsyncget_current_acquisition_runRaw(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetCurrentAcquisitionRunRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::SetSignalReaderResponse>* Asyncset_signal_readerRaw(::grpc::ClientContext* context, const ::minknow_api::acquisition::SetSignalReaderRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::acquisition::SetSignalReaderResponse>* PrepareAsyncset_signal_readerRaw(::grpc::ClientContext* context, const ::minknow_api::acquisition::SetSignalReaderRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status start(::grpc::ClientContext* context, const ::minknow_api::acquisition::StartRequest& request, ::minknow_api::acquisition::StartResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::StartResponse>> Asyncstart(::grpc::ClientContext* context, const ::minknow_api::acquisition::StartRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::StartResponse>>(AsyncstartRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::StartResponse>> PrepareAsyncstart(::grpc::ClientContext* context, const ::minknow_api::acquisition::StartRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::StartResponse>>(PrepareAsyncstartRaw(context, request, cq));
    }
    ::grpc::Status stop(::grpc::ClientContext* context, const ::minknow_api::acquisition::StopRequest& request, ::minknow_api::acquisition::StopResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::StopResponse>> Asyncstop(::grpc::ClientContext* context, const ::minknow_api::acquisition::StopRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::StopResponse>>(AsyncstopRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::StopResponse>> PrepareAsyncstop(::grpc::ClientContext* context, const ::minknow_api::acquisition::StopRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::StopResponse>>(PrepareAsyncstopRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::minknow_api::acquisition::WatchForStatusChangeRequest, ::minknow_api::acquisition::WatchForStatusChangeResponse>> watch_for_status_change(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::minknow_api::acquisition::WatchForStatusChangeRequest, ::minknow_api::acquisition::WatchForStatusChangeResponse>>(watch_for_status_changeRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::minknow_api::acquisition::WatchForStatusChangeRequest, ::minknow_api::acquisition::WatchForStatusChangeResponse>> Asyncwatch_for_status_change(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::minknow_api::acquisition::WatchForStatusChangeRequest, ::minknow_api::acquisition::WatchForStatusChangeResponse>>(Asyncwatch_for_status_changeRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::minknow_api::acquisition::WatchForStatusChangeRequest, ::minknow_api::acquisition::WatchForStatusChangeResponse>> PrepareAsyncwatch_for_status_change(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::minknow_api::acquisition::WatchForStatusChangeRequest, ::minknow_api::acquisition::WatchForStatusChangeResponse>>(PrepareAsyncwatch_for_status_changeRaw(context, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::minknow_api::acquisition::AcquisitionRunInfo>> watch_current_acquisition_run(::grpc::ClientContext* context, const ::minknow_api::acquisition::WatchCurrentAcquisitionRunRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::minknow_api::acquisition::AcquisitionRunInfo>>(watch_current_acquisition_runRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::acquisition::AcquisitionRunInfo>> Asyncwatch_current_acquisition_run(::grpc::ClientContext* context, const ::minknow_api::acquisition::WatchCurrentAcquisitionRunRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::acquisition::AcquisitionRunInfo>>(Asyncwatch_current_acquisition_runRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::acquisition::AcquisitionRunInfo>> PrepareAsyncwatch_current_acquisition_run(::grpc::ClientContext* context, const ::minknow_api::acquisition::WatchCurrentAcquisitionRunRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::acquisition::AcquisitionRunInfo>>(PrepareAsyncwatch_current_acquisition_runRaw(context, request, cq));
    }
    ::grpc::Status current_status(::grpc::ClientContext* context, const ::minknow_api::acquisition::CurrentStatusRequest& request, ::minknow_api::acquisition::CurrentStatusResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::CurrentStatusResponse>> Asynccurrent_status(::grpc::ClientContext* context, const ::minknow_api::acquisition::CurrentStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::CurrentStatusResponse>>(Asynccurrent_statusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::CurrentStatusResponse>> PrepareAsynccurrent_status(::grpc::ClientContext* context, const ::minknow_api::acquisition::CurrentStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::CurrentStatusResponse>>(PrepareAsynccurrent_statusRaw(context, request, cq));
    }
    ::grpc::Status get_progress(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetProgressRequest& request, ::minknow_api::acquisition::GetProgressResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::GetProgressResponse>> Asyncget_progress(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetProgressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::GetProgressResponse>>(Asyncget_progressRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::GetProgressResponse>> PrepareAsyncget_progress(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetProgressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::GetProgressResponse>>(PrepareAsyncget_progressRaw(context, request, cq));
    }
    ::grpc::Status get_acquisition_info(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetAcquisitionRunInfoRequest& request, ::minknow_api::acquisition::AcquisitionRunInfo* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::AcquisitionRunInfo>> Asyncget_acquisition_info(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetAcquisitionRunInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::AcquisitionRunInfo>>(Asyncget_acquisition_infoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::AcquisitionRunInfo>> PrepareAsyncget_acquisition_info(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetAcquisitionRunInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::AcquisitionRunInfo>>(PrepareAsyncget_acquisition_infoRaw(context, request, cq));
    }
    ::grpc::Status list_acquisition_runs(::grpc::ClientContext* context, const ::minknow_api::acquisition::ListAcquisitionRunsRequest& request, ::minknow_api::acquisition::ListAcquisitionRunsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::ListAcquisitionRunsResponse>> Asynclist_acquisition_runs(::grpc::ClientContext* context, const ::minknow_api::acquisition::ListAcquisitionRunsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::ListAcquisitionRunsResponse>>(Asynclist_acquisition_runsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::ListAcquisitionRunsResponse>> PrepareAsynclist_acquisition_runs(::grpc::ClientContext* context, const ::minknow_api::acquisition::ListAcquisitionRunsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::ListAcquisitionRunsResponse>>(PrepareAsynclist_acquisition_runsRaw(context, request, cq));
    }
    ::grpc::Status get_current_acquisition_run(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetCurrentAcquisitionRunRequest& request, ::minknow_api::acquisition::AcquisitionRunInfo* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::AcquisitionRunInfo>> Asyncget_current_acquisition_run(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetCurrentAcquisitionRunRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::AcquisitionRunInfo>>(Asyncget_current_acquisition_runRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::AcquisitionRunInfo>> PrepareAsyncget_current_acquisition_run(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetCurrentAcquisitionRunRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::AcquisitionRunInfo>>(PrepareAsyncget_current_acquisition_runRaw(context, request, cq));
    }
    ::grpc::Status set_signal_reader(::grpc::ClientContext* context, const ::minknow_api::acquisition::SetSignalReaderRequest& request, ::minknow_api::acquisition::SetSignalReaderResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::SetSignalReaderResponse>> Asyncset_signal_reader(::grpc::ClientContext* context, const ::minknow_api::acquisition::SetSignalReaderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::SetSignalReaderResponse>>(Asyncset_signal_readerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::SetSignalReaderResponse>> PrepareAsyncset_signal_reader(::grpc::ClientContext* context, const ::minknow_api::acquisition::SetSignalReaderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::SetSignalReaderResponse>>(PrepareAsyncset_signal_readerRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void start(::grpc::ClientContext* context, const ::minknow_api::acquisition::StartRequest* request, ::minknow_api::acquisition::StartResponse* response, std::function<void(::grpc::Status)>) override;
      void start(::grpc::ClientContext* context, const ::minknow_api::acquisition::StartRequest* request, ::minknow_api::acquisition::StartResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void stop(::grpc::ClientContext* context, const ::minknow_api::acquisition::StopRequest* request, ::minknow_api::acquisition::StopResponse* response, std::function<void(::grpc::Status)>) override;
      void stop(::grpc::ClientContext* context, const ::minknow_api::acquisition::StopRequest* request, ::minknow_api::acquisition::StopResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void watch_for_status_change(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::minknow_api::acquisition::WatchForStatusChangeRequest,::minknow_api::acquisition::WatchForStatusChangeResponse>* reactor) override;
      void watch_current_acquisition_run(::grpc::ClientContext* context, const ::minknow_api::acquisition::WatchCurrentAcquisitionRunRequest* request, ::grpc::ClientReadReactor< ::minknow_api::acquisition::AcquisitionRunInfo>* reactor) override;
      void current_status(::grpc::ClientContext* context, const ::minknow_api::acquisition::CurrentStatusRequest* request, ::minknow_api::acquisition::CurrentStatusResponse* response, std::function<void(::grpc::Status)>) override;
      void current_status(::grpc::ClientContext* context, const ::minknow_api::acquisition::CurrentStatusRequest* request, ::minknow_api::acquisition::CurrentStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_progress(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetProgressRequest* request, ::minknow_api::acquisition::GetProgressResponse* response, std::function<void(::grpc::Status)>) override;
      void get_progress(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetProgressRequest* request, ::minknow_api::acquisition::GetProgressResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_acquisition_info(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetAcquisitionRunInfoRequest* request, ::minknow_api::acquisition::AcquisitionRunInfo* response, std::function<void(::grpc::Status)>) override;
      void get_acquisition_info(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetAcquisitionRunInfoRequest* request, ::minknow_api::acquisition::AcquisitionRunInfo* response, ::grpc::ClientUnaryReactor* reactor) override;
      void list_acquisition_runs(::grpc::ClientContext* context, const ::minknow_api::acquisition::ListAcquisitionRunsRequest* request, ::minknow_api::acquisition::ListAcquisitionRunsResponse* response, std::function<void(::grpc::Status)>) override;
      void list_acquisition_runs(::grpc::ClientContext* context, const ::minknow_api::acquisition::ListAcquisitionRunsRequest* request, ::minknow_api::acquisition::ListAcquisitionRunsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_current_acquisition_run(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetCurrentAcquisitionRunRequest* request, ::minknow_api::acquisition::AcquisitionRunInfo* response, std::function<void(::grpc::Status)>) override;
      void get_current_acquisition_run(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetCurrentAcquisitionRunRequest* request, ::minknow_api::acquisition::AcquisitionRunInfo* response, ::grpc::ClientUnaryReactor* reactor) override;
      void set_signal_reader(::grpc::ClientContext* context, const ::minknow_api::acquisition::SetSignalReaderRequest* request, ::minknow_api::acquisition::SetSignalReaderResponse* response, std::function<void(::grpc::Status)>) override;
      void set_signal_reader(::grpc::ClientContext* context, const ::minknow_api::acquisition::SetSignalReaderRequest* request, ::minknow_api::acquisition::SetSignalReaderResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::StartResponse>* AsyncstartRaw(::grpc::ClientContext* context, const ::minknow_api::acquisition::StartRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::StartResponse>* PrepareAsyncstartRaw(::grpc::ClientContext* context, const ::minknow_api::acquisition::StartRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::StopResponse>* AsyncstopRaw(::grpc::ClientContext* context, const ::minknow_api::acquisition::StopRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::StopResponse>* PrepareAsyncstopRaw(::grpc::ClientContext* context, const ::minknow_api::acquisition::StopRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReaderWriter< ::minknow_api::acquisition::WatchForStatusChangeRequest, ::minknow_api::acquisition::WatchForStatusChangeResponse>* watch_for_status_changeRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::minknow_api::acquisition::WatchForStatusChangeRequest, ::minknow_api::acquisition::WatchForStatusChangeResponse>* Asyncwatch_for_status_changeRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::minknow_api::acquisition::WatchForStatusChangeRequest, ::minknow_api::acquisition::WatchForStatusChangeResponse>* PrepareAsyncwatch_for_status_changeRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::minknow_api::acquisition::AcquisitionRunInfo>* watch_current_acquisition_runRaw(::grpc::ClientContext* context, const ::minknow_api::acquisition::WatchCurrentAcquisitionRunRequest& request) override;
    ::grpc::ClientAsyncReader< ::minknow_api::acquisition::AcquisitionRunInfo>* Asyncwatch_current_acquisition_runRaw(::grpc::ClientContext* context, const ::minknow_api::acquisition::WatchCurrentAcquisitionRunRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::minknow_api::acquisition::AcquisitionRunInfo>* PrepareAsyncwatch_current_acquisition_runRaw(::grpc::ClientContext* context, const ::minknow_api::acquisition::WatchCurrentAcquisitionRunRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::CurrentStatusResponse>* Asynccurrent_statusRaw(::grpc::ClientContext* context, const ::minknow_api::acquisition::CurrentStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::CurrentStatusResponse>* PrepareAsynccurrent_statusRaw(::grpc::ClientContext* context, const ::minknow_api::acquisition::CurrentStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::GetProgressResponse>* Asyncget_progressRaw(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetProgressRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::GetProgressResponse>* PrepareAsyncget_progressRaw(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetProgressRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::AcquisitionRunInfo>* Asyncget_acquisition_infoRaw(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetAcquisitionRunInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::AcquisitionRunInfo>* PrepareAsyncget_acquisition_infoRaw(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetAcquisitionRunInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::ListAcquisitionRunsResponse>* Asynclist_acquisition_runsRaw(::grpc::ClientContext* context, const ::minknow_api::acquisition::ListAcquisitionRunsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::ListAcquisitionRunsResponse>* PrepareAsynclist_acquisition_runsRaw(::grpc::ClientContext* context, const ::minknow_api::acquisition::ListAcquisitionRunsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::AcquisitionRunInfo>* Asyncget_current_acquisition_runRaw(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetCurrentAcquisitionRunRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::AcquisitionRunInfo>* PrepareAsyncget_current_acquisition_runRaw(::grpc::ClientContext* context, const ::minknow_api::acquisition::GetCurrentAcquisitionRunRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::SetSignalReaderResponse>* Asyncset_signal_readerRaw(::grpc::ClientContext* context, const ::minknow_api::acquisition::SetSignalReaderRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::acquisition::SetSignalReaderResponse>* PrepareAsyncset_signal_readerRaw(::grpc::ClientContext* context, const ::minknow_api::acquisition::SetSignalReaderRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_start_;
    const ::grpc::internal::RpcMethod rpcmethod_stop_;
    const ::grpc::internal::RpcMethod rpcmethod_watch_for_status_change_;
    const ::grpc::internal::RpcMethod rpcmethod_watch_current_acquisition_run_;
    const ::grpc::internal::RpcMethod rpcmethod_current_status_;
    const ::grpc::internal::RpcMethod rpcmethod_get_progress_;
    const ::grpc::internal::RpcMethod rpcmethod_get_acquisition_info_;
    const ::grpc::internal::RpcMethod rpcmethod_list_acquisition_runs_;
    const ::grpc::internal::RpcMethod rpcmethod_get_current_acquisition_run_;
    const ::grpc::internal::RpcMethod rpcmethod_set_signal_reader_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Starts reading data from the device
    //
    // Some setup calls will need to be made before starting data acquisition: particularly setting the analysis configuration,
    // calibration, read writer and bulk writer config and some device calls such as setting the sampling frequency
    //
    // If acqusition is already running (even in the FINISHING state), this call will fail.
    //
    // On MinIONs and GridIONs, this will enable the ASIC power supply if it is not already enabled.
    // See StopRequest.keep_power_on for more details about the implications of this.
    //
    // The rpc will return once `current_status` is "PROCESSING" or an error occurs and acqusition fails to start.
    virtual ::grpc::Status start(::grpc::ServerContext* context, const ::minknow_api::acquisition::StartRequest* request, ::minknow_api::acquisition::StartResponse* response);
    // Stops data acquisition.
    //
    // Can specify a stop mode that handles what is done with the data when data acquisition is stopped. Refer to the enum
    // description for documentation on what each mode does.
    //
    // Be aware that this command will return as soon as Minknow enters the FINISHING state and not the READY state.
    // So if starting a new experiment then you will have to wait for the READY state seperately
    virtual ::grpc::Status stop(::grpc::ServerContext* context, const ::minknow_api::acquisition::StopRequest* request, ::minknow_api::acquisition::StopResponse* response);
    // Watches for status changes within MinKNOW. Status states are defined from MinknowStatus enum.
    // This is a bi-directional stream where the incoming response stream will return everytime the status has changed
    // and the request stream is used to stop the watcher. Refer to http://www.grpc.io/docs/tutorials/basic/python.html
    // to see how bi-directoional streaming works in grpc, but essentially when calling this function the user will have
    // to pass in a generator that will eventually yield a WatchForStatusChangeRequest(stop=True) to the cpp side.
    // A wrapper class for this is provided in the Python code.
    //
    // The function will first return with the current status that MinKNOW is in. Every response thereafter will be a
    // change from one status to another.
    //
    // The ERROR_STATUS state includes errors during transition between states. If that happens, MinKNOW will
    // try to revert to the READY state. It is up to the user to determine if they wish to try to wait for MinKNOW to
    // correct itself or to try some other course of action
    virtual ::grpc::Status watch_for_status_change(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::minknow_api::acquisition::WatchForStatusChangeResponse, ::minknow_api::acquisition::WatchForStatusChangeRequest>* stream);
    // Returns current acquisition run info and streams any changes to the current acquisition
    //
    // This call can be made even if acquisition is not running. In this case, the next streamed
    // response will be the start of a new acquisition and you will receive updates for that acquisition
    // until it finishes.
    //
    // If an acquisition finishes this stream will still continue to run and you will be notified when a new acquisition starts.
    //
    // Note if you begin this stream before any acquisition is started in minknow the state is `ACQUISITION_COMPLETED`.
    //
    // Since 1.13
    virtual ::grpc::Status watch_current_acquisition_run(::grpc::ServerContext* context, const ::minknow_api::acquisition::WatchCurrentAcquisitionRunRequest* request, ::grpc::ServerWriter< ::minknow_api::acquisition::AcquisitionRunInfo>* writer);
    // Check the current status of MinKNOW.
    virtual ::grpc::Status current_status(::grpc::ServerContext* context, const ::minknow_api::acquisition::CurrentStatusRequest* request, ::minknow_api::acquisition::CurrentStatusResponse* response);
    // Information on how much data has been acquired, processed and written.
    virtual ::grpc::Status get_progress(::grpc::ServerContext* context, const ::minknow_api::acquisition::GetProgressRequest* request, ::minknow_api::acquisition::GetProgressResponse* response);
    // Gets information about an acquisition run, run within this instance on MinKNOW.
    //
    // If no run ID is provided, information about the most recently started acquisition run is
    // provided.
    //
    // Since 1.11
    virtual ::grpc::Status get_acquisition_info(::grpc::ServerContext* context, const ::minknow_api::acquisition::GetAcquisitionRunInfoRequest* request, ::minknow_api::acquisition::AcquisitionRunInfo* response);
    // Gets information about all previous acquisitions.
    //
    // Since 1.11
    virtual ::grpc::Status list_acquisition_runs(::grpc::ServerContext* context, const ::minknow_api::acquisition::ListAcquisitionRunsRequest* request, ::minknow_api::acquisition::ListAcquisitionRunsResponse* response);
    // Returns the name and run id of the currently running acquisition.
    //
    // Will fail with FAILED_PRECONDITION if there is no acquisition running
    //
    // Since 1.11
    virtual ::grpc::Status get_current_acquisition_run(::grpc::ServerContext* context, const ::minknow_api::acquisition::GetCurrentAcquisitionRunRequest* request, ::minknow_api::acquisition::AcquisitionRunInfo* response);
    // Specify the signal reader to use
    //
    // Since 3.6
    virtual ::grpc::Status set_signal_reader(::grpc::ServerContext* context, const ::minknow_api::acquisition::SetSignalReaderRequest* request, ::minknow_api::acquisition::SetSignalReaderResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_start : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_start() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_start() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status start(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::StartRequest* /*request*/, ::minknow_api::acquisition::StartResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requeststart(::grpc::ServerContext* context, ::minknow_api::acquisition::StartRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::acquisition::StartResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_stop() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stop(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::StopRequest* /*request*/, ::minknow_api::acquisition::StopResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requeststop(::grpc::ServerContext* context, ::minknow_api::acquisition::StopRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::acquisition::StopResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_watch_for_status_change : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_watch_for_status_change() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_watch_for_status_change() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status watch_for_status_change(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::minknow_api::acquisition::WatchForStatusChangeResponse, ::minknow_api::acquisition::WatchForStatusChangeRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestwatch_for_status_change(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::minknow_api::acquisition::WatchForStatusChangeResponse, ::minknow_api::acquisition::WatchForStatusChangeRequest>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(2, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_watch_current_acquisition_run : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_watch_current_acquisition_run() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_watch_current_acquisition_run() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status watch_current_acquisition_run(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::WatchCurrentAcquisitionRunRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::acquisition::AcquisitionRunInfo>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestwatch_current_acquisition_run(::grpc::ServerContext* context, ::minknow_api::acquisition::WatchCurrentAcquisitionRunRequest* request, ::grpc::ServerAsyncWriter< ::minknow_api::acquisition::AcquisitionRunInfo>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(3, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_current_status : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_current_status() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_current_status() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status current_status(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::CurrentStatusRequest* /*request*/, ::minknow_api::acquisition::CurrentStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestcurrent_status(::grpc::ServerContext* context, ::minknow_api::acquisition::CurrentStatusRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::acquisition::CurrentStatusResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_progress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_progress() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_get_progress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_progress(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::GetProgressRequest* /*request*/, ::minknow_api::acquisition::GetProgressResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_progress(::grpc::ServerContext* context, ::minknow_api::acquisition::GetProgressRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::acquisition::GetProgressResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_acquisition_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_acquisition_info() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_get_acquisition_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_acquisition_info(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::GetAcquisitionRunInfoRequest* /*request*/, ::minknow_api::acquisition::AcquisitionRunInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_acquisition_info(::grpc::ServerContext* context, ::minknow_api::acquisition::GetAcquisitionRunInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::acquisition::AcquisitionRunInfo>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_list_acquisition_runs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_list_acquisition_runs() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_list_acquisition_runs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status list_acquisition_runs(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::ListAcquisitionRunsRequest* /*request*/, ::minknow_api::acquisition::ListAcquisitionRunsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestlist_acquisition_runs(::grpc::ServerContext* context, ::minknow_api::acquisition::ListAcquisitionRunsRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::acquisition::ListAcquisitionRunsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_current_acquisition_run : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_current_acquisition_run() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_get_current_acquisition_run() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_current_acquisition_run(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::GetCurrentAcquisitionRunRequest* /*request*/, ::minknow_api::acquisition::AcquisitionRunInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_current_acquisition_run(::grpc::ServerContext* context, ::minknow_api::acquisition::GetCurrentAcquisitionRunRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::acquisition::AcquisitionRunInfo>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_set_signal_reader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_set_signal_reader() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_set_signal_reader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_signal_reader(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::SetSignalReaderRequest* /*request*/, ::minknow_api::acquisition::SetSignalReaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_signal_reader(::grpc::ServerContext* context, ::minknow_api::acquisition::SetSignalReaderRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::acquisition::SetSignalReaderResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_start<WithAsyncMethod_stop<WithAsyncMethod_watch_for_status_change<WithAsyncMethod_watch_current_acquisition_run<WithAsyncMethod_current_status<WithAsyncMethod_get_progress<WithAsyncMethod_get_acquisition_info<WithAsyncMethod_list_acquisition_runs<WithAsyncMethod_get_current_acquisition_run<WithAsyncMethod_set_signal_reader<Service > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_start : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_start() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::acquisition::StartRequest, ::minknow_api::acquisition::StartResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::acquisition::StartRequest* request, ::minknow_api::acquisition::StartResponse* response) { return this->start(context, request, response); }));}
    void SetMessageAllocatorFor_start(
        ::grpc::MessageAllocator< ::minknow_api::acquisition::StartRequest, ::minknow_api::acquisition::StartResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::acquisition::StartRequest, ::minknow_api::acquisition::StartResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_start() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status start(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::StartRequest* /*request*/, ::minknow_api::acquisition::StartResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* start(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::acquisition::StartRequest* /*request*/, ::minknow_api::acquisition::StartResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_stop() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::acquisition::StopRequest, ::minknow_api::acquisition::StopResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::acquisition::StopRequest* request, ::minknow_api::acquisition::StopResponse* response) { return this->stop(context, request, response); }));}
    void SetMessageAllocatorFor_stop(
        ::grpc::MessageAllocator< ::minknow_api::acquisition::StopRequest, ::minknow_api::acquisition::StopResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::acquisition::StopRequest, ::minknow_api::acquisition::StopResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stop(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::StopRequest* /*request*/, ::minknow_api::acquisition::StopResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* stop(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::acquisition::StopRequest* /*request*/, ::minknow_api::acquisition::StopResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_watch_for_status_change : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_watch_for_status_change() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackBidiHandler< ::minknow_api::acquisition::WatchForStatusChangeRequest, ::minknow_api::acquisition::WatchForStatusChangeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->watch_for_status_change(context); }));
    }
    ~WithCallbackMethod_watch_for_status_change() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status watch_for_status_change(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::minknow_api::acquisition::WatchForStatusChangeResponse, ::minknow_api::acquisition::WatchForStatusChangeRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::minknow_api::acquisition::WatchForStatusChangeRequest, ::minknow_api::acquisition::WatchForStatusChangeResponse>* watch_for_status_change(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_watch_current_acquisition_run : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_watch_current_acquisition_run() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackServerStreamingHandler< ::minknow_api::acquisition::WatchCurrentAcquisitionRunRequest, ::minknow_api::acquisition::AcquisitionRunInfo>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::acquisition::WatchCurrentAcquisitionRunRequest* request) { return this->watch_current_acquisition_run(context, request); }));
    }
    ~WithCallbackMethod_watch_current_acquisition_run() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status watch_current_acquisition_run(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::WatchCurrentAcquisitionRunRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::acquisition::AcquisitionRunInfo>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::minknow_api::acquisition::AcquisitionRunInfo>* watch_current_acquisition_run(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::acquisition::WatchCurrentAcquisitionRunRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_current_status : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_current_status() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::acquisition::CurrentStatusRequest, ::minknow_api::acquisition::CurrentStatusResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::acquisition::CurrentStatusRequest* request, ::minknow_api::acquisition::CurrentStatusResponse* response) { return this->current_status(context, request, response); }));}
    void SetMessageAllocatorFor_current_status(
        ::grpc::MessageAllocator< ::minknow_api::acquisition::CurrentStatusRequest, ::minknow_api::acquisition::CurrentStatusResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::acquisition::CurrentStatusRequest, ::minknow_api::acquisition::CurrentStatusResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_current_status() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status current_status(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::CurrentStatusRequest* /*request*/, ::minknow_api::acquisition::CurrentStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* current_status(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::acquisition::CurrentStatusRequest* /*request*/, ::minknow_api::acquisition::CurrentStatusResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_progress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_progress() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::acquisition::GetProgressRequest, ::minknow_api::acquisition::GetProgressResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::acquisition::GetProgressRequest* request, ::minknow_api::acquisition::GetProgressResponse* response) { return this->get_progress(context, request, response); }));}
    void SetMessageAllocatorFor_get_progress(
        ::grpc::MessageAllocator< ::minknow_api::acquisition::GetProgressRequest, ::minknow_api::acquisition::GetProgressResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::acquisition::GetProgressRequest, ::minknow_api::acquisition::GetProgressResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_progress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_progress(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::GetProgressRequest* /*request*/, ::minknow_api::acquisition::GetProgressResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_progress(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::acquisition::GetProgressRequest* /*request*/, ::minknow_api::acquisition::GetProgressResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_acquisition_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_acquisition_info() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::acquisition::GetAcquisitionRunInfoRequest, ::minknow_api::acquisition::AcquisitionRunInfo>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::acquisition::GetAcquisitionRunInfoRequest* request, ::minknow_api::acquisition::AcquisitionRunInfo* response) { return this->get_acquisition_info(context, request, response); }));}
    void SetMessageAllocatorFor_get_acquisition_info(
        ::grpc::MessageAllocator< ::minknow_api::acquisition::GetAcquisitionRunInfoRequest, ::minknow_api::acquisition::AcquisitionRunInfo>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::acquisition::GetAcquisitionRunInfoRequest, ::minknow_api::acquisition::AcquisitionRunInfo>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_acquisition_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_acquisition_info(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::GetAcquisitionRunInfoRequest* /*request*/, ::minknow_api::acquisition::AcquisitionRunInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_acquisition_info(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::acquisition::GetAcquisitionRunInfoRequest* /*request*/, ::minknow_api::acquisition::AcquisitionRunInfo* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_list_acquisition_runs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_list_acquisition_runs() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::acquisition::ListAcquisitionRunsRequest, ::minknow_api::acquisition::ListAcquisitionRunsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::acquisition::ListAcquisitionRunsRequest* request, ::minknow_api::acquisition::ListAcquisitionRunsResponse* response) { return this->list_acquisition_runs(context, request, response); }));}
    void SetMessageAllocatorFor_list_acquisition_runs(
        ::grpc::MessageAllocator< ::minknow_api::acquisition::ListAcquisitionRunsRequest, ::minknow_api::acquisition::ListAcquisitionRunsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::acquisition::ListAcquisitionRunsRequest, ::minknow_api::acquisition::ListAcquisitionRunsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_list_acquisition_runs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status list_acquisition_runs(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::ListAcquisitionRunsRequest* /*request*/, ::minknow_api::acquisition::ListAcquisitionRunsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* list_acquisition_runs(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::acquisition::ListAcquisitionRunsRequest* /*request*/, ::minknow_api::acquisition::ListAcquisitionRunsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_current_acquisition_run : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_current_acquisition_run() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::acquisition::GetCurrentAcquisitionRunRequest, ::minknow_api::acquisition::AcquisitionRunInfo>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::acquisition::GetCurrentAcquisitionRunRequest* request, ::minknow_api::acquisition::AcquisitionRunInfo* response) { return this->get_current_acquisition_run(context, request, response); }));}
    void SetMessageAllocatorFor_get_current_acquisition_run(
        ::grpc::MessageAllocator< ::minknow_api::acquisition::GetCurrentAcquisitionRunRequest, ::minknow_api::acquisition::AcquisitionRunInfo>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::acquisition::GetCurrentAcquisitionRunRequest, ::minknow_api::acquisition::AcquisitionRunInfo>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_current_acquisition_run() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_current_acquisition_run(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::GetCurrentAcquisitionRunRequest* /*request*/, ::minknow_api::acquisition::AcquisitionRunInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_current_acquisition_run(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::acquisition::GetCurrentAcquisitionRunRequest* /*request*/, ::minknow_api::acquisition::AcquisitionRunInfo* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_set_signal_reader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_set_signal_reader() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::acquisition::SetSignalReaderRequest, ::minknow_api::acquisition::SetSignalReaderResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::acquisition::SetSignalReaderRequest* request, ::minknow_api::acquisition::SetSignalReaderResponse* response) { return this->set_signal_reader(context, request, response); }));}
    void SetMessageAllocatorFor_set_signal_reader(
        ::grpc::MessageAllocator< ::minknow_api::acquisition::SetSignalReaderRequest, ::minknow_api::acquisition::SetSignalReaderResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::acquisition::SetSignalReaderRequest, ::minknow_api::acquisition::SetSignalReaderResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_set_signal_reader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_signal_reader(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::SetSignalReaderRequest* /*request*/, ::minknow_api::acquisition::SetSignalReaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_signal_reader(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::acquisition::SetSignalReaderRequest* /*request*/, ::minknow_api::acquisition::SetSignalReaderResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_start<WithCallbackMethod_stop<WithCallbackMethod_watch_for_status_change<WithCallbackMethod_watch_current_acquisition_run<WithCallbackMethod_current_status<WithCallbackMethod_get_progress<WithCallbackMethod_get_acquisition_info<WithCallbackMethod_list_acquisition_runs<WithCallbackMethod_get_current_acquisition_run<WithCallbackMethod_set_signal_reader<Service > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_start : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_start() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_start() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status start(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::StartRequest* /*request*/, ::minknow_api::acquisition::StartResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_stop() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stop(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::StopRequest* /*request*/, ::minknow_api::acquisition::StopResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_watch_for_status_change : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_watch_for_status_change() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_watch_for_status_change() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status watch_for_status_change(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::minknow_api::acquisition::WatchForStatusChangeResponse, ::minknow_api::acquisition::WatchForStatusChangeRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_watch_current_acquisition_run : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_watch_current_acquisition_run() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_watch_current_acquisition_run() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status watch_current_acquisition_run(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::WatchCurrentAcquisitionRunRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::acquisition::AcquisitionRunInfo>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_current_status : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_current_status() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_current_status() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status current_status(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::CurrentStatusRequest* /*request*/, ::minknow_api::acquisition::CurrentStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_progress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_progress() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_get_progress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_progress(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::GetProgressRequest* /*request*/, ::minknow_api::acquisition::GetProgressResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_acquisition_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_acquisition_info() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_get_acquisition_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_acquisition_info(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::GetAcquisitionRunInfoRequest* /*request*/, ::minknow_api::acquisition::AcquisitionRunInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_list_acquisition_runs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_list_acquisition_runs() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_list_acquisition_runs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status list_acquisition_runs(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::ListAcquisitionRunsRequest* /*request*/, ::minknow_api::acquisition::ListAcquisitionRunsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_current_acquisition_run : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_current_acquisition_run() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_get_current_acquisition_run() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_current_acquisition_run(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::GetCurrentAcquisitionRunRequest* /*request*/, ::minknow_api::acquisition::AcquisitionRunInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_set_signal_reader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_set_signal_reader() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_set_signal_reader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_signal_reader(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::SetSignalReaderRequest* /*request*/, ::minknow_api::acquisition::SetSignalReaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_start : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_start() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_start() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status start(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::StartRequest* /*request*/, ::minknow_api::acquisition::StartResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requeststart(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_stop() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stop(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::StopRequest* /*request*/, ::minknow_api::acquisition::StopResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requeststop(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_watch_for_status_change : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_watch_for_status_change() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_watch_for_status_change() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status watch_for_status_change(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::minknow_api::acquisition::WatchForStatusChangeResponse, ::minknow_api::acquisition::WatchForStatusChangeRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestwatch_for_status_change(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(2, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_watch_current_acquisition_run : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_watch_current_acquisition_run() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_watch_current_acquisition_run() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status watch_current_acquisition_run(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::WatchCurrentAcquisitionRunRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::acquisition::AcquisitionRunInfo>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestwatch_current_acquisition_run(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(3, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_current_status : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_current_status() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_current_status() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status current_status(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::CurrentStatusRequest* /*request*/, ::minknow_api::acquisition::CurrentStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestcurrent_status(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_progress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_progress() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_get_progress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_progress(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::GetProgressRequest* /*request*/, ::minknow_api::acquisition::GetProgressResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_progress(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_acquisition_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_acquisition_info() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_get_acquisition_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_acquisition_info(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::GetAcquisitionRunInfoRequest* /*request*/, ::minknow_api::acquisition::AcquisitionRunInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_acquisition_info(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_list_acquisition_runs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_list_acquisition_runs() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_list_acquisition_runs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status list_acquisition_runs(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::ListAcquisitionRunsRequest* /*request*/, ::minknow_api::acquisition::ListAcquisitionRunsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestlist_acquisition_runs(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_current_acquisition_run : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_current_acquisition_run() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_get_current_acquisition_run() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_current_acquisition_run(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::GetCurrentAcquisitionRunRequest* /*request*/, ::minknow_api::acquisition::AcquisitionRunInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_current_acquisition_run(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_set_signal_reader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_set_signal_reader() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_set_signal_reader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_signal_reader(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::SetSignalReaderRequest* /*request*/, ::minknow_api::acquisition::SetSignalReaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_signal_reader(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_start : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_start() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->start(context, request, response); }));
    }
    ~WithRawCallbackMethod_start() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status start(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::StartRequest* /*request*/, ::minknow_api::acquisition::StartResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* start(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_stop() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->stop(context, request, response); }));
    }
    ~WithRawCallbackMethod_stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stop(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::StopRequest* /*request*/, ::minknow_api::acquisition::StopResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* stop(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_watch_for_status_change : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_watch_for_status_change() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackBidiHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->watch_for_status_change(context); }));
    }
    ~WithRawCallbackMethod_watch_for_status_change() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status watch_for_status_change(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::minknow_api::acquisition::WatchForStatusChangeResponse, ::minknow_api::acquisition::WatchForStatusChangeRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* watch_for_status_change(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_watch_current_acquisition_run : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_watch_current_acquisition_run() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->watch_current_acquisition_run(context, request); }));
    }
    ~WithRawCallbackMethod_watch_current_acquisition_run() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status watch_current_acquisition_run(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::WatchCurrentAcquisitionRunRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::acquisition::AcquisitionRunInfo>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* watch_current_acquisition_run(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_current_status : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_current_status() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->current_status(context, request, response); }));
    }
    ~WithRawCallbackMethod_current_status() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status current_status(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::CurrentStatusRequest* /*request*/, ::minknow_api::acquisition::CurrentStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* current_status(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_progress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_progress() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_progress(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_progress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_progress(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::GetProgressRequest* /*request*/, ::minknow_api::acquisition::GetProgressResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_progress(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_acquisition_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_acquisition_info() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_acquisition_info(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_acquisition_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_acquisition_info(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::GetAcquisitionRunInfoRequest* /*request*/, ::minknow_api::acquisition::AcquisitionRunInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_acquisition_info(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_list_acquisition_runs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_list_acquisition_runs() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->list_acquisition_runs(context, request, response); }));
    }
    ~WithRawCallbackMethod_list_acquisition_runs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status list_acquisition_runs(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::ListAcquisitionRunsRequest* /*request*/, ::minknow_api::acquisition::ListAcquisitionRunsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* list_acquisition_runs(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_current_acquisition_run : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_current_acquisition_run() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_current_acquisition_run(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_current_acquisition_run() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_current_acquisition_run(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::GetCurrentAcquisitionRunRequest* /*request*/, ::minknow_api::acquisition::AcquisitionRunInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_current_acquisition_run(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_set_signal_reader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_set_signal_reader() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->set_signal_reader(context, request, response); }));
    }
    ~WithRawCallbackMethod_set_signal_reader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_signal_reader(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::SetSignalReaderRequest* /*request*/, ::minknow_api::acquisition::SetSignalReaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_signal_reader(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_start : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_start() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::acquisition::StartRequest, ::minknow_api::acquisition::StartResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::acquisition::StartRequest, ::minknow_api::acquisition::StartResponse>* streamer) {
                       return this->Streamedstart(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_start() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status start(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::StartRequest* /*request*/, ::minknow_api::acquisition::StartResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedstart(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::acquisition::StartRequest,::minknow_api::acquisition::StartResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_stop() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::acquisition::StopRequest, ::minknow_api::acquisition::StopResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::acquisition::StopRequest, ::minknow_api::acquisition::StopResponse>* streamer) {
                       return this->Streamedstop(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status stop(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::StopRequest* /*request*/, ::minknow_api::acquisition::StopResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedstop(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::acquisition::StopRequest,::minknow_api::acquisition::StopResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_current_status : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_current_status() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::acquisition::CurrentStatusRequest, ::minknow_api::acquisition::CurrentStatusResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::acquisition::CurrentStatusRequest, ::minknow_api::acquisition::CurrentStatusResponse>* streamer) {
                       return this->Streamedcurrent_status(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_current_status() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status current_status(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::CurrentStatusRequest* /*request*/, ::minknow_api::acquisition::CurrentStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedcurrent_status(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::acquisition::CurrentStatusRequest,::minknow_api::acquisition::CurrentStatusResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_progress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_progress() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::acquisition::GetProgressRequest, ::minknow_api::acquisition::GetProgressResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::acquisition::GetProgressRequest, ::minknow_api::acquisition::GetProgressResponse>* streamer) {
                       return this->Streamedget_progress(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_progress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_progress(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::GetProgressRequest* /*request*/, ::minknow_api::acquisition::GetProgressResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_progress(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::acquisition::GetProgressRequest,::minknow_api::acquisition::GetProgressResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_acquisition_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_acquisition_info() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::acquisition::GetAcquisitionRunInfoRequest, ::minknow_api::acquisition::AcquisitionRunInfo>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::acquisition::GetAcquisitionRunInfoRequest, ::minknow_api::acquisition::AcquisitionRunInfo>* streamer) {
                       return this->Streamedget_acquisition_info(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_acquisition_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_acquisition_info(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::GetAcquisitionRunInfoRequest* /*request*/, ::minknow_api::acquisition::AcquisitionRunInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_acquisition_info(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::acquisition::GetAcquisitionRunInfoRequest,::minknow_api::acquisition::AcquisitionRunInfo>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_list_acquisition_runs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_list_acquisition_runs() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::acquisition::ListAcquisitionRunsRequest, ::minknow_api::acquisition::ListAcquisitionRunsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::acquisition::ListAcquisitionRunsRequest, ::minknow_api::acquisition::ListAcquisitionRunsResponse>* streamer) {
                       return this->Streamedlist_acquisition_runs(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_list_acquisition_runs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status list_acquisition_runs(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::ListAcquisitionRunsRequest* /*request*/, ::minknow_api::acquisition::ListAcquisitionRunsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedlist_acquisition_runs(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::acquisition::ListAcquisitionRunsRequest,::minknow_api::acquisition::ListAcquisitionRunsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_current_acquisition_run : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_current_acquisition_run() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::acquisition::GetCurrentAcquisitionRunRequest, ::minknow_api::acquisition::AcquisitionRunInfo>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::acquisition::GetCurrentAcquisitionRunRequest, ::minknow_api::acquisition::AcquisitionRunInfo>* streamer) {
                       return this->Streamedget_current_acquisition_run(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_current_acquisition_run() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_current_acquisition_run(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::GetCurrentAcquisitionRunRequest* /*request*/, ::minknow_api::acquisition::AcquisitionRunInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_current_acquisition_run(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::acquisition::GetCurrentAcquisitionRunRequest,::minknow_api::acquisition::AcquisitionRunInfo>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_set_signal_reader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_set_signal_reader() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::acquisition::SetSignalReaderRequest, ::minknow_api::acquisition::SetSignalReaderResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::acquisition::SetSignalReaderRequest, ::minknow_api::acquisition::SetSignalReaderResponse>* streamer) {
                       return this->Streamedset_signal_reader(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_set_signal_reader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status set_signal_reader(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::SetSignalReaderRequest* /*request*/, ::minknow_api::acquisition::SetSignalReaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedset_signal_reader(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::acquisition::SetSignalReaderRequest,::minknow_api::acquisition::SetSignalReaderResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_start<WithStreamedUnaryMethod_stop<WithStreamedUnaryMethod_current_status<WithStreamedUnaryMethod_get_progress<WithStreamedUnaryMethod_get_acquisition_info<WithStreamedUnaryMethod_list_acquisition_runs<WithStreamedUnaryMethod_get_current_acquisition_run<WithStreamedUnaryMethod_set_signal_reader<Service > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_watch_current_acquisition_run : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_watch_current_acquisition_run() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::minknow_api::acquisition::WatchCurrentAcquisitionRunRequest, ::minknow_api::acquisition::AcquisitionRunInfo>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::minknow_api::acquisition::WatchCurrentAcquisitionRunRequest, ::minknow_api::acquisition::AcquisitionRunInfo>* streamer) {
                       return this->Streamedwatch_current_acquisition_run(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_watch_current_acquisition_run() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status watch_current_acquisition_run(::grpc::ServerContext* /*context*/, const ::minknow_api::acquisition::WatchCurrentAcquisitionRunRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::acquisition::AcquisitionRunInfo>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status Streamedwatch_current_acquisition_run(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::minknow_api::acquisition::WatchCurrentAcquisitionRunRequest,::minknow_api::acquisition::AcquisitionRunInfo>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_watch_current_acquisition_run<Service > SplitStreamedService;
  typedef WithStreamedUnaryMethod_start<WithStreamedUnaryMethod_stop<WithSplitStreamingMethod_watch_current_acquisition_run<WithStreamedUnaryMethod_current_status<WithStreamedUnaryMethod_get_progress<WithStreamedUnaryMethod_get_acquisition_info<WithStreamedUnaryMethod_list_acquisition_runs<WithStreamedUnaryMethod_get_current_acquisition_run<WithStreamedUnaryMethod_set_signal_reader<Service > > > > > > > > > StreamedService;
};

}  // namespace acquisition
}  // namespace minknow_api


#endif  // GRPC_minknow_5fapi_2facquisition_2eproto__INCLUDED
