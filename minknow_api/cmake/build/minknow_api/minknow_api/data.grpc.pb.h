// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: minknow_api/data.proto
#ifndef GRPC_minknow_5fapi_2fdata_2eproto__INCLUDED
#define GRPC_minknow_5fapi_2fdata_2eproto__INCLUDED

#include "minknow_api/data.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace minknow_api {
namespace data {

class DataService final {
 public:
  static constexpr char const* service_full_name() {
    return "minknow_api.data.DataService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Get the channel states for all channels from the device.
    //
    // This will return all the channel states from the moment of calling until the rpc is
    // closed by the user. If the user stops acquisition, the rpc will return with the
    // ABORTED status. If the user cancels the rpc, the status will be CANCELLED.
    //
    // The first messages returned will retrieve the current channel state for all channels
    // On the MinION, the current state for all channels will be included in the first message.
    // For PromethION, it will be split on multiple messages.
    //
    // To determine which channels have been returned, please check the channel member in the
    // messages returned in the response.
    //
    // The response will be streamed, and we will provide a message as soon as there are channel
    // state changes (though note that some channels could stay in the same state for a long time),
    // so there is no guaranteed frequency of the messages returned. However, because a response
    // message includes multiple channels, it is very likely that we have messages every few seconds.
    // As in, it is likely that at least some of the channels will change every so often, therefore
    // messages will be generated. For example, if 5 out of 512 channels change the state in the
    // same time, there will be a message containing all 5 changes. Later on, if other channels
    // change their state we will receive another message containing those and so on. Note that
    // MinKNOW tries to group as many channel state changes in a single message, up to the message
    // limit size, which is currently set to 32kB.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::minknow_api::data::GetChannelStatesResponse>> get_channel_states(::grpc::ClientContext* context, const ::minknow_api::data::GetChannelStatesRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::minknow_api::data::GetChannelStatesResponse>>(get_channel_statesRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::data::GetChannelStatesResponse>> Asyncget_channel_states(::grpc::ClientContext* context, const ::minknow_api::data::GetChannelStatesRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::data::GetChannelStatesResponse>>(Asyncget_channel_statesRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::data::GetChannelStatesResponse>> PrepareAsyncget_channel_states(::grpc::ClientContext* context, const ::minknow_api::data::GetChannelStatesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::data::GetChannelStatesResponse>>(PrepareAsyncget_channel_statesRaw(context, request, cq));
    }
    // Get the data types of data items produced by this service.
    //
    // In order to allow clients to efficiently deal with large volumes of data in languages such as
    // Python, this service can provide data as raw bytes. This call can be used to determine how to
    // interpret those bytes. This can be used to construct an appropriate numpy dtype, for example.
    virtual ::grpc::Status get_data_types(::grpc::ClientContext* context, const ::minknow_api::data::GetDataTypesRequest& request, ::minknow_api::data::GetDataTypesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::data::GetDataTypesResponse>> Asyncget_data_types(::grpc::ClientContext* context, const ::minknow_api::data::GetDataTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::data::GetDataTypesResponse>>(Asyncget_data_typesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::data::GetDataTypesResponse>> PrepareAsyncget_data_types(::grpc::ClientContext* context, const ::minknow_api::data::GetDataTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::data::GetDataTypesResponse>>(PrepareAsyncget_data_typesRaw(context, request, cq));
    }
    // Get signal data from the device.
    //
    // This can be used to sample the signal being produced by the device. The signal can be
    // returned as raw ADC values or as calibrated picoamp (pA) values; see ``set_calibration`` on
    // the device service for the values used in this conversion.
    //
    // In addition to the signal, this can return the associated channel configuration and/or bias
    // voltage information, to help analyse the data.
    //
    // If bias voltage information is requested, one bias voltage sample will be provided for each
    // signal sample (on any given channel). So if you request 20 samples of signal data and also
    // bias voltages, you will get 20 signal samples on each channel and also 20 bias voltage
    // samples. Bias voltages are always given in millivolts, and no corrections need to be applied
    // (for example, the 5x amplifier on a MinION is already accounted for).
    //
    // If channel configuration information is requested, each channel will have the starting
    // channel configuration (with offset 0 to indicate it applies to the first sample on that
    // channel), as well as any configuration changes that affect any of the returned samples.
    //
    // If a device settings change RPC has completed before this method is called, the data returned
    // is guaranteed to have been generated by the device after those settings were applied.
    // However, note that no guarantee is made about how device settings changes that overlap with
    // this request will affect the returned data.
    //
    // The response will be streamed. In order to limit the size of each response message, any given
    // message may include data from only a subset of the requested channels.
    //
    // Note that the data is returned as bytes fields. See the GetSignalBytesResponse documentation
    // for more details about how to interpret the value. In Python code, the minknow.Device class
    // provides a convenience wrapper method to convert the data into numpy arrays.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::minknow_api::data::GetSignalBytesResponse>> get_signal_bytes(::grpc::ClientContext* context, const ::minknow_api::data::GetSignalBytesRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::minknow_api::data::GetSignalBytesResponse>>(get_signal_bytesRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::data::GetSignalBytesResponse>> Asyncget_signal_bytes(::grpc::ClientContext* context, const ::minknow_api::data::GetSignalBytesRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::data::GetSignalBytesResponse>>(Asyncget_signal_bytesRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::data::GetSignalBytesResponse>> PrepareAsyncget_signal_bytes(::grpc::ClientContext* context, const ::minknow_api::data::GetSignalBytesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::data::GetSignalBytesResponse>>(PrepareAsyncget_signal_bytesRaw(context, request, cq));
    }
    // Get summarised signal data from the device.
    //
    // This provides signal data from the device, like get_signal_bytes, but instead of all the
    // data, it divides the data up into windows, and provides the minimum and maximum values for
    // each window.
    //
    // This call is aimed at visualisations of data (ie: a traceviewer interface). As such, it does
    // not provide most of the guarantees and options that get_signal_bytes() does. No bias voltage
    // or channel configuration data is provided, it is not possible to set the number of samples
    // desired up front (just cancel the call when no further data is required) and no guarantees
    // are made about whether particular commands have been applied to the returned data.
    //
    // Also unlike get_signal_bytes(), the returned data is in native types, and does not require
    // any further interpretation based on get_data_types(). This can be done performantly because
    // of the reduced amount of data transmitted.
    //
    // The response will be streamed. In order to limit the size of each response message, any given
    // message may include data from only a subset of the requested channels.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::minknow_api::data::GetSignalMinMaxResponse>> get_signal_min_max(::grpc::ClientContext* context, const ::minknow_api::data::GetSignalMinMaxRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::minknow_api::data::GetSignalMinMaxResponse>>(get_signal_min_maxRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::data::GetSignalMinMaxResponse>> Asyncget_signal_min_max(::grpc::ClientContext* context, const ::minknow_api::data::GetSignalMinMaxRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::data::GetSignalMinMaxResponse>>(Asyncget_signal_min_maxRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::data::GetSignalMinMaxResponse>> PrepareAsyncget_signal_min_max(::grpc::ClientContext* context, const ::minknow_api::data::GetSignalMinMaxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::data::GetSignalMinMaxResponse>>(PrepareAsyncget_signal_min_maxRaw(context, request, cq));
    }
    // Call this to force re-evaluating the channel states. This will make sure the next
    // channel state evaluated will be 'unclassified_following_reset'. If the analyser is behind,
    // and older data will come for evaluation, it will result in changing the state to 'pending_manual_reset'.
    // So tipically, after a resetting the channel states, the user would see in the bulk file
    // 'unclassified_following_reset', 'pending_manual_reset', 'pending_manual_reset', until the relevant data
    // comes through to the analyser and it will start outputting the normal channel states again.
    // If the analyser is not behind, the user should ideally see just the 'unclassified_following_reset' state.
    //
    // This call is blocking - it will return from the rpc when it would have processed the
    // 'unclassified_following_reset' in the analyser. If the rpc takes more than 1 minute
    // it will exit with the ABORTED status. This can happen if the analyser is more than 1 minute behind
    // for example (in practice it shouldn't be the case). If the RPC exits with the ABORT status, it means
    // the channels are to be reset in the future, but the analyser did not reach that point yet.
    //
    // Only one of these can be executed at a given time. If multiple threads call this simultaneously,
    // it will execute the first request and it will exit with FAILED_PRECONDITION for the rest. If an RPC
    // exited with the ABORT status, another RPC can immediately be started. The failed RPC would have not
    // reset the channel states, and the user could try again. The second RPC will return as soon as the first
    // reset happens, so this will not be necessarily waiting for the second acquisition index to be
    // processed.
    virtual ::grpc::Status reset_channel_states(::grpc::ClientContext* context, const ::minknow_api::data::ResetChannelStatesRequest& request, ::minknow_api::data::ResetChannelStatesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::data::ResetChannelStatesResponse>> Asyncreset_channel_states(::grpc::ClientContext* context, const ::minknow_api::data::ResetChannelStatesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::data::ResetChannelStatesResponse>>(Asyncreset_channel_statesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::data::ResetChannelStatesResponse>> PrepareAsyncreset_channel_states(::grpc::ClientContext* context, const ::minknow_api::data::ResetChannelStatesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::data::ResetChannelStatesResponse>>(PrepareAsyncreset_channel_statesRaw(context, request, cq));
    }
    // Forces channels to be fixed on a custom channel state. The channels will not be re-evaluated until
    // they are activated using unlock_channel_states.
    // To create a channel state that will never be entered unless manually set using this call,
    // use the "never_evaluated" criteria:
    // "9": { "group": {...},
    //        "logic": {
    //            "rank": 0,
    //            "criteria": "never_evaluated"
    //             },
    //         "name": "custom_name_picked_by_the_user"
    //       }
    //
    // While the this RPC has the power of forcing a channel to any valid state other than 'unclassified',
    // it is intended to be used with channel states that are designed for this functionality (i.e. that
    // are never evaluated).
    // Has to be called while acquiring data, fails otherwise.
    // The forced channels are reset (reset = every channel back to being evaluated) every time a
    // new acquisition sequence is started.
    //
    // NOTE:
    // Calls to lock_channel_states and unlock_channel_states cannot be done in the same time.
    // If any of these two is called while any of these is already running, the grpc will return
    // with an error.
    virtual ::grpc::Status lock_channel_states(::grpc::ClientContext* context, const ::minknow_api::data::LockChannelStatesRequest& request, ::minknow_api::data::LockChannelStatesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::data::LockChannelStatesResponse>> Asynclock_channel_states(::grpc::ClientContext* context, const ::minknow_api::data::LockChannelStatesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::data::LockChannelStatesResponse>>(Asynclock_channel_statesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::data::LockChannelStatesResponse>> PrepareAsynclock_channel_states(::grpc::ClientContext* context, const ::minknow_api::data::LockChannelStatesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::data::LockChannelStatesResponse>>(PrepareAsynclock_channel_statesRaw(context, request, cq));
    }
    // Re-activates channels that have been turned-off with force_channels_to_state.
    // Note that 'turning off' refers to channel states only, everything else is still applied on the channel
    // (e.g. mux changes, saturation, commands etc)
    // No action is taken if the channel is already active.
    // Has to be called while acquiring data, fails otherwise.
    // NOTE:
    // Calls to lock_channel_states and unlock_channel_states cannot be done in the same time.
    // If any of these two is called while any of these is already running, the grpc will return
    // with an error.
    virtual ::grpc::Status unlock_channel_states(::grpc::ClientContext* context, const ::minknow_api::data::UnlockChannelStatesRequest& request, ::minknow_api::data::UnlockChannelStatesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::data::UnlockChannelStatesResponse>> Asyncunlock_channel_states(::grpc::ClientContext* context, const ::minknow_api::data::UnlockChannelStatesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::data::UnlockChannelStatesResponse>>(Asyncunlock_channel_statesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::data::UnlockChannelStatesResponse>> PrepareAsyncunlock_channel_states(::grpc::ClientContext* context, const ::minknow_api::data::UnlockChannelStatesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::data::UnlockChannelStatesResponse>>(PrepareAsyncunlock_channel_statesRaw(context, request, cq));
    }
    // Get live reads sent in order to control sequencing behaviour.
    //
    // This method sends current reads (reads that are currently in the sequencer) to the user along
    // with live analysis data in order for real time decisions to be made.
    //
    // The method provides two streams:
    //
    // GetLiveReadsRequest stream:
    //      Sent by the user, provides MinKNOW with actions to take on current reads, actions
    //      taken are sumarised and sent back to the user in the GetLiveReadsResponse stream.
    // GetLiveReadsResponse stream:
    //      Sent to the user, contains a stream of ongoing sequencing information, sent as
    //      regularly as possible, with information on reads in progress, and feedback on actions
    //      taken on the data.
    //
    // note: This method operates on read chunks in MinKNOW, and will send at minimum, 1 read
    // chunk to the user. In order to reduce latency on the method, tune the following options:
    //
    // The raw chunk size data is processed in minknow (specified in samples):
    //      app_conf/hyperstream.raw_data_intermediate.size
    //      app_conf/hyperstream.raw_meta_data_intermediate.size
    //
    // The maximum read chunk size - changing the size read chunks are processed in minknow:
    //      analysis_conf/read_detection.break_reads_after_seconds
    //
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::minknow_api::data::GetLiveReadsRequest, ::minknow_api::data::GetLiveReadsResponse>> get_live_reads(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::minknow_api::data::GetLiveReadsRequest, ::minknow_api::data::GetLiveReadsResponse>>(get_live_readsRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::minknow_api::data::GetLiveReadsRequest, ::minknow_api::data::GetLiveReadsResponse>> Asyncget_live_reads(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::minknow_api::data::GetLiveReadsRequest, ::minknow_api::data::GetLiveReadsResponse>>(Asyncget_live_readsRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::minknow_api::data::GetLiveReadsRequest, ::minknow_api::data::GetLiveReadsResponse>> PrepareAsyncget_live_reads(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::minknow_api::data::GetLiveReadsRequest, ::minknow_api::data::GetLiveReadsResponse>>(PrepareAsyncget_live_readsRaw(context, cq));
    }
    // Collects statistics about read (chunk) lengths and signal, split by channel, channel
    // configuration and read (chunk) classification.
    virtual ::grpc::Status get_read_statistics(::grpc::ClientContext* context, const ::minknow_api::data::GetReadStatisticsRequest& request, ::minknow_api::data::GetReadStatisticsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::data::GetReadStatisticsResponse>> Asyncget_read_statistics(::grpc::ClientContext* context, const ::minknow_api::data::GetReadStatisticsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::data::GetReadStatisticsResponse>>(Asyncget_read_statisticsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::data::GetReadStatisticsResponse>> PrepareAsyncget_read_statistics(::grpc::ClientContext* context, const ::minknow_api::data::GetReadStatisticsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::data::GetReadStatisticsResponse>>(PrepareAsyncget_read_statisticsRaw(context, request, cq));
    }
    // Returns various points of yield information for the ongoing experiment, such as complete
    // read information and basecaller progress.
    virtual ::grpc::Status get_experiment_yield_info(::grpc::ClientContext* context, const ::minknow_api::data::GetExperimentYieldInfoRequest& request, ::minknow_api::data::GetExperimentYieldInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::data::GetExperimentYieldInfoResponse>> Asyncget_experiment_yield_info(::grpc::ClientContext* context, const ::minknow_api::data::GetExperimentYieldInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::data::GetExperimentYieldInfoResponse>>(Asyncget_experiment_yield_infoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::data::GetExperimentYieldInfoResponse>> PrepareAsyncget_experiment_yield_info(::grpc::ClientContext* context, const ::minknow_api::data::GetExperimentYieldInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::data::GetExperimentYieldInfoResponse>>(PrepareAsyncget_experiment_yield_infoRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // Get the channel states for all channels from the device.
      //
      // This will return all the channel states from the moment of calling until the rpc is
      // closed by the user. If the user stops acquisition, the rpc will return with the
      // ABORTED status. If the user cancels the rpc, the status will be CANCELLED.
      //
      // The first messages returned will retrieve the current channel state for all channels
      // On the MinION, the current state for all channels will be included in the first message.
      // For PromethION, it will be split on multiple messages.
      //
      // To determine which channels have been returned, please check the channel member in the
      // messages returned in the response.
      //
      // The response will be streamed, and we will provide a message as soon as there are channel
      // state changes (though note that some channels could stay in the same state for a long time),
      // so there is no guaranteed frequency of the messages returned. However, because a response
      // message includes multiple channels, it is very likely that we have messages every few seconds.
      // As in, it is likely that at least some of the channels will change every so often, therefore
      // messages will be generated. For example, if 5 out of 512 channels change the state in the
      // same time, there will be a message containing all 5 changes. Later on, if other channels
      // change their state we will receive another message containing those and so on. Note that
      // MinKNOW tries to group as many channel state changes in a single message, up to the message
      // limit size, which is currently set to 32kB.
      virtual void get_channel_states(::grpc::ClientContext* context, const ::minknow_api::data::GetChannelStatesRequest* request, ::grpc::ClientReadReactor< ::minknow_api::data::GetChannelStatesResponse>* reactor) = 0;
      // Get the data types of data items produced by this service.
      //
      // In order to allow clients to efficiently deal with large volumes of data in languages such as
      // Python, this service can provide data as raw bytes. This call can be used to determine how to
      // interpret those bytes. This can be used to construct an appropriate numpy dtype, for example.
      virtual void get_data_types(::grpc::ClientContext* context, const ::minknow_api::data::GetDataTypesRequest* request, ::minknow_api::data::GetDataTypesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_data_types(::grpc::ClientContext* context, const ::minknow_api::data::GetDataTypesRequest* request, ::minknow_api::data::GetDataTypesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Get signal data from the device.
      //
      // This can be used to sample the signal being produced by the device. The signal can be
      // returned as raw ADC values or as calibrated picoamp (pA) values; see ``set_calibration`` on
      // the device service for the values used in this conversion.
      //
      // In addition to the signal, this can return the associated channel configuration and/or bias
      // voltage information, to help analyse the data.
      //
      // If bias voltage information is requested, one bias voltage sample will be provided for each
      // signal sample (on any given channel). So if you request 20 samples of signal data and also
      // bias voltages, you will get 20 signal samples on each channel and also 20 bias voltage
      // samples. Bias voltages are always given in millivolts, and no corrections need to be applied
      // (for example, the 5x amplifier on a MinION is already accounted for).
      //
      // If channel configuration information is requested, each channel will have the starting
      // channel configuration (with offset 0 to indicate it applies to the first sample on that
      // channel), as well as any configuration changes that affect any of the returned samples.
      //
      // If a device settings change RPC has completed before this method is called, the data returned
      // is guaranteed to have been generated by the device after those settings were applied.
      // However, note that no guarantee is made about how device settings changes that overlap with
      // this request will affect the returned data.
      //
      // The response will be streamed. In order to limit the size of each response message, any given
      // message may include data from only a subset of the requested channels.
      //
      // Note that the data is returned as bytes fields. See the GetSignalBytesResponse documentation
      // for more details about how to interpret the value. In Python code, the minknow.Device class
      // provides a convenience wrapper method to convert the data into numpy arrays.
      virtual void get_signal_bytes(::grpc::ClientContext* context, const ::minknow_api::data::GetSignalBytesRequest* request, ::grpc::ClientReadReactor< ::minknow_api::data::GetSignalBytesResponse>* reactor) = 0;
      // Get summarised signal data from the device.
      //
      // This provides signal data from the device, like get_signal_bytes, but instead of all the
      // data, it divides the data up into windows, and provides the minimum and maximum values for
      // each window.
      //
      // This call is aimed at visualisations of data (ie: a traceviewer interface). As such, it does
      // not provide most of the guarantees and options that get_signal_bytes() does. No bias voltage
      // or channel configuration data is provided, it is not possible to set the number of samples
      // desired up front (just cancel the call when no further data is required) and no guarantees
      // are made about whether particular commands have been applied to the returned data.
      //
      // Also unlike get_signal_bytes(), the returned data is in native types, and does not require
      // any further interpretation based on get_data_types(). This can be done performantly because
      // of the reduced amount of data transmitted.
      //
      // The response will be streamed. In order to limit the size of each response message, any given
      // message may include data from only a subset of the requested channels.
      virtual void get_signal_min_max(::grpc::ClientContext* context, const ::minknow_api::data::GetSignalMinMaxRequest* request, ::grpc::ClientReadReactor< ::minknow_api::data::GetSignalMinMaxResponse>* reactor) = 0;
      // Call this to force re-evaluating the channel states. This will make sure the next
      // channel state evaluated will be 'unclassified_following_reset'. If the analyser is behind,
      // and older data will come for evaluation, it will result in changing the state to 'pending_manual_reset'.
      // So tipically, after a resetting the channel states, the user would see in the bulk file
      // 'unclassified_following_reset', 'pending_manual_reset', 'pending_manual_reset', until the relevant data
      // comes through to the analyser and it will start outputting the normal channel states again.
      // If the analyser is not behind, the user should ideally see just the 'unclassified_following_reset' state.
      //
      // This call is blocking - it will return from the rpc when it would have processed the
      // 'unclassified_following_reset' in the analyser. If the rpc takes more than 1 minute
      // it will exit with the ABORTED status. This can happen if the analyser is more than 1 minute behind
      // for example (in practice it shouldn't be the case). If the RPC exits with the ABORT status, it means
      // the channels are to be reset in the future, but the analyser did not reach that point yet.
      //
      // Only one of these can be executed at a given time. If multiple threads call this simultaneously,
      // it will execute the first request and it will exit with FAILED_PRECONDITION for the rest. If an RPC
      // exited with the ABORT status, another RPC can immediately be started. The failed RPC would have not
      // reset the channel states, and the user could try again. The second RPC will return as soon as the first
      // reset happens, so this will not be necessarily waiting for the second acquisition index to be
      // processed.
      virtual void reset_channel_states(::grpc::ClientContext* context, const ::minknow_api::data::ResetChannelStatesRequest* request, ::minknow_api::data::ResetChannelStatesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void reset_channel_states(::grpc::ClientContext* context, const ::minknow_api::data::ResetChannelStatesRequest* request, ::minknow_api::data::ResetChannelStatesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Forces channels to be fixed on a custom channel state. The channels will not be re-evaluated until
      // they are activated using unlock_channel_states.
      // To create a channel state that will never be entered unless manually set using this call,
      // use the "never_evaluated" criteria:
      // "9": { "group": {...},
      //        "logic": {
      //            "rank": 0,
      //            "criteria": "never_evaluated"
      //             },
      //         "name": "custom_name_picked_by_the_user"
      //       }
      //
      // While the this RPC has the power of forcing a channel to any valid state other than 'unclassified',
      // it is intended to be used with channel states that are designed for this functionality (i.e. that
      // are never evaluated).
      // Has to be called while acquiring data, fails otherwise.
      // The forced channels are reset (reset = every channel back to being evaluated) every time a
      // new acquisition sequence is started.
      //
      // NOTE:
      // Calls to lock_channel_states and unlock_channel_states cannot be done in the same time.
      // If any of these two is called while any of these is already running, the grpc will return
      // with an error.
      virtual void lock_channel_states(::grpc::ClientContext* context, const ::minknow_api::data::LockChannelStatesRequest* request, ::minknow_api::data::LockChannelStatesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void lock_channel_states(::grpc::ClientContext* context, const ::minknow_api::data::LockChannelStatesRequest* request, ::minknow_api::data::LockChannelStatesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Re-activates channels that have been turned-off with force_channels_to_state.
      // Note that 'turning off' refers to channel states only, everything else is still applied on the channel
      // (e.g. mux changes, saturation, commands etc)
      // No action is taken if the channel is already active.
      // Has to be called while acquiring data, fails otherwise.
      // NOTE:
      // Calls to lock_channel_states and unlock_channel_states cannot be done in the same time.
      // If any of these two is called while any of these is already running, the grpc will return
      // with an error.
      virtual void unlock_channel_states(::grpc::ClientContext* context, const ::minknow_api::data::UnlockChannelStatesRequest* request, ::minknow_api::data::UnlockChannelStatesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void unlock_channel_states(::grpc::ClientContext* context, const ::minknow_api::data::UnlockChannelStatesRequest* request, ::minknow_api::data::UnlockChannelStatesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Get live reads sent in order to control sequencing behaviour.
      //
      // This method sends current reads (reads that are currently in the sequencer) to the user along
      // with live analysis data in order for real time decisions to be made.
      //
      // The method provides two streams:
      //
      // GetLiveReadsRequest stream:
      //      Sent by the user, provides MinKNOW with actions to take on current reads, actions
      //      taken are sumarised and sent back to the user in the GetLiveReadsResponse stream.
      // GetLiveReadsResponse stream:
      //      Sent to the user, contains a stream of ongoing sequencing information, sent as
      //      regularly as possible, with information on reads in progress, and feedback on actions
      //      taken on the data.
      //
      // note: This method operates on read chunks in MinKNOW, and will send at minimum, 1 read
      // chunk to the user. In order to reduce latency on the method, tune the following options:
      //
      // The raw chunk size data is processed in minknow (specified in samples):
      //      app_conf/hyperstream.raw_data_intermediate.size
      //      app_conf/hyperstream.raw_meta_data_intermediate.size
      //
      // The maximum read chunk size - changing the size read chunks are processed in minknow:
      //      analysis_conf/read_detection.break_reads_after_seconds
      //
      virtual void get_live_reads(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::minknow_api::data::GetLiveReadsRequest,::minknow_api::data::GetLiveReadsResponse>* reactor) = 0;
      // Collects statistics about read (chunk) lengths and signal, split by channel, channel
      // configuration and read (chunk) classification.
      virtual void get_read_statistics(::grpc::ClientContext* context, const ::minknow_api::data::GetReadStatisticsRequest* request, ::minknow_api::data::GetReadStatisticsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_read_statistics(::grpc::ClientContext* context, const ::minknow_api::data::GetReadStatisticsRequest* request, ::minknow_api::data::GetReadStatisticsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Returns various points of yield information for the ongoing experiment, such as complete
      // read information and basecaller progress.
      virtual void get_experiment_yield_info(::grpc::ClientContext* context, const ::minknow_api::data::GetExperimentYieldInfoRequest* request, ::minknow_api::data::GetExperimentYieldInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_experiment_yield_info(::grpc::ClientContext* context, const ::minknow_api::data::GetExperimentYieldInfoRequest* request, ::minknow_api::data::GetExperimentYieldInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientReaderInterface< ::minknow_api::data::GetChannelStatesResponse>* get_channel_statesRaw(::grpc::ClientContext* context, const ::minknow_api::data::GetChannelStatesRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::minknow_api::data::GetChannelStatesResponse>* Asyncget_channel_statesRaw(::grpc::ClientContext* context, const ::minknow_api::data::GetChannelStatesRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::minknow_api::data::GetChannelStatesResponse>* PrepareAsyncget_channel_statesRaw(::grpc::ClientContext* context, const ::minknow_api::data::GetChannelStatesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::data::GetDataTypesResponse>* Asyncget_data_typesRaw(::grpc::ClientContext* context, const ::minknow_api::data::GetDataTypesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::data::GetDataTypesResponse>* PrepareAsyncget_data_typesRaw(::grpc::ClientContext* context, const ::minknow_api::data::GetDataTypesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::minknow_api::data::GetSignalBytesResponse>* get_signal_bytesRaw(::grpc::ClientContext* context, const ::minknow_api::data::GetSignalBytesRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::minknow_api::data::GetSignalBytesResponse>* Asyncget_signal_bytesRaw(::grpc::ClientContext* context, const ::minknow_api::data::GetSignalBytesRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::minknow_api::data::GetSignalBytesResponse>* PrepareAsyncget_signal_bytesRaw(::grpc::ClientContext* context, const ::minknow_api::data::GetSignalBytesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::minknow_api::data::GetSignalMinMaxResponse>* get_signal_min_maxRaw(::grpc::ClientContext* context, const ::minknow_api::data::GetSignalMinMaxRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::minknow_api::data::GetSignalMinMaxResponse>* Asyncget_signal_min_maxRaw(::grpc::ClientContext* context, const ::minknow_api::data::GetSignalMinMaxRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::minknow_api::data::GetSignalMinMaxResponse>* PrepareAsyncget_signal_min_maxRaw(::grpc::ClientContext* context, const ::minknow_api::data::GetSignalMinMaxRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::data::ResetChannelStatesResponse>* Asyncreset_channel_statesRaw(::grpc::ClientContext* context, const ::minknow_api::data::ResetChannelStatesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::data::ResetChannelStatesResponse>* PrepareAsyncreset_channel_statesRaw(::grpc::ClientContext* context, const ::minknow_api::data::ResetChannelStatesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::data::LockChannelStatesResponse>* Asynclock_channel_statesRaw(::grpc::ClientContext* context, const ::minknow_api::data::LockChannelStatesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::data::LockChannelStatesResponse>* PrepareAsynclock_channel_statesRaw(::grpc::ClientContext* context, const ::minknow_api::data::LockChannelStatesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::data::UnlockChannelStatesResponse>* Asyncunlock_channel_statesRaw(::grpc::ClientContext* context, const ::minknow_api::data::UnlockChannelStatesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::data::UnlockChannelStatesResponse>* PrepareAsyncunlock_channel_statesRaw(::grpc::ClientContext* context, const ::minknow_api::data::UnlockChannelStatesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::minknow_api::data::GetLiveReadsRequest, ::minknow_api::data::GetLiveReadsResponse>* get_live_readsRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::minknow_api::data::GetLiveReadsRequest, ::minknow_api::data::GetLiveReadsResponse>* Asyncget_live_readsRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::minknow_api::data::GetLiveReadsRequest, ::minknow_api::data::GetLiveReadsResponse>* PrepareAsyncget_live_readsRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::data::GetReadStatisticsResponse>* Asyncget_read_statisticsRaw(::grpc::ClientContext* context, const ::minknow_api::data::GetReadStatisticsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::data::GetReadStatisticsResponse>* PrepareAsyncget_read_statisticsRaw(::grpc::ClientContext* context, const ::minknow_api::data::GetReadStatisticsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::data::GetExperimentYieldInfoResponse>* Asyncget_experiment_yield_infoRaw(::grpc::ClientContext* context, const ::minknow_api::data::GetExperimentYieldInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::data::GetExperimentYieldInfoResponse>* PrepareAsyncget_experiment_yield_infoRaw(::grpc::ClientContext* context, const ::minknow_api::data::GetExperimentYieldInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    std::unique_ptr< ::grpc::ClientReader< ::minknow_api::data::GetChannelStatesResponse>> get_channel_states(::grpc::ClientContext* context, const ::minknow_api::data::GetChannelStatesRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::minknow_api::data::GetChannelStatesResponse>>(get_channel_statesRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::data::GetChannelStatesResponse>> Asyncget_channel_states(::grpc::ClientContext* context, const ::minknow_api::data::GetChannelStatesRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::data::GetChannelStatesResponse>>(Asyncget_channel_statesRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::data::GetChannelStatesResponse>> PrepareAsyncget_channel_states(::grpc::ClientContext* context, const ::minknow_api::data::GetChannelStatesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::data::GetChannelStatesResponse>>(PrepareAsyncget_channel_statesRaw(context, request, cq));
    }
    ::grpc::Status get_data_types(::grpc::ClientContext* context, const ::minknow_api::data::GetDataTypesRequest& request, ::minknow_api::data::GetDataTypesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::data::GetDataTypesResponse>> Asyncget_data_types(::grpc::ClientContext* context, const ::minknow_api::data::GetDataTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::data::GetDataTypesResponse>>(Asyncget_data_typesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::data::GetDataTypesResponse>> PrepareAsyncget_data_types(::grpc::ClientContext* context, const ::minknow_api::data::GetDataTypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::data::GetDataTypesResponse>>(PrepareAsyncget_data_typesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::minknow_api::data::GetSignalBytesResponse>> get_signal_bytes(::grpc::ClientContext* context, const ::minknow_api::data::GetSignalBytesRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::minknow_api::data::GetSignalBytesResponse>>(get_signal_bytesRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::data::GetSignalBytesResponse>> Asyncget_signal_bytes(::grpc::ClientContext* context, const ::minknow_api::data::GetSignalBytesRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::data::GetSignalBytesResponse>>(Asyncget_signal_bytesRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::data::GetSignalBytesResponse>> PrepareAsyncget_signal_bytes(::grpc::ClientContext* context, const ::minknow_api::data::GetSignalBytesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::data::GetSignalBytesResponse>>(PrepareAsyncget_signal_bytesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::minknow_api::data::GetSignalMinMaxResponse>> get_signal_min_max(::grpc::ClientContext* context, const ::minknow_api::data::GetSignalMinMaxRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::minknow_api::data::GetSignalMinMaxResponse>>(get_signal_min_maxRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::data::GetSignalMinMaxResponse>> Asyncget_signal_min_max(::grpc::ClientContext* context, const ::minknow_api::data::GetSignalMinMaxRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::data::GetSignalMinMaxResponse>>(Asyncget_signal_min_maxRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::data::GetSignalMinMaxResponse>> PrepareAsyncget_signal_min_max(::grpc::ClientContext* context, const ::minknow_api::data::GetSignalMinMaxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::data::GetSignalMinMaxResponse>>(PrepareAsyncget_signal_min_maxRaw(context, request, cq));
    }
    ::grpc::Status reset_channel_states(::grpc::ClientContext* context, const ::minknow_api::data::ResetChannelStatesRequest& request, ::minknow_api::data::ResetChannelStatesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::data::ResetChannelStatesResponse>> Asyncreset_channel_states(::grpc::ClientContext* context, const ::minknow_api::data::ResetChannelStatesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::data::ResetChannelStatesResponse>>(Asyncreset_channel_statesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::data::ResetChannelStatesResponse>> PrepareAsyncreset_channel_states(::grpc::ClientContext* context, const ::minknow_api::data::ResetChannelStatesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::data::ResetChannelStatesResponse>>(PrepareAsyncreset_channel_statesRaw(context, request, cq));
    }
    ::grpc::Status lock_channel_states(::grpc::ClientContext* context, const ::minknow_api::data::LockChannelStatesRequest& request, ::minknow_api::data::LockChannelStatesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::data::LockChannelStatesResponse>> Asynclock_channel_states(::grpc::ClientContext* context, const ::minknow_api::data::LockChannelStatesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::data::LockChannelStatesResponse>>(Asynclock_channel_statesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::data::LockChannelStatesResponse>> PrepareAsynclock_channel_states(::grpc::ClientContext* context, const ::minknow_api::data::LockChannelStatesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::data::LockChannelStatesResponse>>(PrepareAsynclock_channel_statesRaw(context, request, cq));
    }
    ::grpc::Status unlock_channel_states(::grpc::ClientContext* context, const ::minknow_api::data::UnlockChannelStatesRequest& request, ::minknow_api::data::UnlockChannelStatesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::data::UnlockChannelStatesResponse>> Asyncunlock_channel_states(::grpc::ClientContext* context, const ::minknow_api::data::UnlockChannelStatesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::data::UnlockChannelStatesResponse>>(Asyncunlock_channel_statesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::data::UnlockChannelStatesResponse>> PrepareAsyncunlock_channel_states(::grpc::ClientContext* context, const ::minknow_api::data::UnlockChannelStatesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::data::UnlockChannelStatesResponse>>(PrepareAsyncunlock_channel_statesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::minknow_api::data::GetLiveReadsRequest, ::minknow_api::data::GetLiveReadsResponse>> get_live_reads(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::minknow_api::data::GetLiveReadsRequest, ::minknow_api::data::GetLiveReadsResponse>>(get_live_readsRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::minknow_api::data::GetLiveReadsRequest, ::minknow_api::data::GetLiveReadsResponse>> Asyncget_live_reads(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::minknow_api::data::GetLiveReadsRequest, ::minknow_api::data::GetLiveReadsResponse>>(Asyncget_live_readsRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::minknow_api::data::GetLiveReadsRequest, ::minknow_api::data::GetLiveReadsResponse>> PrepareAsyncget_live_reads(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::minknow_api::data::GetLiveReadsRequest, ::minknow_api::data::GetLiveReadsResponse>>(PrepareAsyncget_live_readsRaw(context, cq));
    }
    ::grpc::Status get_read_statistics(::grpc::ClientContext* context, const ::minknow_api::data::GetReadStatisticsRequest& request, ::minknow_api::data::GetReadStatisticsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::data::GetReadStatisticsResponse>> Asyncget_read_statistics(::grpc::ClientContext* context, const ::minknow_api::data::GetReadStatisticsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::data::GetReadStatisticsResponse>>(Asyncget_read_statisticsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::data::GetReadStatisticsResponse>> PrepareAsyncget_read_statistics(::grpc::ClientContext* context, const ::minknow_api::data::GetReadStatisticsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::data::GetReadStatisticsResponse>>(PrepareAsyncget_read_statisticsRaw(context, request, cq));
    }
    ::grpc::Status get_experiment_yield_info(::grpc::ClientContext* context, const ::minknow_api::data::GetExperimentYieldInfoRequest& request, ::minknow_api::data::GetExperimentYieldInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::data::GetExperimentYieldInfoResponse>> Asyncget_experiment_yield_info(::grpc::ClientContext* context, const ::minknow_api::data::GetExperimentYieldInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::data::GetExperimentYieldInfoResponse>>(Asyncget_experiment_yield_infoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::data::GetExperimentYieldInfoResponse>> PrepareAsyncget_experiment_yield_info(::grpc::ClientContext* context, const ::minknow_api::data::GetExperimentYieldInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::data::GetExperimentYieldInfoResponse>>(PrepareAsyncget_experiment_yield_infoRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void get_channel_states(::grpc::ClientContext* context, const ::minknow_api::data::GetChannelStatesRequest* request, ::grpc::ClientReadReactor< ::minknow_api::data::GetChannelStatesResponse>* reactor) override;
      void get_data_types(::grpc::ClientContext* context, const ::minknow_api::data::GetDataTypesRequest* request, ::minknow_api::data::GetDataTypesResponse* response, std::function<void(::grpc::Status)>) override;
      void get_data_types(::grpc::ClientContext* context, const ::minknow_api::data::GetDataTypesRequest* request, ::minknow_api::data::GetDataTypesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_signal_bytes(::grpc::ClientContext* context, const ::minknow_api::data::GetSignalBytesRequest* request, ::grpc::ClientReadReactor< ::minknow_api::data::GetSignalBytesResponse>* reactor) override;
      void get_signal_min_max(::grpc::ClientContext* context, const ::minknow_api::data::GetSignalMinMaxRequest* request, ::grpc::ClientReadReactor< ::minknow_api::data::GetSignalMinMaxResponse>* reactor) override;
      void reset_channel_states(::grpc::ClientContext* context, const ::minknow_api::data::ResetChannelStatesRequest* request, ::minknow_api::data::ResetChannelStatesResponse* response, std::function<void(::grpc::Status)>) override;
      void reset_channel_states(::grpc::ClientContext* context, const ::minknow_api::data::ResetChannelStatesRequest* request, ::minknow_api::data::ResetChannelStatesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void lock_channel_states(::grpc::ClientContext* context, const ::minknow_api::data::LockChannelStatesRequest* request, ::minknow_api::data::LockChannelStatesResponse* response, std::function<void(::grpc::Status)>) override;
      void lock_channel_states(::grpc::ClientContext* context, const ::minknow_api::data::LockChannelStatesRequest* request, ::minknow_api::data::LockChannelStatesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void unlock_channel_states(::grpc::ClientContext* context, const ::minknow_api::data::UnlockChannelStatesRequest* request, ::minknow_api::data::UnlockChannelStatesResponse* response, std::function<void(::grpc::Status)>) override;
      void unlock_channel_states(::grpc::ClientContext* context, const ::minknow_api::data::UnlockChannelStatesRequest* request, ::minknow_api::data::UnlockChannelStatesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_live_reads(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::minknow_api::data::GetLiveReadsRequest,::minknow_api::data::GetLiveReadsResponse>* reactor) override;
      void get_read_statistics(::grpc::ClientContext* context, const ::minknow_api::data::GetReadStatisticsRequest* request, ::minknow_api::data::GetReadStatisticsResponse* response, std::function<void(::grpc::Status)>) override;
      void get_read_statistics(::grpc::ClientContext* context, const ::minknow_api::data::GetReadStatisticsRequest* request, ::minknow_api::data::GetReadStatisticsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_experiment_yield_info(::grpc::ClientContext* context, const ::minknow_api::data::GetExperimentYieldInfoRequest* request, ::minknow_api::data::GetExperimentYieldInfoResponse* response, std::function<void(::grpc::Status)>) override;
      void get_experiment_yield_info(::grpc::ClientContext* context, const ::minknow_api::data::GetExperimentYieldInfoRequest* request, ::minknow_api::data::GetExperimentYieldInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientReader< ::minknow_api::data::GetChannelStatesResponse>* get_channel_statesRaw(::grpc::ClientContext* context, const ::minknow_api::data::GetChannelStatesRequest& request) override;
    ::grpc::ClientAsyncReader< ::minknow_api::data::GetChannelStatesResponse>* Asyncget_channel_statesRaw(::grpc::ClientContext* context, const ::minknow_api::data::GetChannelStatesRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::minknow_api::data::GetChannelStatesResponse>* PrepareAsyncget_channel_statesRaw(::grpc::ClientContext* context, const ::minknow_api::data::GetChannelStatesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::data::GetDataTypesResponse>* Asyncget_data_typesRaw(::grpc::ClientContext* context, const ::minknow_api::data::GetDataTypesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::data::GetDataTypesResponse>* PrepareAsyncget_data_typesRaw(::grpc::ClientContext* context, const ::minknow_api::data::GetDataTypesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::minknow_api::data::GetSignalBytesResponse>* get_signal_bytesRaw(::grpc::ClientContext* context, const ::minknow_api::data::GetSignalBytesRequest& request) override;
    ::grpc::ClientAsyncReader< ::minknow_api::data::GetSignalBytesResponse>* Asyncget_signal_bytesRaw(::grpc::ClientContext* context, const ::minknow_api::data::GetSignalBytesRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::minknow_api::data::GetSignalBytesResponse>* PrepareAsyncget_signal_bytesRaw(::grpc::ClientContext* context, const ::minknow_api::data::GetSignalBytesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::minknow_api::data::GetSignalMinMaxResponse>* get_signal_min_maxRaw(::grpc::ClientContext* context, const ::minknow_api::data::GetSignalMinMaxRequest& request) override;
    ::grpc::ClientAsyncReader< ::minknow_api::data::GetSignalMinMaxResponse>* Asyncget_signal_min_maxRaw(::grpc::ClientContext* context, const ::minknow_api::data::GetSignalMinMaxRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::minknow_api::data::GetSignalMinMaxResponse>* PrepareAsyncget_signal_min_maxRaw(::grpc::ClientContext* context, const ::minknow_api::data::GetSignalMinMaxRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::data::ResetChannelStatesResponse>* Asyncreset_channel_statesRaw(::grpc::ClientContext* context, const ::minknow_api::data::ResetChannelStatesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::data::ResetChannelStatesResponse>* PrepareAsyncreset_channel_statesRaw(::grpc::ClientContext* context, const ::minknow_api::data::ResetChannelStatesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::data::LockChannelStatesResponse>* Asynclock_channel_statesRaw(::grpc::ClientContext* context, const ::minknow_api::data::LockChannelStatesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::data::LockChannelStatesResponse>* PrepareAsynclock_channel_statesRaw(::grpc::ClientContext* context, const ::minknow_api::data::LockChannelStatesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::data::UnlockChannelStatesResponse>* Asyncunlock_channel_statesRaw(::grpc::ClientContext* context, const ::minknow_api::data::UnlockChannelStatesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::data::UnlockChannelStatesResponse>* PrepareAsyncunlock_channel_statesRaw(::grpc::ClientContext* context, const ::minknow_api::data::UnlockChannelStatesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReaderWriter< ::minknow_api::data::GetLiveReadsRequest, ::minknow_api::data::GetLiveReadsResponse>* get_live_readsRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::minknow_api::data::GetLiveReadsRequest, ::minknow_api::data::GetLiveReadsResponse>* Asyncget_live_readsRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::minknow_api::data::GetLiveReadsRequest, ::minknow_api::data::GetLiveReadsResponse>* PrepareAsyncget_live_readsRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::data::GetReadStatisticsResponse>* Asyncget_read_statisticsRaw(::grpc::ClientContext* context, const ::minknow_api::data::GetReadStatisticsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::data::GetReadStatisticsResponse>* PrepareAsyncget_read_statisticsRaw(::grpc::ClientContext* context, const ::minknow_api::data::GetReadStatisticsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::data::GetExperimentYieldInfoResponse>* Asyncget_experiment_yield_infoRaw(::grpc::ClientContext* context, const ::minknow_api::data::GetExperimentYieldInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::data::GetExperimentYieldInfoResponse>* PrepareAsyncget_experiment_yield_infoRaw(::grpc::ClientContext* context, const ::minknow_api::data::GetExperimentYieldInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_get_channel_states_;
    const ::grpc::internal::RpcMethod rpcmethod_get_data_types_;
    const ::grpc::internal::RpcMethod rpcmethod_get_signal_bytes_;
    const ::grpc::internal::RpcMethod rpcmethod_get_signal_min_max_;
    const ::grpc::internal::RpcMethod rpcmethod_reset_channel_states_;
    const ::grpc::internal::RpcMethod rpcmethod_lock_channel_states_;
    const ::grpc::internal::RpcMethod rpcmethod_unlock_channel_states_;
    const ::grpc::internal::RpcMethod rpcmethod_get_live_reads_;
    const ::grpc::internal::RpcMethod rpcmethod_get_read_statistics_;
    const ::grpc::internal::RpcMethod rpcmethod_get_experiment_yield_info_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Get the channel states for all channels from the device.
    //
    // This will return all the channel states from the moment of calling until the rpc is
    // closed by the user. If the user stops acquisition, the rpc will return with the
    // ABORTED status. If the user cancels the rpc, the status will be CANCELLED.
    //
    // The first messages returned will retrieve the current channel state for all channels
    // On the MinION, the current state for all channels will be included in the first message.
    // For PromethION, it will be split on multiple messages.
    //
    // To determine which channels have been returned, please check the channel member in the
    // messages returned in the response.
    //
    // The response will be streamed, and we will provide a message as soon as there are channel
    // state changes (though note that some channels could stay in the same state for a long time),
    // so there is no guaranteed frequency of the messages returned. However, because a response
    // message includes multiple channels, it is very likely that we have messages every few seconds.
    // As in, it is likely that at least some of the channels will change every so often, therefore
    // messages will be generated. For example, if 5 out of 512 channels change the state in the
    // same time, there will be a message containing all 5 changes. Later on, if other channels
    // change their state we will receive another message containing those and so on. Note that
    // MinKNOW tries to group as many channel state changes in a single message, up to the message
    // limit size, which is currently set to 32kB.
    virtual ::grpc::Status get_channel_states(::grpc::ServerContext* context, const ::minknow_api::data::GetChannelStatesRequest* request, ::grpc::ServerWriter< ::minknow_api::data::GetChannelStatesResponse>* writer);
    // Get the data types of data items produced by this service.
    //
    // In order to allow clients to efficiently deal with large volumes of data in languages such as
    // Python, this service can provide data as raw bytes. This call can be used to determine how to
    // interpret those bytes. This can be used to construct an appropriate numpy dtype, for example.
    virtual ::grpc::Status get_data_types(::grpc::ServerContext* context, const ::minknow_api::data::GetDataTypesRequest* request, ::minknow_api::data::GetDataTypesResponse* response);
    // Get signal data from the device.
    //
    // This can be used to sample the signal being produced by the device. The signal can be
    // returned as raw ADC values or as calibrated picoamp (pA) values; see ``set_calibration`` on
    // the device service for the values used in this conversion.
    //
    // In addition to the signal, this can return the associated channel configuration and/or bias
    // voltage information, to help analyse the data.
    //
    // If bias voltage information is requested, one bias voltage sample will be provided for each
    // signal sample (on any given channel). So if you request 20 samples of signal data and also
    // bias voltages, you will get 20 signal samples on each channel and also 20 bias voltage
    // samples. Bias voltages are always given in millivolts, and no corrections need to be applied
    // (for example, the 5x amplifier on a MinION is already accounted for).
    //
    // If channel configuration information is requested, each channel will have the starting
    // channel configuration (with offset 0 to indicate it applies to the first sample on that
    // channel), as well as any configuration changes that affect any of the returned samples.
    //
    // If a device settings change RPC has completed before this method is called, the data returned
    // is guaranteed to have been generated by the device after those settings were applied.
    // However, note that no guarantee is made about how device settings changes that overlap with
    // this request will affect the returned data.
    //
    // The response will be streamed. In order to limit the size of each response message, any given
    // message may include data from only a subset of the requested channels.
    //
    // Note that the data is returned as bytes fields. See the GetSignalBytesResponse documentation
    // for more details about how to interpret the value. In Python code, the minknow.Device class
    // provides a convenience wrapper method to convert the data into numpy arrays.
    virtual ::grpc::Status get_signal_bytes(::grpc::ServerContext* context, const ::minknow_api::data::GetSignalBytesRequest* request, ::grpc::ServerWriter< ::minknow_api::data::GetSignalBytesResponse>* writer);
    // Get summarised signal data from the device.
    //
    // This provides signal data from the device, like get_signal_bytes, but instead of all the
    // data, it divides the data up into windows, and provides the minimum and maximum values for
    // each window.
    //
    // This call is aimed at visualisations of data (ie: a traceviewer interface). As such, it does
    // not provide most of the guarantees and options that get_signal_bytes() does. No bias voltage
    // or channel configuration data is provided, it is not possible to set the number of samples
    // desired up front (just cancel the call when no further data is required) and no guarantees
    // are made about whether particular commands have been applied to the returned data.
    //
    // Also unlike get_signal_bytes(), the returned data is in native types, and does not require
    // any further interpretation based on get_data_types(). This can be done performantly because
    // of the reduced amount of data transmitted.
    //
    // The response will be streamed. In order to limit the size of each response message, any given
    // message may include data from only a subset of the requested channels.
    virtual ::grpc::Status get_signal_min_max(::grpc::ServerContext* context, const ::minknow_api::data::GetSignalMinMaxRequest* request, ::grpc::ServerWriter< ::minknow_api::data::GetSignalMinMaxResponse>* writer);
    // Call this to force re-evaluating the channel states. This will make sure the next
    // channel state evaluated will be 'unclassified_following_reset'. If the analyser is behind,
    // and older data will come for evaluation, it will result in changing the state to 'pending_manual_reset'.
    // So tipically, after a resetting the channel states, the user would see in the bulk file
    // 'unclassified_following_reset', 'pending_manual_reset', 'pending_manual_reset', until the relevant data
    // comes through to the analyser and it will start outputting the normal channel states again.
    // If the analyser is not behind, the user should ideally see just the 'unclassified_following_reset' state.
    //
    // This call is blocking - it will return from the rpc when it would have processed the
    // 'unclassified_following_reset' in the analyser. If the rpc takes more than 1 minute
    // it will exit with the ABORTED status. This can happen if the analyser is more than 1 minute behind
    // for example (in practice it shouldn't be the case). If the RPC exits with the ABORT status, it means
    // the channels are to be reset in the future, but the analyser did not reach that point yet.
    //
    // Only one of these can be executed at a given time. If multiple threads call this simultaneously,
    // it will execute the first request and it will exit with FAILED_PRECONDITION for the rest. If an RPC
    // exited with the ABORT status, another RPC can immediately be started. The failed RPC would have not
    // reset the channel states, and the user could try again. The second RPC will return as soon as the first
    // reset happens, so this will not be necessarily waiting for the second acquisition index to be
    // processed.
    virtual ::grpc::Status reset_channel_states(::grpc::ServerContext* context, const ::minknow_api::data::ResetChannelStatesRequest* request, ::minknow_api::data::ResetChannelStatesResponse* response);
    // Forces channels to be fixed on a custom channel state. The channels will not be re-evaluated until
    // they are activated using unlock_channel_states.
    // To create a channel state that will never be entered unless manually set using this call,
    // use the "never_evaluated" criteria:
    // "9": { "group": {...},
    //        "logic": {
    //            "rank": 0,
    //            "criteria": "never_evaluated"
    //             },
    //         "name": "custom_name_picked_by_the_user"
    //       }
    //
    // While the this RPC has the power of forcing a channel to any valid state other than 'unclassified',
    // it is intended to be used with channel states that are designed for this functionality (i.e. that
    // are never evaluated).
    // Has to be called while acquiring data, fails otherwise.
    // The forced channels are reset (reset = every channel back to being evaluated) every time a
    // new acquisition sequence is started.
    //
    // NOTE:
    // Calls to lock_channel_states and unlock_channel_states cannot be done in the same time.
    // If any of these two is called while any of these is already running, the grpc will return
    // with an error.
    virtual ::grpc::Status lock_channel_states(::grpc::ServerContext* context, const ::minknow_api::data::LockChannelStatesRequest* request, ::minknow_api::data::LockChannelStatesResponse* response);
    // Re-activates channels that have been turned-off with force_channels_to_state.
    // Note that 'turning off' refers to channel states only, everything else is still applied on the channel
    // (e.g. mux changes, saturation, commands etc)
    // No action is taken if the channel is already active.
    // Has to be called while acquiring data, fails otherwise.
    // NOTE:
    // Calls to lock_channel_states and unlock_channel_states cannot be done in the same time.
    // If any of these two is called while any of these is already running, the grpc will return
    // with an error.
    virtual ::grpc::Status unlock_channel_states(::grpc::ServerContext* context, const ::minknow_api::data::UnlockChannelStatesRequest* request, ::minknow_api::data::UnlockChannelStatesResponse* response);
    // Get live reads sent in order to control sequencing behaviour.
    //
    // This method sends current reads (reads that are currently in the sequencer) to the user along
    // with live analysis data in order for real time decisions to be made.
    //
    // The method provides two streams:
    //
    // GetLiveReadsRequest stream:
    //      Sent by the user, provides MinKNOW with actions to take on current reads, actions
    //      taken are sumarised and sent back to the user in the GetLiveReadsResponse stream.
    // GetLiveReadsResponse stream:
    //      Sent to the user, contains a stream of ongoing sequencing information, sent as
    //      regularly as possible, with information on reads in progress, and feedback on actions
    //      taken on the data.
    //
    // note: This method operates on read chunks in MinKNOW, and will send at minimum, 1 read
    // chunk to the user. In order to reduce latency on the method, tune the following options:
    //
    // The raw chunk size data is processed in minknow (specified in samples):
    //      app_conf/hyperstream.raw_data_intermediate.size
    //      app_conf/hyperstream.raw_meta_data_intermediate.size
    //
    // The maximum read chunk size - changing the size read chunks are processed in minknow:
    //      analysis_conf/read_detection.break_reads_after_seconds
    //
    virtual ::grpc::Status get_live_reads(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::minknow_api::data::GetLiveReadsResponse, ::minknow_api::data::GetLiveReadsRequest>* stream);
    // Collects statistics about read (chunk) lengths and signal, split by channel, channel
    // configuration and read (chunk) classification.
    virtual ::grpc::Status get_read_statistics(::grpc::ServerContext* context, const ::minknow_api::data::GetReadStatisticsRequest* request, ::minknow_api::data::GetReadStatisticsResponse* response);
    // Returns various points of yield information for the ongoing experiment, such as complete
    // read information and basecaller progress.
    virtual ::grpc::Status get_experiment_yield_info(::grpc::ServerContext* context, const ::minknow_api::data::GetExperimentYieldInfoRequest* request, ::minknow_api::data::GetExperimentYieldInfoResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_get_channel_states : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_channel_states() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_get_channel_states() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_channel_states(::grpc::ServerContext* /*context*/, const ::minknow_api::data::GetChannelStatesRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::data::GetChannelStatesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_channel_states(::grpc::ServerContext* context, ::minknow_api::data::GetChannelStatesRequest* request, ::grpc::ServerAsyncWriter< ::minknow_api::data::GetChannelStatesResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(0, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_data_types : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_data_types() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_get_data_types() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_data_types(::grpc::ServerContext* /*context*/, const ::minknow_api::data::GetDataTypesRequest* /*request*/, ::minknow_api::data::GetDataTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_data_types(::grpc::ServerContext* context, ::minknow_api::data::GetDataTypesRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::data::GetDataTypesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_signal_bytes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_signal_bytes() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_get_signal_bytes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_signal_bytes(::grpc::ServerContext* /*context*/, const ::minknow_api::data::GetSignalBytesRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::data::GetSignalBytesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_signal_bytes(::grpc::ServerContext* context, ::minknow_api::data::GetSignalBytesRequest* request, ::grpc::ServerAsyncWriter< ::minknow_api::data::GetSignalBytesResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(2, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_signal_min_max : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_signal_min_max() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_get_signal_min_max() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_signal_min_max(::grpc::ServerContext* /*context*/, const ::minknow_api::data::GetSignalMinMaxRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::data::GetSignalMinMaxResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_signal_min_max(::grpc::ServerContext* context, ::minknow_api::data::GetSignalMinMaxRequest* request, ::grpc::ServerAsyncWriter< ::minknow_api::data::GetSignalMinMaxResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(3, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_reset_channel_states : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_reset_channel_states() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_reset_channel_states() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status reset_channel_states(::grpc::ServerContext* /*context*/, const ::minknow_api::data::ResetChannelStatesRequest* /*request*/, ::minknow_api::data::ResetChannelStatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestreset_channel_states(::grpc::ServerContext* context, ::minknow_api::data::ResetChannelStatesRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::data::ResetChannelStatesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_lock_channel_states : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_lock_channel_states() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_lock_channel_states() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status lock_channel_states(::grpc::ServerContext* /*context*/, const ::minknow_api::data::LockChannelStatesRequest* /*request*/, ::minknow_api::data::LockChannelStatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestlock_channel_states(::grpc::ServerContext* context, ::minknow_api::data::LockChannelStatesRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::data::LockChannelStatesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_unlock_channel_states : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_unlock_channel_states() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_unlock_channel_states() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status unlock_channel_states(::grpc::ServerContext* /*context*/, const ::minknow_api::data::UnlockChannelStatesRequest* /*request*/, ::minknow_api::data::UnlockChannelStatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestunlock_channel_states(::grpc::ServerContext* context, ::minknow_api::data::UnlockChannelStatesRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::data::UnlockChannelStatesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_live_reads : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_live_reads() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_get_live_reads() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_live_reads(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::minknow_api::data::GetLiveReadsResponse, ::minknow_api::data::GetLiveReadsRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_live_reads(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::minknow_api::data::GetLiveReadsResponse, ::minknow_api::data::GetLiveReadsRequest>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(7, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_read_statistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_read_statistics() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_get_read_statistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_read_statistics(::grpc::ServerContext* /*context*/, const ::minknow_api::data::GetReadStatisticsRequest* /*request*/, ::minknow_api::data::GetReadStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_read_statistics(::grpc::ServerContext* context, ::minknow_api::data::GetReadStatisticsRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::data::GetReadStatisticsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_experiment_yield_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_experiment_yield_info() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_get_experiment_yield_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_experiment_yield_info(::grpc::ServerContext* /*context*/, const ::minknow_api::data::GetExperimentYieldInfoRequest* /*request*/, ::minknow_api::data::GetExperimentYieldInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_experiment_yield_info(::grpc::ServerContext* context, ::minknow_api::data::GetExperimentYieldInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::data::GetExperimentYieldInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_get_channel_states<WithAsyncMethod_get_data_types<WithAsyncMethod_get_signal_bytes<WithAsyncMethod_get_signal_min_max<WithAsyncMethod_reset_channel_states<WithAsyncMethod_lock_channel_states<WithAsyncMethod_unlock_channel_states<WithAsyncMethod_get_live_reads<WithAsyncMethod_get_read_statistics<WithAsyncMethod_get_experiment_yield_info<Service > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_get_channel_states : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_channel_states() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackServerStreamingHandler< ::minknow_api::data::GetChannelStatesRequest, ::minknow_api::data::GetChannelStatesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::data::GetChannelStatesRequest* request) { return this->get_channel_states(context, request); }));
    }
    ~WithCallbackMethod_get_channel_states() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_channel_states(::grpc::ServerContext* /*context*/, const ::minknow_api::data::GetChannelStatesRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::data::GetChannelStatesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::minknow_api::data::GetChannelStatesResponse>* get_channel_states(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::data::GetChannelStatesRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_data_types : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_data_types() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::data::GetDataTypesRequest, ::minknow_api::data::GetDataTypesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::data::GetDataTypesRequest* request, ::minknow_api::data::GetDataTypesResponse* response) { return this->get_data_types(context, request, response); }));}
    void SetMessageAllocatorFor_get_data_types(
        ::grpc::MessageAllocator< ::minknow_api::data::GetDataTypesRequest, ::minknow_api::data::GetDataTypesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::data::GetDataTypesRequest, ::minknow_api::data::GetDataTypesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_data_types() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_data_types(::grpc::ServerContext* /*context*/, const ::minknow_api::data::GetDataTypesRequest* /*request*/, ::minknow_api::data::GetDataTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_data_types(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::data::GetDataTypesRequest* /*request*/, ::minknow_api::data::GetDataTypesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_signal_bytes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_signal_bytes() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackServerStreamingHandler< ::minknow_api::data::GetSignalBytesRequest, ::minknow_api::data::GetSignalBytesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::data::GetSignalBytesRequest* request) { return this->get_signal_bytes(context, request); }));
    }
    ~WithCallbackMethod_get_signal_bytes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_signal_bytes(::grpc::ServerContext* /*context*/, const ::minknow_api::data::GetSignalBytesRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::data::GetSignalBytesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::minknow_api::data::GetSignalBytesResponse>* get_signal_bytes(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::data::GetSignalBytesRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_signal_min_max : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_signal_min_max() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackServerStreamingHandler< ::minknow_api::data::GetSignalMinMaxRequest, ::minknow_api::data::GetSignalMinMaxResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::data::GetSignalMinMaxRequest* request) { return this->get_signal_min_max(context, request); }));
    }
    ~WithCallbackMethod_get_signal_min_max() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_signal_min_max(::grpc::ServerContext* /*context*/, const ::minknow_api::data::GetSignalMinMaxRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::data::GetSignalMinMaxResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::minknow_api::data::GetSignalMinMaxResponse>* get_signal_min_max(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::data::GetSignalMinMaxRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_reset_channel_states : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_reset_channel_states() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::data::ResetChannelStatesRequest, ::minknow_api::data::ResetChannelStatesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::data::ResetChannelStatesRequest* request, ::minknow_api::data::ResetChannelStatesResponse* response) { return this->reset_channel_states(context, request, response); }));}
    void SetMessageAllocatorFor_reset_channel_states(
        ::grpc::MessageAllocator< ::minknow_api::data::ResetChannelStatesRequest, ::minknow_api::data::ResetChannelStatesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::data::ResetChannelStatesRequest, ::minknow_api::data::ResetChannelStatesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_reset_channel_states() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status reset_channel_states(::grpc::ServerContext* /*context*/, const ::minknow_api::data::ResetChannelStatesRequest* /*request*/, ::minknow_api::data::ResetChannelStatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* reset_channel_states(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::data::ResetChannelStatesRequest* /*request*/, ::minknow_api::data::ResetChannelStatesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_lock_channel_states : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_lock_channel_states() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::data::LockChannelStatesRequest, ::minknow_api::data::LockChannelStatesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::data::LockChannelStatesRequest* request, ::minknow_api::data::LockChannelStatesResponse* response) { return this->lock_channel_states(context, request, response); }));}
    void SetMessageAllocatorFor_lock_channel_states(
        ::grpc::MessageAllocator< ::minknow_api::data::LockChannelStatesRequest, ::minknow_api::data::LockChannelStatesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::data::LockChannelStatesRequest, ::minknow_api::data::LockChannelStatesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_lock_channel_states() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status lock_channel_states(::grpc::ServerContext* /*context*/, const ::minknow_api::data::LockChannelStatesRequest* /*request*/, ::minknow_api::data::LockChannelStatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* lock_channel_states(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::data::LockChannelStatesRequest* /*request*/, ::minknow_api::data::LockChannelStatesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_unlock_channel_states : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_unlock_channel_states() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::data::UnlockChannelStatesRequest, ::minknow_api::data::UnlockChannelStatesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::data::UnlockChannelStatesRequest* request, ::minknow_api::data::UnlockChannelStatesResponse* response) { return this->unlock_channel_states(context, request, response); }));}
    void SetMessageAllocatorFor_unlock_channel_states(
        ::grpc::MessageAllocator< ::minknow_api::data::UnlockChannelStatesRequest, ::minknow_api::data::UnlockChannelStatesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::data::UnlockChannelStatesRequest, ::minknow_api::data::UnlockChannelStatesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_unlock_channel_states() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status unlock_channel_states(::grpc::ServerContext* /*context*/, const ::minknow_api::data::UnlockChannelStatesRequest* /*request*/, ::minknow_api::data::UnlockChannelStatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* unlock_channel_states(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::data::UnlockChannelStatesRequest* /*request*/, ::minknow_api::data::UnlockChannelStatesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_live_reads : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_live_reads() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackBidiHandler< ::minknow_api::data::GetLiveReadsRequest, ::minknow_api::data::GetLiveReadsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->get_live_reads(context); }));
    }
    ~WithCallbackMethod_get_live_reads() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_live_reads(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::minknow_api::data::GetLiveReadsResponse, ::minknow_api::data::GetLiveReadsRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::minknow_api::data::GetLiveReadsRequest, ::minknow_api::data::GetLiveReadsResponse>* get_live_reads(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_read_statistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_read_statistics() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::data::GetReadStatisticsRequest, ::minknow_api::data::GetReadStatisticsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::data::GetReadStatisticsRequest* request, ::minknow_api::data::GetReadStatisticsResponse* response) { return this->get_read_statistics(context, request, response); }));}
    void SetMessageAllocatorFor_get_read_statistics(
        ::grpc::MessageAllocator< ::minknow_api::data::GetReadStatisticsRequest, ::minknow_api::data::GetReadStatisticsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::data::GetReadStatisticsRequest, ::minknow_api::data::GetReadStatisticsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_read_statistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_read_statistics(::grpc::ServerContext* /*context*/, const ::minknow_api::data::GetReadStatisticsRequest* /*request*/, ::minknow_api::data::GetReadStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_read_statistics(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::data::GetReadStatisticsRequest* /*request*/, ::minknow_api::data::GetReadStatisticsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_experiment_yield_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_experiment_yield_info() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::data::GetExperimentYieldInfoRequest, ::minknow_api::data::GetExperimentYieldInfoResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::data::GetExperimentYieldInfoRequest* request, ::minknow_api::data::GetExperimentYieldInfoResponse* response) { return this->get_experiment_yield_info(context, request, response); }));}
    void SetMessageAllocatorFor_get_experiment_yield_info(
        ::grpc::MessageAllocator< ::minknow_api::data::GetExperimentYieldInfoRequest, ::minknow_api::data::GetExperimentYieldInfoResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::data::GetExperimentYieldInfoRequest, ::minknow_api::data::GetExperimentYieldInfoResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_experiment_yield_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_experiment_yield_info(::grpc::ServerContext* /*context*/, const ::minknow_api::data::GetExperimentYieldInfoRequest* /*request*/, ::minknow_api::data::GetExperimentYieldInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_experiment_yield_info(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::data::GetExperimentYieldInfoRequest* /*request*/, ::minknow_api::data::GetExperimentYieldInfoResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_get_channel_states<WithCallbackMethod_get_data_types<WithCallbackMethod_get_signal_bytes<WithCallbackMethod_get_signal_min_max<WithCallbackMethod_reset_channel_states<WithCallbackMethod_lock_channel_states<WithCallbackMethod_unlock_channel_states<WithCallbackMethod_get_live_reads<WithCallbackMethod_get_read_statistics<WithCallbackMethod_get_experiment_yield_info<Service > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_get_channel_states : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_channel_states() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_get_channel_states() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_channel_states(::grpc::ServerContext* /*context*/, const ::minknow_api::data::GetChannelStatesRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::data::GetChannelStatesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_data_types : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_data_types() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_get_data_types() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_data_types(::grpc::ServerContext* /*context*/, const ::minknow_api::data::GetDataTypesRequest* /*request*/, ::minknow_api::data::GetDataTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_signal_bytes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_signal_bytes() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_get_signal_bytes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_signal_bytes(::grpc::ServerContext* /*context*/, const ::minknow_api::data::GetSignalBytesRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::data::GetSignalBytesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_signal_min_max : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_signal_min_max() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_get_signal_min_max() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_signal_min_max(::grpc::ServerContext* /*context*/, const ::minknow_api::data::GetSignalMinMaxRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::data::GetSignalMinMaxResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_reset_channel_states : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_reset_channel_states() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_reset_channel_states() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status reset_channel_states(::grpc::ServerContext* /*context*/, const ::minknow_api::data::ResetChannelStatesRequest* /*request*/, ::minknow_api::data::ResetChannelStatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_lock_channel_states : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_lock_channel_states() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_lock_channel_states() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status lock_channel_states(::grpc::ServerContext* /*context*/, const ::minknow_api::data::LockChannelStatesRequest* /*request*/, ::minknow_api::data::LockChannelStatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_unlock_channel_states : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_unlock_channel_states() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_unlock_channel_states() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status unlock_channel_states(::grpc::ServerContext* /*context*/, const ::minknow_api::data::UnlockChannelStatesRequest* /*request*/, ::minknow_api::data::UnlockChannelStatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_live_reads : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_live_reads() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_get_live_reads() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_live_reads(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::minknow_api::data::GetLiveReadsResponse, ::minknow_api::data::GetLiveReadsRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_read_statistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_read_statistics() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_get_read_statistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_read_statistics(::grpc::ServerContext* /*context*/, const ::minknow_api::data::GetReadStatisticsRequest* /*request*/, ::minknow_api::data::GetReadStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_experiment_yield_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_experiment_yield_info() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_get_experiment_yield_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_experiment_yield_info(::grpc::ServerContext* /*context*/, const ::minknow_api::data::GetExperimentYieldInfoRequest* /*request*/, ::minknow_api::data::GetExperimentYieldInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_channel_states : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_channel_states() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_get_channel_states() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_channel_states(::grpc::ServerContext* /*context*/, const ::minknow_api::data::GetChannelStatesRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::data::GetChannelStatesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_channel_states(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(0, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_data_types : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_data_types() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_get_data_types() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_data_types(::grpc::ServerContext* /*context*/, const ::minknow_api::data::GetDataTypesRequest* /*request*/, ::minknow_api::data::GetDataTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_data_types(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_signal_bytes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_signal_bytes() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_get_signal_bytes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_signal_bytes(::grpc::ServerContext* /*context*/, const ::minknow_api::data::GetSignalBytesRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::data::GetSignalBytesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_signal_bytes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(2, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_signal_min_max : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_signal_min_max() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_get_signal_min_max() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_signal_min_max(::grpc::ServerContext* /*context*/, const ::minknow_api::data::GetSignalMinMaxRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::data::GetSignalMinMaxResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_signal_min_max(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(3, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_reset_channel_states : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_reset_channel_states() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_reset_channel_states() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status reset_channel_states(::grpc::ServerContext* /*context*/, const ::minknow_api::data::ResetChannelStatesRequest* /*request*/, ::minknow_api::data::ResetChannelStatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestreset_channel_states(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_lock_channel_states : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_lock_channel_states() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_lock_channel_states() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status lock_channel_states(::grpc::ServerContext* /*context*/, const ::minknow_api::data::LockChannelStatesRequest* /*request*/, ::minknow_api::data::LockChannelStatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestlock_channel_states(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_unlock_channel_states : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_unlock_channel_states() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_unlock_channel_states() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status unlock_channel_states(::grpc::ServerContext* /*context*/, const ::minknow_api::data::UnlockChannelStatesRequest* /*request*/, ::minknow_api::data::UnlockChannelStatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestunlock_channel_states(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_live_reads : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_live_reads() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_get_live_reads() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_live_reads(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::minknow_api::data::GetLiveReadsResponse, ::minknow_api::data::GetLiveReadsRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_live_reads(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(7, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_read_statistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_read_statistics() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_get_read_statistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_read_statistics(::grpc::ServerContext* /*context*/, const ::minknow_api::data::GetReadStatisticsRequest* /*request*/, ::minknow_api::data::GetReadStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_read_statistics(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_experiment_yield_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_experiment_yield_info() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_get_experiment_yield_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_experiment_yield_info(::grpc::ServerContext* /*context*/, const ::minknow_api::data::GetExperimentYieldInfoRequest* /*request*/, ::minknow_api::data::GetExperimentYieldInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_experiment_yield_info(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_channel_states : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_channel_states() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->get_channel_states(context, request); }));
    }
    ~WithRawCallbackMethod_get_channel_states() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_channel_states(::grpc::ServerContext* /*context*/, const ::minknow_api::data::GetChannelStatesRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::data::GetChannelStatesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* get_channel_states(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_data_types : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_data_types() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_data_types(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_data_types() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_data_types(::grpc::ServerContext* /*context*/, const ::minknow_api::data::GetDataTypesRequest* /*request*/, ::minknow_api::data::GetDataTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_data_types(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_signal_bytes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_signal_bytes() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->get_signal_bytes(context, request); }));
    }
    ~WithRawCallbackMethod_get_signal_bytes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_signal_bytes(::grpc::ServerContext* /*context*/, const ::minknow_api::data::GetSignalBytesRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::data::GetSignalBytesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* get_signal_bytes(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_signal_min_max : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_signal_min_max() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->get_signal_min_max(context, request); }));
    }
    ~WithRawCallbackMethod_get_signal_min_max() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_signal_min_max(::grpc::ServerContext* /*context*/, const ::minknow_api::data::GetSignalMinMaxRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::data::GetSignalMinMaxResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* get_signal_min_max(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_reset_channel_states : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_reset_channel_states() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->reset_channel_states(context, request, response); }));
    }
    ~WithRawCallbackMethod_reset_channel_states() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status reset_channel_states(::grpc::ServerContext* /*context*/, const ::minknow_api::data::ResetChannelStatesRequest* /*request*/, ::minknow_api::data::ResetChannelStatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* reset_channel_states(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_lock_channel_states : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_lock_channel_states() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->lock_channel_states(context, request, response); }));
    }
    ~WithRawCallbackMethod_lock_channel_states() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status lock_channel_states(::grpc::ServerContext* /*context*/, const ::minknow_api::data::LockChannelStatesRequest* /*request*/, ::minknow_api::data::LockChannelStatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* lock_channel_states(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_unlock_channel_states : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_unlock_channel_states() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->unlock_channel_states(context, request, response); }));
    }
    ~WithRawCallbackMethod_unlock_channel_states() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status unlock_channel_states(::grpc::ServerContext* /*context*/, const ::minknow_api::data::UnlockChannelStatesRequest* /*request*/, ::minknow_api::data::UnlockChannelStatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* unlock_channel_states(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_live_reads : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_live_reads() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackBidiHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->get_live_reads(context); }));
    }
    ~WithRawCallbackMethod_get_live_reads() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_live_reads(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::minknow_api::data::GetLiveReadsResponse, ::minknow_api::data::GetLiveReadsRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* get_live_reads(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_read_statistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_read_statistics() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_read_statistics(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_read_statistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_read_statistics(::grpc::ServerContext* /*context*/, const ::minknow_api::data::GetReadStatisticsRequest* /*request*/, ::minknow_api::data::GetReadStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_read_statistics(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_experiment_yield_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_experiment_yield_info() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_experiment_yield_info(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_experiment_yield_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_experiment_yield_info(::grpc::ServerContext* /*context*/, const ::minknow_api::data::GetExperimentYieldInfoRequest* /*request*/, ::minknow_api::data::GetExperimentYieldInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_experiment_yield_info(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_data_types : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_data_types() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::data::GetDataTypesRequest, ::minknow_api::data::GetDataTypesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::data::GetDataTypesRequest, ::minknow_api::data::GetDataTypesResponse>* streamer) {
                       return this->Streamedget_data_types(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_data_types() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_data_types(::grpc::ServerContext* /*context*/, const ::minknow_api::data::GetDataTypesRequest* /*request*/, ::minknow_api::data::GetDataTypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_data_types(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::data::GetDataTypesRequest,::minknow_api::data::GetDataTypesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_reset_channel_states : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_reset_channel_states() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::data::ResetChannelStatesRequest, ::minknow_api::data::ResetChannelStatesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::data::ResetChannelStatesRequest, ::minknow_api::data::ResetChannelStatesResponse>* streamer) {
                       return this->Streamedreset_channel_states(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_reset_channel_states() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status reset_channel_states(::grpc::ServerContext* /*context*/, const ::minknow_api::data::ResetChannelStatesRequest* /*request*/, ::minknow_api::data::ResetChannelStatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedreset_channel_states(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::data::ResetChannelStatesRequest,::minknow_api::data::ResetChannelStatesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_lock_channel_states : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_lock_channel_states() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::data::LockChannelStatesRequest, ::minknow_api::data::LockChannelStatesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::data::LockChannelStatesRequest, ::minknow_api::data::LockChannelStatesResponse>* streamer) {
                       return this->Streamedlock_channel_states(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_lock_channel_states() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status lock_channel_states(::grpc::ServerContext* /*context*/, const ::minknow_api::data::LockChannelStatesRequest* /*request*/, ::minknow_api::data::LockChannelStatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedlock_channel_states(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::data::LockChannelStatesRequest,::minknow_api::data::LockChannelStatesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_unlock_channel_states : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_unlock_channel_states() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::data::UnlockChannelStatesRequest, ::minknow_api::data::UnlockChannelStatesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::data::UnlockChannelStatesRequest, ::minknow_api::data::UnlockChannelStatesResponse>* streamer) {
                       return this->Streamedunlock_channel_states(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_unlock_channel_states() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status unlock_channel_states(::grpc::ServerContext* /*context*/, const ::minknow_api::data::UnlockChannelStatesRequest* /*request*/, ::minknow_api::data::UnlockChannelStatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedunlock_channel_states(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::data::UnlockChannelStatesRequest,::minknow_api::data::UnlockChannelStatesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_read_statistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_read_statistics() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::data::GetReadStatisticsRequest, ::minknow_api::data::GetReadStatisticsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::data::GetReadStatisticsRequest, ::minknow_api::data::GetReadStatisticsResponse>* streamer) {
                       return this->Streamedget_read_statistics(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_read_statistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_read_statistics(::grpc::ServerContext* /*context*/, const ::minknow_api::data::GetReadStatisticsRequest* /*request*/, ::minknow_api::data::GetReadStatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_read_statistics(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::data::GetReadStatisticsRequest,::minknow_api::data::GetReadStatisticsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_experiment_yield_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_experiment_yield_info() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::data::GetExperimentYieldInfoRequest, ::minknow_api::data::GetExperimentYieldInfoResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::data::GetExperimentYieldInfoRequest, ::minknow_api::data::GetExperimentYieldInfoResponse>* streamer) {
                       return this->Streamedget_experiment_yield_info(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_experiment_yield_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_experiment_yield_info(::grpc::ServerContext* /*context*/, const ::minknow_api::data::GetExperimentYieldInfoRequest* /*request*/, ::minknow_api::data::GetExperimentYieldInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_experiment_yield_info(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::data::GetExperimentYieldInfoRequest,::minknow_api::data::GetExperimentYieldInfoResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_get_data_types<WithStreamedUnaryMethod_reset_channel_states<WithStreamedUnaryMethod_lock_channel_states<WithStreamedUnaryMethod_unlock_channel_states<WithStreamedUnaryMethod_get_read_statistics<WithStreamedUnaryMethod_get_experiment_yield_info<Service > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_get_channel_states : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_get_channel_states() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::minknow_api::data::GetChannelStatesRequest, ::minknow_api::data::GetChannelStatesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::minknow_api::data::GetChannelStatesRequest, ::minknow_api::data::GetChannelStatesResponse>* streamer) {
                       return this->Streamedget_channel_states(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_get_channel_states() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_channel_states(::grpc::ServerContext* /*context*/, const ::minknow_api::data::GetChannelStatesRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::data::GetChannelStatesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status Streamedget_channel_states(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::minknow_api::data::GetChannelStatesRequest,::minknow_api::data::GetChannelStatesResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_get_signal_bytes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_get_signal_bytes() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::minknow_api::data::GetSignalBytesRequest, ::minknow_api::data::GetSignalBytesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::minknow_api::data::GetSignalBytesRequest, ::minknow_api::data::GetSignalBytesResponse>* streamer) {
                       return this->Streamedget_signal_bytes(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_get_signal_bytes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_signal_bytes(::grpc::ServerContext* /*context*/, const ::minknow_api::data::GetSignalBytesRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::data::GetSignalBytesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status Streamedget_signal_bytes(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::minknow_api::data::GetSignalBytesRequest,::minknow_api::data::GetSignalBytesResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_get_signal_min_max : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_get_signal_min_max() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::minknow_api::data::GetSignalMinMaxRequest, ::minknow_api::data::GetSignalMinMaxResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::minknow_api::data::GetSignalMinMaxRequest, ::minknow_api::data::GetSignalMinMaxResponse>* streamer) {
                       return this->Streamedget_signal_min_max(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_get_signal_min_max() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_signal_min_max(::grpc::ServerContext* /*context*/, const ::minknow_api::data::GetSignalMinMaxRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::data::GetSignalMinMaxResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status Streamedget_signal_min_max(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::minknow_api::data::GetSignalMinMaxRequest,::minknow_api::data::GetSignalMinMaxResponse>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_get_channel_states<WithSplitStreamingMethod_get_signal_bytes<WithSplitStreamingMethod_get_signal_min_max<Service > > > SplitStreamedService;
  typedef WithSplitStreamingMethod_get_channel_states<WithStreamedUnaryMethod_get_data_types<WithSplitStreamingMethod_get_signal_bytes<WithSplitStreamingMethod_get_signal_min_max<WithStreamedUnaryMethod_reset_channel_states<WithStreamedUnaryMethod_lock_channel_states<WithStreamedUnaryMethod_unlock_channel_states<WithStreamedUnaryMethod_get_read_statistics<WithStreamedUnaryMethod_get_experiment_yield_info<Service > > > > > > > > > StreamedService;
};

}  // namespace data
}  // namespace minknow_api


#endif  // GRPC_minknow_5fapi_2fdata_2eproto__INCLUDED
