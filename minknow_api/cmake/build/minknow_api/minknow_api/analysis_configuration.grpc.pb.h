// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: minknow_api/analysis_configuration.proto
#ifndef GRPC_minknow_5fapi_2fanalysis_5fconfiguration_2eproto__INCLUDED
#define GRPC_minknow_5fapi_2fanalysis_5fconfiguration_2eproto__INCLUDED

#include "minknow_api/analysis_configuration.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace minknow_api {
namespace analysis_configuration {

class AnalysisConfigurationService final {
 public:
  static constexpr char const* service_full_name() {
    return "minknow_api.analysis_configuration.AnalysisConfigurationService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Get the analysis configuration
    virtual ::grpc::Status get_analysis_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetAnalysisConfigurationRequest& request, ::minknow_api::analysis_configuration::AnalysisConfiguration* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::AnalysisConfiguration>> Asyncget_analysis_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetAnalysisConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::AnalysisConfiguration>>(Asyncget_analysis_configurationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::AnalysisConfiguration>> PrepareAsyncget_analysis_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetAnalysisConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::AnalysisConfiguration>>(PrepareAsyncget_analysis_configurationRaw(context, request, cq));
    }
    // Sets the analysis configuration
    //
    // This sets the whole configuration as-is, so you have to specify the whole analysis configuration as any fields
    // there previously will be overwritten. To preserve the current analysis configuration, use a get-modify-set
    // approach. Use get_analysis_configuration to retrieve the current config and modify the fields on that copy.
    // Then use this call to set the modified version.
    //
    // The AnalysisConfiguration message is converted to/from json in Minknow, but this will be removed from later
    // versions of MinKNOW. The basecaller params are the first ones to move away from the jsn format. The old structure
    // has been kept for backwards compatibility, but it will be removed.
    //
    // The AnalysisConfiguration message is intended to be used to convert easily from protobuf to json and back again.
    // To convert from json to a protobuf message (assuming 'analysis_conf_json' holds the json data:
    //
    // >>> import minknow_api
    // >>> from google.protobuf import json_format
    // >>>
    // >>> analysis_conf_pb = minknow_api.analysis_configuration_service.AnalysisConfiguration()
    // >>> json_format.Parse(json.dumps(analysis_conf_json), analysis_conf_pb)
    //
    // To convert from a protobuf message to json:
    //
    // >>> json_data = json_format.MessageToJson(analysis_conf_resp, preserving_proto_field_name=True, including_default_value_fields=True)
    //
    // 'preserving_proto_field_name' is needed because json_format will try convert keys to json-standard(?) format, like converting
    // my_key to myKey, and the key names as seen in the protobuf file are important to minknow
    //
    // 'including_default_value_fields' is needed because in proto3, primitive values that are default initialised (like a uint32 with value 0)
    // will not be sent on the wire, so the value wouldn't appear when converting to json. In practice, most values are wrapper types and this
    // field won't have an affect in wrapper types, but it does affect enum types as the default initailised value is the 0th enum.
    //
    // NOTE: if the analysis configuration was set using the new parameters (with the filename for albacore config files), the old parameters
    // from jsn will be ignored. So set_analysis_configuration must be used with either the old protobuf message for the basecaller parameters,
    // or with the new one, but it cannot be used interleaved!
    virtual ::grpc::Status set_analysis_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::AnalysisConfiguration& request, ::minknow_api::analysis_configuration::SetAnalysisConfigurationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::SetAnalysisConfigurationResponse>> Asyncset_analysis_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::AnalysisConfiguration& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::SetAnalysisConfigurationResponse>>(Asyncset_analysis_configurationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::SetAnalysisConfigurationResponse>> PrepareAsyncset_analysis_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::AnalysisConfiguration& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::SetAnalysisConfigurationResponse>>(PrepareAsyncset_analysis_configurationRaw(context, request, cq));
    }
    // Reset the analysis configuration
    //
    // The configuration will be set to the initial default configuration that was set on boot
    //
    // Since 3.0
    virtual ::grpc::Status reset_analysis_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::ResetAnalysisConfigurationRequest& request, ::minknow_api::analysis_configuration::ResetAnalysisConfigurationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::ResetAnalysisConfigurationResponse>> Asyncreset_analysis_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::ResetAnalysisConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::ResetAnalysisConfigurationResponse>>(Asyncreset_analysis_configurationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::ResetAnalysisConfigurationResponse>> PrepareAsyncreset_analysis_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::ResetAnalysisConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::ResetAnalysisConfigurationResponse>>(PrepareAsyncreset_analysis_configurationRaw(context, request, cq));
    }
    // Enable or disable analysis entirely.
    virtual ::grpc::Status set_analysis_enabled_state(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetAnalysisEnabledStateRequest& request, ::minknow_api::analysis_configuration::SetAnalysisEnabledStateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::SetAnalysisEnabledStateResponse>> Asyncset_analysis_enabled_state(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetAnalysisEnabledStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::SetAnalysisEnabledStateResponse>>(Asyncset_analysis_enabled_stateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::SetAnalysisEnabledStateResponse>> PrepareAsyncset_analysis_enabled_state(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetAnalysisEnabledStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::SetAnalysisEnabledStateResponse>>(PrepareAsyncset_analysis_enabled_stateRaw(context, request, cq));
    }
    // Get a description of the possible channel states.
    //
    // This is a subset of the information included in the channel states section of the analysis
    // configuration. It will change when the analysis configuration changes.
    virtual ::grpc::Status get_channel_states_desc(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetChannelStatesDescRequest& request, ::minknow_api::analysis_configuration::GetChannelStatesDescResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::GetChannelStatesDescResponse>> Asyncget_channel_states_desc(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetChannelStatesDescRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::GetChannelStatesDescResponse>>(Asyncget_channel_states_descRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::GetChannelStatesDescResponse>> PrepareAsyncget_channel_states_desc(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetChannelStatesDescRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::GetChannelStatesDescResponse>>(PrepareAsyncget_channel_states_descRaw(context, request, cq));
    }
    // Get a brief summary of the analysis configuration.
    //
    // This is a high-level overview of what major parts of the analysis pipeline are enabled.
    virtual ::grpc::Status get_summary(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetSummaryRequest& request, ::minknow_api::analysis_configuration::GetSummaryResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::GetSummaryResponse>> Asyncget_summary(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetSummaryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::GetSummaryResponse>>(Asyncget_summaryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::GetSummaryResponse>> PrepareAsyncget_summary(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetSummaryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::GetSummaryResponse>>(PrepareAsyncget_summaryRaw(context, request, cq));
    }
    // Configure the basecaller which will run during acquisition.
    //
    // This rpc will result in an error if invoked during acquisition.
    //
    // By default no basecalling is performed (enable = false).
    //
    // Since 3.0
    virtual ::grpc::Status set_basecaller_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest& request, ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse>> Asyncset_basecaller_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse>>(Asyncset_basecaller_configurationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse>> PrepareAsyncset_basecaller_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse>>(PrepareAsyncset_basecaller_configurationRaw(context, request, cq));
    }
    // Inform MinKNOW the passed basecall configuration will be used at some point in the future, and could be loaded now
    // to reduce wait time in the future.
    //
    // This rpc will result in an error if invoked during acquisition.
    //
    // The call will block until any previous call to preload configs is complete, but does not block while the config
    // is loaded, no errors are reported to the caller if the config is invalid.
    //
    // Since 4.1
    virtual ::grpc::Status preload_basecaller_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest& request, ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse>> Asyncpreload_basecaller_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse>>(Asyncpreload_basecaller_configurationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse>> PrepareAsyncpreload_basecaller_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse>>(PrepareAsyncpreload_basecaller_configurationRaw(context, request, cq));
    }
    // Find the current basecaller configuration (see #set_basecaller_configuration)
    //
    // Since 3.0
    virtual ::grpc::Status get_basecaller_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetBasecallerConfigurationRequest& request, ::minknow_api::analysis_configuration::BasecallerConfiguration* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::BasecallerConfiguration>> Asyncget_basecaller_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetBasecallerConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::BasecallerConfiguration>>(Asyncget_basecaller_configurationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::BasecallerConfiguration>> PrepareAsyncget_basecaller_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetBasecallerConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::BasecallerConfiguration>>(PrepareAsyncget_basecaller_configurationRaw(context, request, cq));
    }
    // Get the pore type configuration
    //
    // Since 3.2
    virtual ::grpc::Status get_pore_type_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetPoreTypeConfigurationRequest& request, ::minknow_api::analysis_configuration::PoreTypeConfiguration* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::PoreTypeConfiguration>> Asyncget_pore_type_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetPoreTypeConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::PoreTypeConfiguration>>(Asyncget_pore_type_configurationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::PoreTypeConfiguration>> PrepareAsyncget_pore_type_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetPoreTypeConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::PoreTypeConfiguration>>(PrepareAsyncget_pore_type_configurationRaw(context, request, cq));
    }
    // Set the pore type configuration
    //
    // By default, the configuration for all wells is "not_set"
    // (global_pore_type set to "not_set")
    //
    // This rpc will result in an error if new pore types are defined during acquisition.
    // The pore type which is active on specific channel/well may be changed during acquisition.
    //
    // If an invalid PoreTypeConfiguration is supplied, an error will be returned
    // Invalid PoreTypeConfiguration include those where:
    //
    //  - No pore_type_config is set
    //  - A pore type is set to an empty string
    //  - A pore type is set to "invalid"
    //
    // If an error is returned, the pore type configuration is not updated.
    //
    // Since 3.2
    virtual ::grpc::Status set_pore_type_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::PoreTypeConfiguration& request, ::minknow_api::analysis_configuration::SetPoreTypeConfigurationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::SetPoreTypeConfigurationResponse>> Asyncset_pore_type_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::PoreTypeConfiguration& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::SetPoreTypeConfigurationResponse>>(Asyncset_pore_type_configurationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::SetPoreTypeConfigurationResponse>> PrepareAsyncset_pore_type_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::PoreTypeConfiguration& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::SetPoreTypeConfigurationResponse>>(PrepareAsyncset_pore_type_configurationRaw(context, request, cq));
    }
    // Set the writer configuration.
    //
    // Note: Calling this method overrides any previous settings stored for the writers.
    // In order to preserve settings, you should call #get_writer_configuration, mutate
    // the config, then call this method.
    //
    // Will fail with FAILED_PRECONDITION if acquisition is running.
    //
    // The default writer config is to write nothing to disk.
    //
    // Since 3.3
    virtual ::grpc::Status set_writer_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::WriterConfiguration& request, ::minknow_api::analysis_configuration::SetWriterConfigurationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::SetWriterConfigurationResponse>> Asyncset_writer_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::WriterConfiguration& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::SetWriterConfigurationResponse>>(Asyncset_writer_configurationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::SetWriterConfigurationResponse>> PrepareAsyncset_writer_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::WriterConfiguration& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::SetWriterConfigurationResponse>>(PrepareAsyncset_writer_configurationRaw(context, request, cq));
    }
    // Get the currently active writer configuration.
    //
    // Since 3.3
    virtual ::grpc::Status get_writer_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetWriterConfigurationRequest& request, ::minknow_api::analysis_configuration::WriterConfiguration* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::WriterConfiguration>> Asyncget_writer_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetWriterConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::WriterConfiguration>>(Asyncget_writer_configurationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::WriterConfiguration>> PrepareAsyncget_writer_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetWriterConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::WriterConfiguration>>(PrepareAsyncget_writer_configurationRaw(context, request, cq));
    }
    // Get a map of read classifications mapped to id (used internally in analysis).
    //
    // This will change when the analysis configuration changes.
    virtual ::grpc::Status get_read_classifications(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetReadClassificationsRequest& request, ::minknow_api::analysis_configuration::GetReadClassificationsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::GetReadClassificationsResponse>> Asyncget_read_classifications(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetReadClassificationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::GetReadClassificationsResponse>>(Asyncget_read_classificationsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::GetReadClassificationsResponse>> PrepareAsyncget_read_classifications(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetReadClassificationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::GetReadClassificationsResponse>>(PrepareAsyncget_read_classificationsRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // Get the analysis configuration
      virtual void get_analysis_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetAnalysisConfigurationRequest* request, ::minknow_api::analysis_configuration::AnalysisConfiguration* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_analysis_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetAnalysisConfigurationRequest* request, ::minknow_api::analysis_configuration::AnalysisConfiguration* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Sets the analysis configuration
      //
      // This sets the whole configuration as-is, so you have to specify the whole analysis configuration as any fields
      // there previously will be overwritten. To preserve the current analysis configuration, use a get-modify-set
      // approach. Use get_analysis_configuration to retrieve the current config and modify the fields on that copy.
      // Then use this call to set the modified version.
      //
      // The AnalysisConfiguration message is converted to/from json in Minknow, but this will be removed from later
      // versions of MinKNOW. The basecaller params are the first ones to move away from the jsn format. The old structure
      // has been kept for backwards compatibility, but it will be removed.
      //
      // The AnalysisConfiguration message is intended to be used to convert easily from protobuf to json and back again.
      // To convert from json to a protobuf message (assuming 'analysis_conf_json' holds the json data:
      //
      // >>> import minknow_api
      // >>> from google.protobuf import json_format
      // >>>
      // >>> analysis_conf_pb = minknow_api.analysis_configuration_service.AnalysisConfiguration()
      // >>> json_format.Parse(json.dumps(analysis_conf_json), analysis_conf_pb)
      //
      // To convert from a protobuf message to json:
      //
      // >>> json_data = json_format.MessageToJson(analysis_conf_resp, preserving_proto_field_name=True, including_default_value_fields=True)
      //
      // 'preserving_proto_field_name' is needed because json_format will try convert keys to json-standard(?) format, like converting
      // my_key to myKey, and the key names as seen in the protobuf file are important to minknow
      //
      // 'including_default_value_fields' is needed because in proto3, primitive values that are default initialised (like a uint32 with value 0)
      // will not be sent on the wire, so the value wouldn't appear when converting to json. In practice, most values are wrapper types and this
      // field won't have an affect in wrapper types, but it does affect enum types as the default initailised value is the 0th enum.
      //
      // NOTE: if the analysis configuration was set using the new parameters (with the filename for albacore config files), the old parameters
      // from jsn will be ignored. So set_analysis_configuration must be used with either the old protobuf message for the basecaller parameters,
      // or with the new one, but it cannot be used interleaved!
      virtual void set_analysis_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::AnalysisConfiguration* request, ::minknow_api::analysis_configuration::SetAnalysisConfigurationResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void set_analysis_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::AnalysisConfiguration* request, ::minknow_api::analysis_configuration::SetAnalysisConfigurationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Reset the analysis configuration
      //
      // The configuration will be set to the initial default configuration that was set on boot
      //
      // Since 3.0
      virtual void reset_analysis_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::ResetAnalysisConfigurationRequest* request, ::minknow_api::analysis_configuration::ResetAnalysisConfigurationResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void reset_analysis_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::ResetAnalysisConfigurationRequest* request, ::minknow_api::analysis_configuration::ResetAnalysisConfigurationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Enable or disable analysis entirely.
      virtual void set_analysis_enabled_state(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetAnalysisEnabledStateRequest* request, ::minknow_api::analysis_configuration::SetAnalysisEnabledStateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void set_analysis_enabled_state(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetAnalysisEnabledStateRequest* request, ::minknow_api::analysis_configuration::SetAnalysisEnabledStateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Get a description of the possible channel states.
      //
      // This is a subset of the information included in the channel states section of the analysis
      // configuration. It will change when the analysis configuration changes.
      virtual void get_channel_states_desc(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetChannelStatesDescRequest* request, ::minknow_api::analysis_configuration::GetChannelStatesDescResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_channel_states_desc(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetChannelStatesDescRequest* request, ::minknow_api::analysis_configuration::GetChannelStatesDescResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Get a brief summary of the analysis configuration.
      //
      // This is a high-level overview of what major parts of the analysis pipeline are enabled.
      virtual void get_summary(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetSummaryRequest* request, ::minknow_api::analysis_configuration::GetSummaryResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_summary(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetSummaryRequest* request, ::minknow_api::analysis_configuration::GetSummaryResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Configure the basecaller which will run during acquisition.
      //
      // This rpc will result in an error if invoked during acquisition.
      //
      // By default no basecalling is performed (enable = false).
      //
      // Since 3.0
      virtual void set_basecaller_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest* request, ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void set_basecaller_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest* request, ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Inform MinKNOW the passed basecall configuration will be used at some point in the future, and could be loaded now
      // to reduce wait time in the future.
      //
      // This rpc will result in an error if invoked during acquisition.
      //
      // The call will block until any previous call to preload configs is complete, but does not block while the config
      // is loaded, no errors are reported to the caller if the config is invalid.
      //
      // Since 4.1
      virtual void preload_basecaller_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest* request, ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void preload_basecaller_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest* request, ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Find the current basecaller configuration (see #set_basecaller_configuration)
      //
      // Since 3.0
      virtual void get_basecaller_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetBasecallerConfigurationRequest* request, ::minknow_api::analysis_configuration::BasecallerConfiguration* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_basecaller_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetBasecallerConfigurationRequest* request, ::minknow_api::analysis_configuration::BasecallerConfiguration* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Get the pore type configuration
      //
      // Since 3.2
      virtual void get_pore_type_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetPoreTypeConfigurationRequest* request, ::minknow_api::analysis_configuration::PoreTypeConfiguration* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_pore_type_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetPoreTypeConfigurationRequest* request, ::minknow_api::analysis_configuration::PoreTypeConfiguration* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Set the pore type configuration
      //
      // By default, the configuration for all wells is "not_set"
      // (global_pore_type set to "not_set")
      //
      // This rpc will result in an error if new pore types are defined during acquisition.
      // The pore type which is active on specific channel/well may be changed during acquisition.
      //
      // If an invalid PoreTypeConfiguration is supplied, an error will be returned
      // Invalid PoreTypeConfiguration include those where:
      //
      //  - No pore_type_config is set
      //  - A pore type is set to an empty string
      //  - A pore type is set to "invalid"
      //
      // If an error is returned, the pore type configuration is not updated.
      //
      // Since 3.2
      virtual void set_pore_type_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::PoreTypeConfiguration* request, ::minknow_api::analysis_configuration::SetPoreTypeConfigurationResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void set_pore_type_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::PoreTypeConfiguration* request, ::minknow_api::analysis_configuration::SetPoreTypeConfigurationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Set the writer configuration.
      //
      // Note: Calling this method overrides any previous settings stored for the writers.
      // In order to preserve settings, you should call #get_writer_configuration, mutate
      // the config, then call this method.
      //
      // Will fail with FAILED_PRECONDITION if acquisition is running.
      //
      // The default writer config is to write nothing to disk.
      //
      // Since 3.3
      virtual void set_writer_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::WriterConfiguration* request, ::minknow_api::analysis_configuration::SetWriterConfigurationResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void set_writer_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::WriterConfiguration* request, ::minknow_api::analysis_configuration::SetWriterConfigurationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Get the currently active writer configuration.
      //
      // Since 3.3
      virtual void get_writer_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetWriterConfigurationRequest* request, ::minknow_api::analysis_configuration::WriterConfiguration* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_writer_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetWriterConfigurationRequest* request, ::minknow_api::analysis_configuration::WriterConfiguration* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Get a map of read classifications mapped to id (used internally in analysis).
      //
      // This will change when the analysis configuration changes.
      virtual void get_read_classifications(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetReadClassificationsRequest* request, ::minknow_api::analysis_configuration::GetReadClassificationsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_read_classifications(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetReadClassificationsRequest* request, ::minknow_api::analysis_configuration::GetReadClassificationsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::AnalysisConfiguration>* Asyncget_analysis_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetAnalysisConfigurationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::AnalysisConfiguration>* PrepareAsyncget_analysis_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetAnalysisConfigurationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::SetAnalysisConfigurationResponse>* Asyncset_analysis_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::AnalysisConfiguration& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::SetAnalysisConfigurationResponse>* PrepareAsyncset_analysis_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::AnalysisConfiguration& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::ResetAnalysisConfigurationResponse>* Asyncreset_analysis_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::ResetAnalysisConfigurationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::ResetAnalysisConfigurationResponse>* PrepareAsyncreset_analysis_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::ResetAnalysisConfigurationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::SetAnalysisEnabledStateResponse>* Asyncset_analysis_enabled_stateRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetAnalysisEnabledStateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::SetAnalysisEnabledStateResponse>* PrepareAsyncset_analysis_enabled_stateRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetAnalysisEnabledStateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::GetChannelStatesDescResponse>* Asyncget_channel_states_descRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetChannelStatesDescRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::GetChannelStatesDescResponse>* PrepareAsyncget_channel_states_descRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetChannelStatesDescRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::GetSummaryResponse>* Asyncget_summaryRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetSummaryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::GetSummaryResponse>* PrepareAsyncget_summaryRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetSummaryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse>* Asyncset_basecaller_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse>* PrepareAsyncset_basecaller_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse>* Asyncpreload_basecaller_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse>* PrepareAsyncpreload_basecaller_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::BasecallerConfiguration>* Asyncget_basecaller_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetBasecallerConfigurationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::BasecallerConfiguration>* PrepareAsyncget_basecaller_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetBasecallerConfigurationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::PoreTypeConfiguration>* Asyncget_pore_type_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetPoreTypeConfigurationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::PoreTypeConfiguration>* PrepareAsyncget_pore_type_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetPoreTypeConfigurationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::SetPoreTypeConfigurationResponse>* Asyncset_pore_type_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::PoreTypeConfiguration& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::SetPoreTypeConfigurationResponse>* PrepareAsyncset_pore_type_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::PoreTypeConfiguration& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::SetWriterConfigurationResponse>* Asyncset_writer_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::WriterConfiguration& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::SetWriterConfigurationResponse>* PrepareAsyncset_writer_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::WriterConfiguration& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::WriterConfiguration>* Asyncget_writer_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetWriterConfigurationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::WriterConfiguration>* PrepareAsyncget_writer_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetWriterConfigurationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::GetReadClassificationsResponse>* Asyncget_read_classificationsRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetReadClassificationsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::analysis_configuration::GetReadClassificationsResponse>* PrepareAsyncget_read_classificationsRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetReadClassificationsRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status get_analysis_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetAnalysisConfigurationRequest& request, ::minknow_api::analysis_configuration::AnalysisConfiguration* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::AnalysisConfiguration>> Asyncget_analysis_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetAnalysisConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::AnalysisConfiguration>>(Asyncget_analysis_configurationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::AnalysisConfiguration>> PrepareAsyncget_analysis_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetAnalysisConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::AnalysisConfiguration>>(PrepareAsyncget_analysis_configurationRaw(context, request, cq));
    }
    ::grpc::Status set_analysis_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::AnalysisConfiguration& request, ::minknow_api::analysis_configuration::SetAnalysisConfigurationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::SetAnalysisConfigurationResponse>> Asyncset_analysis_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::AnalysisConfiguration& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::SetAnalysisConfigurationResponse>>(Asyncset_analysis_configurationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::SetAnalysisConfigurationResponse>> PrepareAsyncset_analysis_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::AnalysisConfiguration& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::SetAnalysisConfigurationResponse>>(PrepareAsyncset_analysis_configurationRaw(context, request, cq));
    }
    ::grpc::Status reset_analysis_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::ResetAnalysisConfigurationRequest& request, ::minknow_api::analysis_configuration::ResetAnalysisConfigurationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::ResetAnalysisConfigurationResponse>> Asyncreset_analysis_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::ResetAnalysisConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::ResetAnalysisConfigurationResponse>>(Asyncreset_analysis_configurationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::ResetAnalysisConfigurationResponse>> PrepareAsyncreset_analysis_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::ResetAnalysisConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::ResetAnalysisConfigurationResponse>>(PrepareAsyncreset_analysis_configurationRaw(context, request, cq));
    }
    ::grpc::Status set_analysis_enabled_state(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetAnalysisEnabledStateRequest& request, ::minknow_api::analysis_configuration::SetAnalysisEnabledStateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::SetAnalysisEnabledStateResponse>> Asyncset_analysis_enabled_state(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetAnalysisEnabledStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::SetAnalysisEnabledStateResponse>>(Asyncset_analysis_enabled_stateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::SetAnalysisEnabledStateResponse>> PrepareAsyncset_analysis_enabled_state(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetAnalysisEnabledStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::SetAnalysisEnabledStateResponse>>(PrepareAsyncset_analysis_enabled_stateRaw(context, request, cq));
    }
    ::grpc::Status get_channel_states_desc(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetChannelStatesDescRequest& request, ::minknow_api::analysis_configuration::GetChannelStatesDescResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::GetChannelStatesDescResponse>> Asyncget_channel_states_desc(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetChannelStatesDescRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::GetChannelStatesDescResponse>>(Asyncget_channel_states_descRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::GetChannelStatesDescResponse>> PrepareAsyncget_channel_states_desc(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetChannelStatesDescRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::GetChannelStatesDescResponse>>(PrepareAsyncget_channel_states_descRaw(context, request, cq));
    }
    ::grpc::Status get_summary(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetSummaryRequest& request, ::minknow_api::analysis_configuration::GetSummaryResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::GetSummaryResponse>> Asyncget_summary(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetSummaryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::GetSummaryResponse>>(Asyncget_summaryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::GetSummaryResponse>> PrepareAsyncget_summary(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetSummaryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::GetSummaryResponse>>(PrepareAsyncget_summaryRaw(context, request, cq));
    }
    ::grpc::Status set_basecaller_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest& request, ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse>> Asyncset_basecaller_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse>>(Asyncset_basecaller_configurationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse>> PrepareAsyncset_basecaller_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse>>(PrepareAsyncset_basecaller_configurationRaw(context, request, cq));
    }
    ::grpc::Status preload_basecaller_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest& request, ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse>> Asyncpreload_basecaller_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse>>(Asyncpreload_basecaller_configurationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse>> PrepareAsyncpreload_basecaller_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse>>(PrepareAsyncpreload_basecaller_configurationRaw(context, request, cq));
    }
    ::grpc::Status get_basecaller_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetBasecallerConfigurationRequest& request, ::minknow_api::analysis_configuration::BasecallerConfiguration* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::BasecallerConfiguration>> Asyncget_basecaller_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetBasecallerConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::BasecallerConfiguration>>(Asyncget_basecaller_configurationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::BasecallerConfiguration>> PrepareAsyncget_basecaller_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetBasecallerConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::BasecallerConfiguration>>(PrepareAsyncget_basecaller_configurationRaw(context, request, cq));
    }
    ::grpc::Status get_pore_type_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetPoreTypeConfigurationRequest& request, ::minknow_api::analysis_configuration::PoreTypeConfiguration* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::PoreTypeConfiguration>> Asyncget_pore_type_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetPoreTypeConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::PoreTypeConfiguration>>(Asyncget_pore_type_configurationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::PoreTypeConfiguration>> PrepareAsyncget_pore_type_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetPoreTypeConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::PoreTypeConfiguration>>(PrepareAsyncget_pore_type_configurationRaw(context, request, cq));
    }
    ::grpc::Status set_pore_type_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::PoreTypeConfiguration& request, ::minknow_api::analysis_configuration::SetPoreTypeConfigurationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::SetPoreTypeConfigurationResponse>> Asyncset_pore_type_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::PoreTypeConfiguration& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::SetPoreTypeConfigurationResponse>>(Asyncset_pore_type_configurationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::SetPoreTypeConfigurationResponse>> PrepareAsyncset_pore_type_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::PoreTypeConfiguration& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::SetPoreTypeConfigurationResponse>>(PrepareAsyncset_pore_type_configurationRaw(context, request, cq));
    }
    ::grpc::Status set_writer_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::WriterConfiguration& request, ::minknow_api::analysis_configuration::SetWriterConfigurationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::SetWriterConfigurationResponse>> Asyncset_writer_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::WriterConfiguration& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::SetWriterConfigurationResponse>>(Asyncset_writer_configurationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::SetWriterConfigurationResponse>> PrepareAsyncset_writer_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::WriterConfiguration& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::SetWriterConfigurationResponse>>(PrepareAsyncset_writer_configurationRaw(context, request, cq));
    }
    ::grpc::Status get_writer_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetWriterConfigurationRequest& request, ::minknow_api::analysis_configuration::WriterConfiguration* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::WriterConfiguration>> Asyncget_writer_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetWriterConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::WriterConfiguration>>(Asyncget_writer_configurationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::WriterConfiguration>> PrepareAsyncget_writer_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetWriterConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::WriterConfiguration>>(PrepareAsyncget_writer_configurationRaw(context, request, cq));
    }
    ::grpc::Status get_read_classifications(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetReadClassificationsRequest& request, ::minknow_api::analysis_configuration::GetReadClassificationsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::GetReadClassificationsResponse>> Asyncget_read_classifications(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetReadClassificationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::GetReadClassificationsResponse>>(Asyncget_read_classificationsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::GetReadClassificationsResponse>> PrepareAsyncget_read_classifications(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetReadClassificationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::GetReadClassificationsResponse>>(PrepareAsyncget_read_classificationsRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void get_analysis_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetAnalysisConfigurationRequest* request, ::minknow_api::analysis_configuration::AnalysisConfiguration* response, std::function<void(::grpc::Status)>) override;
      void get_analysis_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetAnalysisConfigurationRequest* request, ::minknow_api::analysis_configuration::AnalysisConfiguration* response, ::grpc::ClientUnaryReactor* reactor) override;
      void set_analysis_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::AnalysisConfiguration* request, ::minknow_api::analysis_configuration::SetAnalysisConfigurationResponse* response, std::function<void(::grpc::Status)>) override;
      void set_analysis_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::AnalysisConfiguration* request, ::minknow_api::analysis_configuration::SetAnalysisConfigurationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void reset_analysis_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::ResetAnalysisConfigurationRequest* request, ::minknow_api::analysis_configuration::ResetAnalysisConfigurationResponse* response, std::function<void(::grpc::Status)>) override;
      void reset_analysis_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::ResetAnalysisConfigurationRequest* request, ::minknow_api::analysis_configuration::ResetAnalysisConfigurationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void set_analysis_enabled_state(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetAnalysisEnabledStateRequest* request, ::minknow_api::analysis_configuration::SetAnalysisEnabledStateResponse* response, std::function<void(::grpc::Status)>) override;
      void set_analysis_enabled_state(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetAnalysisEnabledStateRequest* request, ::minknow_api::analysis_configuration::SetAnalysisEnabledStateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_channel_states_desc(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetChannelStatesDescRequest* request, ::minknow_api::analysis_configuration::GetChannelStatesDescResponse* response, std::function<void(::grpc::Status)>) override;
      void get_channel_states_desc(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetChannelStatesDescRequest* request, ::minknow_api::analysis_configuration::GetChannelStatesDescResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_summary(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetSummaryRequest* request, ::minknow_api::analysis_configuration::GetSummaryResponse* response, std::function<void(::grpc::Status)>) override;
      void get_summary(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetSummaryRequest* request, ::minknow_api::analysis_configuration::GetSummaryResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void set_basecaller_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest* request, ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse* response, std::function<void(::grpc::Status)>) override;
      void set_basecaller_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest* request, ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void preload_basecaller_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest* request, ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse* response, std::function<void(::grpc::Status)>) override;
      void preload_basecaller_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest* request, ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_basecaller_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetBasecallerConfigurationRequest* request, ::minknow_api::analysis_configuration::BasecallerConfiguration* response, std::function<void(::grpc::Status)>) override;
      void get_basecaller_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetBasecallerConfigurationRequest* request, ::minknow_api::analysis_configuration::BasecallerConfiguration* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_pore_type_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetPoreTypeConfigurationRequest* request, ::minknow_api::analysis_configuration::PoreTypeConfiguration* response, std::function<void(::grpc::Status)>) override;
      void get_pore_type_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetPoreTypeConfigurationRequest* request, ::minknow_api::analysis_configuration::PoreTypeConfiguration* response, ::grpc::ClientUnaryReactor* reactor) override;
      void set_pore_type_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::PoreTypeConfiguration* request, ::minknow_api::analysis_configuration::SetPoreTypeConfigurationResponse* response, std::function<void(::grpc::Status)>) override;
      void set_pore_type_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::PoreTypeConfiguration* request, ::minknow_api::analysis_configuration::SetPoreTypeConfigurationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void set_writer_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::WriterConfiguration* request, ::minknow_api::analysis_configuration::SetWriterConfigurationResponse* response, std::function<void(::grpc::Status)>) override;
      void set_writer_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::WriterConfiguration* request, ::minknow_api::analysis_configuration::SetWriterConfigurationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_writer_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetWriterConfigurationRequest* request, ::minknow_api::analysis_configuration::WriterConfiguration* response, std::function<void(::grpc::Status)>) override;
      void get_writer_configuration(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetWriterConfigurationRequest* request, ::minknow_api::analysis_configuration::WriterConfiguration* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_read_classifications(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetReadClassificationsRequest* request, ::minknow_api::analysis_configuration::GetReadClassificationsResponse* response, std::function<void(::grpc::Status)>) override;
      void get_read_classifications(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetReadClassificationsRequest* request, ::minknow_api::analysis_configuration::GetReadClassificationsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::AnalysisConfiguration>* Asyncget_analysis_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetAnalysisConfigurationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::AnalysisConfiguration>* PrepareAsyncget_analysis_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetAnalysisConfigurationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::SetAnalysisConfigurationResponse>* Asyncset_analysis_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::AnalysisConfiguration& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::SetAnalysisConfigurationResponse>* PrepareAsyncset_analysis_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::AnalysisConfiguration& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::ResetAnalysisConfigurationResponse>* Asyncreset_analysis_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::ResetAnalysisConfigurationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::ResetAnalysisConfigurationResponse>* PrepareAsyncreset_analysis_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::ResetAnalysisConfigurationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::SetAnalysisEnabledStateResponse>* Asyncset_analysis_enabled_stateRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetAnalysisEnabledStateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::SetAnalysisEnabledStateResponse>* PrepareAsyncset_analysis_enabled_stateRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetAnalysisEnabledStateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::GetChannelStatesDescResponse>* Asyncget_channel_states_descRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetChannelStatesDescRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::GetChannelStatesDescResponse>* PrepareAsyncget_channel_states_descRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetChannelStatesDescRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::GetSummaryResponse>* Asyncget_summaryRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetSummaryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::GetSummaryResponse>* PrepareAsyncget_summaryRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetSummaryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse>* Asyncset_basecaller_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse>* PrepareAsyncset_basecaller_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse>* Asyncpreload_basecaller_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse>* PrepareAsyncpreload_basecaller_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::BasecallerConfiguration>* Asyncget_basecaller_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetBasecallerConfigurationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::BasecallerConfiguration>* PrepareAsyncget_basecaller_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetBasecallerConfigurationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::PoreTypeConfiguration>* Asyncget_pore_type_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetPoreTypeConfigurationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::PoreTypeConfiguration>* PrepareAsyncget_pore_type_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetPoreTypeConfigurationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::SetPoreTypeConfigurationResponse>* Asyncset_pore_type_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::PoreTypeConfiguration& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::SetPoreTypeConfigurationResponse>* PrepareAsyncset_pore_type_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::PoreTypeConfiguration& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::SetWriterConfigurationResponse>* Asyncset_writer_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::WriterConfiguration& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::SetWriterConfigurationResponse>* PrepareAsyncset_writer_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::WriterConfiguration& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::WriterConfiguration>* Asyncget_writer_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetWriterConfigurationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::WriterConfiguration>* PrepareAsyncget_writer_configurationRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetWriterConfigurationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::GetReadClassificationsResponse>* Asyncget_read_classificationsRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetReadClassificationsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::analysis_configuration::GetReadClassificationsResponse>* PrepareAsyncget_read_classificationsRaw(::grpc::ClientContext* context, const ::minknow_api::analysis_configuration::GetReadClassificationsRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_get_analysis_configuration_;
    const ::grpc::internal::RpcMethod rpcmethod_set_analysis_configuration_;
    const ::grpc::internal::RpcMethod rpcmethod_reset_analysis_configuration_;
    const ::grpc::internal::RpcMethod rpcmethod_set_analysis_enabled_state_;
    const ::grpc::internal::RpcMethod rpcmethod_get_channel_states_desc_;
    const ::grpc::internal::RpcMethod rpcmethod_get_summary_;
    const ::grpc::internal::RpcMethod rpcmethod_set_basecaller_configuration_;
    const ::grpc::internal::RpcMethod rpcmethod_preload_basecaller_configuration_;
    const ::grpc::internal::RpcMethod rpcmethod_get_basecaller_configuration_;
    const ::grpc::internal::RpcMethod rpcmethod_get_pore_type_configuration_;
    const ::grpc::internal::RpcMethod rpcmethod_set_pore_type_configuration_;
    const ::grpc::internal::RpcMethod rpcmethod_set_writer_configuration_;
    const ::grpc::internal::RpcMethod rpcmethod_get_writer_configuration_;
    const ::grpc::internal::RpcMethod rpcmethod_get_read_classifications_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Get the analysis configuration
    virtual ::grpc::Status get_analysis_configuration(::grpc::ServerContext* context, const ::minknow_api::analysis_configuration::GetAnalysisConfigurationRequest* request, ::minknow_api::analysis_configuration::AnalysisConfiguration* response);
    // Sets the analysis configuration
    //
    // This sets the whole configuration as-is, so you have to specify the whole analysis configuration as any fields
    // there previously will be overwritten. To preserve the current analysis configuration, use a get-modify-set
    // approach. Use get_analysis_configuration to retrieve the current config and modify the fields on that copy.
    // Then use this call to set the modified version.
    //
    // The AnalysisConfiguration message is converted to/from json in Minknow, but this will be removed from later
    // versions of MinKNOW. The basecaller params are the first ones to move away from the jsn format. The old structure
    // has been kept for backwards compatibility, but it will be removed.
    //
    // The AnalysisConfiguration message is intended to be used to convert easily from protobuf to json and back again.
    // To convert from json to a protobuf message (assuming 'analysis_conf_json' holds the json data:
    //
    // >>> import minknow_api
    // >>> from google.protobuf import json_format
    // >>>
    // >>> analysis_conf_pb = minknow_api.analysis_configuration_service.AnalysisConfiguration()
    // >>> json_format.Parse(json.dumps(analysis_conf_json), analysis_conf_pb)
    //
    // To convert from a protobuf message to json:
    //
    // >>> json_data = json_format.MessageToJson(analysis_conf_resp, preserving_proto_field_name=True, including_default_value_fields=True)
    //
    // 'preserving_proto_field_name' is needed because json_format will try convert keys to json-standard(?) format, like converting
    // my_key to myKey, and the key names as seen in the protobuf file are important to minknow
    //
    // 'including_default_value_fields' is needed because in proto3, primitive values that are default initialised (like a uint32 with value 0)
    // will not be sent on the wire, so the value wouldn't appear when converting to json. In practice, most values are wrapper types and this
    // field won't have an affect in wrapper types, but it does affect enum types as the default initailised value is the 0th enum.
    //
    // NOTE: if the analysis configuration was set using the new parameters (with the filename for albacore config files), the old parameters
    // from jsn will be ignored. So set_analysis_configuration must be used with either the old protobuf message for the basecaller parameters,
    // or with the new one, but it cannot be used interleaved!
    virtual ::grpc::Status set_analysis_configuration(::grpc::ServerContext* context, const ::minknow_api::analysis_configuration::AnalysisConfiguration* request, ::minknow_api::analysis_configuration::SetAnalysisConfigurationResponse* response);
    // Reset the analysis configuration
    //
    // The configuration will be set to the initial default configuration that was set on boot
    //
    // Since 3.0
    virtual ::grpc::Status reset_analysis_configuration(::grpc::ServerContext* context, const ::minknow_api::analysis_configuration::ResetAnalysisConfigurationRequest* request, ::minknow_api::analysis_configuration::ResetAnalysisConfigurationResponse* response);
    // Enable or disable analysis entirely.
    virtual ::grpc::Status set_analysis_enabled_state(::grpc::ServerContext* context, const ::minknow_api::analysis_configuration::SetAnalysisEnabledStateRequest* request, ::minknow_api::analysis_configuration::SetAnalysisEnabledStateResponse* response);
    // Get a description of the possible channel states.
    //
    // This is a subset of the information included in the channel states section of the analysis
    // configuration. It will change when the analysis configuration changes.
    virtual ::grpc::Status get_channel_states_desc(::grpc::ServerContext* context, const ::minknow_api::analysis_configuration::GetChannelStatesDescRequest* request, ::minknow_api::analysis_configuration::GetChannelStatesDescResponse* response);
    // Get a brief summary of the analysis configuration.
    //
    // This is a high-level overview of what major parts of the analysis pipeline are enabled.
    virtual ::grpc::Status get_summary(::grpc::ServerContext* context, const ::minknow_api::analysis_configuration::GetSummaryRequest* request, ::minknow_api::analysis_configuration::GetSummaryResponse* response);
    // Configure the basecaller which will run during acquisition.
    //
    // This rpc will result in an error if invoked during acquisition.
    //
    // By default no basecalling is performed (enable = false).
    //
    // Since 3.0
    virtual ::grpc::Status set_basecaller_configuration(::grpc::ServerContext* context, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest* request, ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse* response);
    // Inform MinKNOW the passed basecall configuration will be used at some point in the future, and could be loaded now
    // to reduce wait time in the future.
    //
    // This rpc will result in an error if invoked during acquisition.
    //
    // The call will block until any previous call to preload configs is complete, but does not block while the config
    // is loaded, no errors are reported to the caller if the config is invalid.
    //
    // Since 4.1
    virtual ::grpc::Status preload_basecaller_configuration(::grpc::ServerContext* context, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest* request, ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse* response);
    // Find the current basecaller configuration (see #set_basecaller_configuration)
    //
    // Since 3.0
    virtual ::grpc::Status get_basecaller_configuration(::grpc::ServerContext* context, const ::minknow_api::analysis_configuration::GetBasecallerConfigurationRequest* request, ::minknow_api::analysis_configuration::BasecallerConfiguration* response);
    // Get the pore type configuration
    //
    // Since 3.2
    virtual ::grpc::Status get_pore_type_configuration(::grpc::ServerContext* context, const ::minknow_api::analysis_configuration::GetPoreTypeConfigurationRequest* request, ::minknow_api::analysis_configuration::PoreTypeConfiguration* response);
    // Set the pore type configuration
    //
    // By default, the configuration for all wells is "not_set"
    // (global_pore_type set to "not_set")
    //
    // This rpc will result in an error if new pore types are defined during acquisition.
    // The pore type which is active on specific channel/well may be changed during acquisition.
    //
    // If an invalid PoreTypeConfiguration is supplied, an error will be returned
    // Invalid PoreTypeConfiguration include those where:
    //
    //  - No pore_type_config is set
    //  - A pore type is set to an empty string
    //  - A pore type is set to "invalid"
    //
    // If an error is returned, the pore type configuration is not updated.
    //
    // Since 3.2
    virtual ::grpc::Status set_pore_type_configuration(::grpc::ServerContext* context, const ::minknow_api::analysis_configuration::PoreTypeConfiguration* request, ::minknow_api::analysis_configuration::SetPoreTypeConfigurationResponse* response);
    // Set the writer configuration.
    //
    // Note: Calling this method overrides any previous settings stored for the writers.
    // In order to preserve settings, you should call #get_writer_configuration, mutate
    // the config, then call this method.
    //
    // Will fail with FAILED_PRECONDITION if acquisition is running.
    //
    // The default writer config is to write nothing to disk.
    //
    // Since 3.3
    virtual ::grpc::Status set_writer_configuration(::grpc::ServerContext* context, const ::minknow_api::analysis_configuration::WriterConfiguration* request, ::minknow_api::analysis_configuration::SetWriterConfigurationResponse* response);
    // Get the currently active writer configuration.
    //
    // Since 3.3
    virtual ::grpc::Status get_writer_configuration(::grpc::ServerContext* context, const ::minknow_api::analysis_configuration::GetWriterConfigurationRequest* request, ::minknow_api::analysis_configuration::WriterConfiguration* response);
    // Get a map of read classifications mapped to id (used internally in analysis).
    //
    // This will change when the analysis configuration changes.
    virtual ::grpc::Status get_read_classifications(::grpc::ServerContext* context, const ::minknow_api::analysis_configuration::GetReadClassificationsRequest* request, ::minknow_api::analysis_configuration::GetReadClassificationsResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_get_analysis_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_analysis_configuration() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_get_analysis_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_analysis_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetAnalysisConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::AnalysisConfiguration* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_analysis_configuration(::grpc::ServerContext* context, ::minknow_api::analysis_configuration::GetAnalysisConfigurationRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::analysis_configuration::AnalysisConfiguration>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_set_analysis_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_set_analysis_configuration() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_set_analysis_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_analysis_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::AnalysisConfiguration* /*request*/, ::minknow_api::analysis_configuration::SetAnalysisConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_analysis_configuration(::grpc::ServerContext* context, ::minknow_api::analysis_configuration::AnalysisConfiguration* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::analysis_configuration::SetAnalysisConfigurationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_reset_analysis_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_reset_analysis_configuration() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_reset_analysis_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status reset_analysis_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::ResetAnalysisConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::ResetAnalysisConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestreset_analysis_configuration(::grpc::ServerContext* context, ::minknow_api::analysis_configuration::ResetAnalysisConfigurationRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::analysis_configuration::ResetAnalysisConfigurationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_set_analysis_enabled_state : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_set_analysis_enabled_state() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_set_analysis_enabled_state() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_analysis_enabled_state(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::SetAnalysisEnabledStateRequest* /*request*/, ::minknow_api::analysis_configuration::SetAnalysisEnabledStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_analysis_enabled_state(::grpc::ServerContext* context, ::minknow_api::analysis_configuration::SetAnalysisEnabledStateRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::analysis_configuration::SetAnalysisEnabledStateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_channel_states_desc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_channel_states_desc() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_get_channel_states_desc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_channel_states_desc(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetChannelStatesDescRequest* /*request*/, ::minknow_api::analysis_configuration::GetChannelStatesDescResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_channel_states_desc(::grpc::ServerContext* context, ::minknow_api::analysis_configuration::GetChannelStatesDescRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::analysis_configuration::GetChannelStatesDescResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_summary : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_summary() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_get_summary() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_summary(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetSummaryRequest* /*request*/, ::minknow_api::analysis_configuration::GetSummaryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_summary(::grpc::ServerContext* context, ::minknow_api::analysis_configuration::GetSummaryRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::analysis_configuration::GetSummaryResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_set_basecaller_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_set_basecaller_configuration() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_set_basecaller_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_basecaller_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_basecaller_configuration(::grpc::ServerContext* context, ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_preload_basecaller_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_preload_basecaller_configuration() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_preload_basecaller_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status preload_basecaller_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestpreload_basecaller_configuration(::grpc::ServerContext* context, ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_basecaller_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_basecaller_configuration() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_get_basecaller_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_basecaller_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetBasecallerConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::BasecallerConfiguration* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_basecaller_configuration(::grpc::ServerContext* context, ::minknow_api::analysis_configuration::GetBasecallerConfigurationRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::analysis_configuration::BasecallerConfiguration>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_pore_type_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_pore_type_configuration() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_get_pore_type_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_pore_type_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetPoreTypeConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::PoreTypeConfiguration* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_pore_type_configuration(::grpc::ServerContext* context, ::minknow_api::analysis_configuration::GetPoreTypeConfigurationRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::analysis_configuration::PoreTypeConfiguration>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_set_pore_type_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_set_pore_type_configuration() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_set_pore_type_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_pore_type_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::PoreTypeConfiguration* /*request*/, ::minknow_api::analysis_configuration::SetPoreTypeConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_pore_type_configuration(::grpc::ServerContext* context, ::minknow_api::analysis_configuration::PoreTypeConfiguration* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::analysis_configuration::SetPoreTypeConfigurationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_set_writer_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_set_writer_configuration() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_set_writer_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_writer_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::WriterConfiguration* /*request*/, ::minknow_api::analysis_configuration::SetWriterConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_writer_configuration(::grpc::ServerContext* context, ::minknow_api::analysis_configuration::WriterConfiguration* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::analysis_configuration::SetWriterConfigurationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_writer_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_writer_configuration() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_get_writer_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_writer_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetWriterConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::WriterConfiguration* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_writer_configuration(::grpc::ServerContext* context, ::minknow_api::analysis_configuration::GetWriterConfigurationRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::analysis_configuration::WriterConfiguration>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_read_classifications : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_read_classifications() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_get_read_classifications() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_read_classifications(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetReadClassificationsRequest* /*request*/, ::minknow_api::analysis_configuration::GetReadClassificationsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_read_classifications(::grpc::ServerContext* context, ::minknow_api::analysis_configuration::GetReadClassificationsRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::analysis_configuration::GetReadClassificationsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_get_analysis_configuration<WithAsyncMethod_set_analysis_configuration<WithAsyncMethod_reset_analysis_configuration<WithAsyncMethod_set_analysis_enabled_state<WithAsyncMethod_get_channel_states_desc<WithAsyncMethod_get_summary<WithAsyncMethod_set_basecaller_configuration<WithAsyncMethod_preload_basecaller_configuration<WithAsyncMethod_get_basecaller_configuration<WithAsyncMethod_get_pore_type_configuration<WithAsyncMethod_set_pore_type_configuration<WithAsyncMethod_set_writer_configuration<WithAsyncMethod_get_writer_configuration<WithAsyncMethod_get_read_classifications<Service > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_get_analysis_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_analysis_configuration() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::analysis_configuration::GetAnalysisConfigurationRequest, ::minknow_api::analysis_configuration::AnalysisConfiguration>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::analysis_configuration::GetAnalysisConfigurationRequest* request, ::minknow_api::analysis_configuration::AnalysisConfiguration* response) { return this->get_analysis_configuration(context, request, response); }));}
    void SetMessageAllocatorFor_get_analysis_configuration(
        ::grpc::MessageAllocator< ::minknow_api::analysis_configuration::GetAnalysisConfigurationRequest, ::minknow_api::analysis_configuration::AnalysisConfiguration>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::analysis_configuration::GetAnalysisConfigurationRequest, ::minknow_api::analysis_configuration::AnalysisConfiguration>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_analysis_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_analysis_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetAnalysisConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::AnalysisConfiguration* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_analysis_configuration(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetAnalysisConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::AnalysisConfiguration* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_set_analysis_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_set_analysis_configuration() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::analysis_configuration::AnalysisConfiguration, ::minknow_api::analysis_configuration::SetAnalysisConfigurationResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::analysis_configuration::AnalysisConfiguration* request, ::minknow_api::analysis_configuration::SetAnalysisConfigurationResponse* response) { return this->set_analysis_configuration(context, request, response); }));}
    void SetMessageAllocatorFor_set_analysis_configuration(
        ::grpc::MessageAllocator< ::minknow_api::analysis_configuration::AnalysisConfiguration, ::minknow_api::analysis_configuration::SetAnalysisConfigurationResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::analysis_configuration::AnalysisConfiguration, ::minknow_api::analysis_configuration::SetAnalysisConfigurationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_set_analysis_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_analysis_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::AnalysisConfiguration* /*request*/, ::minknow_api::analysis_configuration::SetAnalysisConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_analysis_configuration(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::analysis_configuration::AnalysisConfiguration* /*request*/, ::minknow_api::analysis_configuration::SetAnalysisConfigurationResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_reset_analysis_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_reset_analysis_configuration() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::analysis_configuration::ResetAnalysisConfigurationRequest, ::minknow_api::analysis_configuration::ResetAnalysisConfigurationResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::analysis_configuration::ResetAnalysisConfigurationRequest* request, ::minknow_api::analysis_configuration::ResetAnalysisConfigurationResponse* response) { return this->reset_analysis_configuration(context, request, response); }));}
    void SetMessageAllocatorFor_reset_analysis_configuration(
        ::grpc::MessageAllocator< ::minknow_api::analysis_configuration::ResetAnalysisConfigurationRequest, ::minknow_api::analysis_configuration::ResetAnalysisConfigurationResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::analysis_configuration::ResetAnalysisConfigurationRequest, ::minknow_api::analysis_configuration::ResetAnalysisConfigurationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_reset_analysis_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status reset_analysis_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::ResetAnalysisConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::ResetAnalysisConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* reset_analysis_configuration(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::analysis_configuration::ResetAnalysisConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::ResetAnalysisConfigurationResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_set_analysis_enabled_state : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_set_analysis_enabled_state() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::analysis_configuration::SetAnalysisEnabledStateRequest, ::minknow_api::analysis_configuration::SetAnalysisEnabledStateResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::analysis_configuration::SetAnalysisEnabledStateRequest* request, ::minknow_api::analysis_configuration::SetAnalysisEnabledStateResponse* response) { return this->set_analysis_enabled_state(context, request, response); }));}
    void SetMessageAllocatorFor_set_analysis_enabled_state(
        ::grpc::MessageAllocator< ::minknow_api::analysis_configuration::SetAnalysisEnabledStateRequest, ::minknow_api::analysis_configuration::SetAnalysisEnabledStateResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::analysis_configuration::SetAnalysisEnabledStateRequest, ::minknow_api::analysis_configuration::SetAnalysisEnabledStateResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_set_analysis_enabled_state() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_analysis_enabled_state(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::SetAnalysisEnabledStateRequest* /*request*/, ::minknow_api::analysis_configuration::SetAnalysisEnabledStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_analysis_enabled_state(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::analysis_configuration::SetAnalysisEnabledStateRequest* /*request*/, ::minknow_api::analysis_configuration::SetAnalysisEnabledStateResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_channel_states_desc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_channel_states_desc() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::analysis_configuration::GetChannelStatesDescRequest, ::minknow_api::analysis_configuration::GetChannelStatesDescResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::analysis_configuration::GetChannelStatesDescRequest* request, ::minknow_api::analysis_configuration::GetChannelStatesDescResponse* response) { return this->get_channel_states_desc(context, request, response); }));}
    void SetMessageAllocatorFor_get_channel_states_desc(
        ::grpc::MessageAllocator< ::minknow_api::analysis_configuration::GetChannelStatesDescRequest, ::minknow_api::analysis_configuration::GetChannelStatesDescResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::analysis_configuration::GetChannelStatesDescRequest, ::minknow_api::analysis_configuration::GetChannelStatesDescResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_channel_states_desc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_channel_states_desc(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetChannelStatesDescRequest* /*request*/, ::minknow_api::analysis_configuration::GetChannelStatesDescResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_channel_states_desc(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetChannelStatesDescRequest* /*request*/, ::minknow_api::analysis_configuration::GetChannelStatesDescResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_summary : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_summary() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::analysis_configuration::GetSummaryRequest, ::minknow_api::analysis_configuration::GetSummaryResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::analysis_configuration::GetSummaryRequest* request, ::minknow_api::analysis_configuration::GetSummaryResponse* response) { return this->get_summary(context, request, response); }));}
    void SetMessageAllocatorFor_get_summary(
        ::grpc::MessageAllocator< ::minknow_api::analysis_configuration::GetSummaryRequest, ::minknow_api::analysis_configuration::GetSummaryResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::analysis_configuration::GetSummaryRequest, ::minknow_api::analysis_configuration::GetSummaryResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_summary() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_summary(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetSummaryRequest* /*request*/, ::minknow_api::analysis_configuration::GetSummaryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_summary(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetSummaryRequest* /*request*/, ::minknow_api::analysis_configuration::GetSummaryResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_set_basecaller_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_set_basecaller_configuration() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest, ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest* request, ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse* response) { return this->set_basecaller_configuration(context, request, response); }));}
    void SetMessageAllocatorFor_set_basecaller_configuration(
        ::grpc::MessageAllocator< ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest, ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest, ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_set_basecaller_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_basecaller_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_basecaller_configuration(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_preload_basecaller_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_preload_basecaller_configuration() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest, ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest* request, ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse* response) { return this->preload_basecaller_configuration(context, request, response); }));}
    void SetMessageAllocatorFor_preload_basecaller_configuration(
        ::grpc::MessageAllocator< ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest, ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest, ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_preload_basecaller_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status preload_basecaller_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* preload_basecaller_configuration(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_basecaller_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_basecaller_configuration() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::analysis_configuration::GetBasecallerConfigurationRequest, ::minknow_api::analysis_configuration::BasecallerConfiguration>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::analysis_configuration::GetBasecallerConfigurationRequest* request, ::minknow_api::analysis_configuration::BasecallerConfiguration* response) { return this->get_basecaller_configuration(context, request, response); }));}
    void SetMessageAllocatorFor_get_basecaller_configuration(
        ::grpc::MessageAllocator< ::minknow_api::analysis_configuration::GetBasecallerConfigurationRequest, ::minknow_api::analysis_configuration::BasecallerConfiguration>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::analysis_configuration::GetBasecallerConfigurationRequest, ::minknow_api::analysis_configuration::BasecallerConfiguration>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_basecaller_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_basecaller_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetBasecallerConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::BasecallerConfiguration* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_basecaller_configuration(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetBasecallerConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::BasecallerConfiguration* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_pore_type_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_pore_type_configuration() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::analysis_configuration::GetPoreTypeConfigurationRequest, ::minknow_api::analysis_configuration::PoreTypeConfiguration>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::analysis_configuration::GetPoreTypeConfigurationRequest* request, ::minknow_api::analysis_configuration::PoreTypeConfiguration* response) { return this->get_pore_type_configuration(context, request, response); }));}
    void SetMessageAllocatorFor_get_pore_type_configuration(
        ::grpc::MessageAllocator< ::minknow_api::analysis_configuration::GetPoreTypeConfigurationRequest, ::minknow_api::analysis_configuration::PoreTypeConfiguration>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::analysis_configuration::GetPoreTypeConfigurationRequest, ::minknow_api::analysis_configuration::PoreTypeConfiguration>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_pore_type_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_pore_type_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetPoreTypeConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::PoreTypeConfiguration* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_pore_type_configuration(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetPoreTypeConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::PoreTypeConfiguration* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_set_pore_type_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_set_pore_type_configuration() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::analysis_configuration::PoreTypeConfiguration, ::minknow_api::analysis_configuration::SetPoreTypeConfigurationResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::analysis_configuration::PoreTypeConfiguration* request, ::minknow_api::analysis_configuration::SetPoreTypeConfigurationResponse* response) { return this->set_pore_type_configuration(context, request, response); }));}
    void SetMessageAllocatorFor_set_pore_type_configuration(
        ::grpc::MessageAllocator< ::minknow_api::analysis_configuration::PoreTypeConfiguration, ::minknow_api::analysis_configuration::SetPoreTypeConfigurationResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::analysis_configuration::PoreTypeConfiguration, ::minknow_api::analysis_configuration::SetPoreTypeConfigurationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_set_pore_type_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_pore_type_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::PoreTypeConfiguration* /*request*/, ::minknow_api::analysis_configuration::SetPoreTypeConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_pore_type_configuration(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::analysis_configuration::PoreTypeConfiguration* /*request*/, ::minknow_api::analysis_configuration::SetPoreTypeConfigurationResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_set_writer_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_set_writer_configuration() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::analysis_configuration::WriterConfiguration, ::minknow_api::analysis_configuration::SetWriterConfigurationResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::analysis_configuration::WriterConfiguration* request, ::minknow_api::analysis_configuration::SetWriterConfigurationResponse* response) { return this->set_writer_configuration(context, request, response); }));}
    void SetMessageAllocatorFor_set_writer_configuration(
        ::grpc::MessageAllocator< ::minknow_api::analysis_configuration::WriterConfiguration, ::minknow_api::analysis_configuration::SetWriterConfigurationResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::analysis_configuration::WriterConfiguration, ::minknow_api::analysis_configuration::SetWriterConfigurationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_set_writer_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_writer_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::WriterConfiguration* /*request*/, ::minknow_api::analysis_configuration::SetWriterConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_writer_configuration(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::analysis_configuration::WriterConfiguration* /*request*/, ::minknow_api::analysis_configuration::SetWriterConfigurationResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_writer_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_writer_configuration() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::analysis_configuration::GetWriterConfigurationRequest, ::minknow_api::analysis_configuration::WriterConfiguration>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::analysis_configuration::GetWriterConfigurationRequest* request, ::minknow_api::analysis_configuration::WriterConfiguration* response) { return this->get_writer_configuration(context, request, response); }));}
    void SetMessageAllocatorFor_get_writer_configuration(
        ::grpc::MessageAllocator< ::minknow_api::analysis_configuration::GetWriterConfigurationRequest, ::minknow_api::analysis_configuration::WriterConfiguration>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::analysis_configuration::GetWriterConfigurationRequest, ::minknow_api::analysis_configuration::WriterConfiguration>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_writer_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_writer_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetWriterConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::WriterConfiguration* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_writer_configuration(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetWriterConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::WriterConfiguration* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_read_classifications : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_read_classifications() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::analysis_configuration::GetReadClassificationsRequest, ::minknow_api::analysis_configuration::GetReadClassificationsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::analysis_configuration::GetReadClassificationsRequest* request, ::minknow_api::analysis_configuration::GetReadClassificationsResponse* response) { return this->get_read_classifications(context, request, response); }));}
    void SetMessageAllocatorFor_get_read_classifications(
        ::grpc::MessageAllocator< ::minknow_api::analysis_configuration::GetReadClassificationsRequest, ::minknow_api::analysis_configuration::GetReadClassificationsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::analysis_configuration::GetReadClassificationsRequest, ::minknow_api::analysis_configuration::GetReadClassificationsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_read_classifications() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_read_classifications(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetReadClassificationsRequest* /*request*/, ::minknow_api::analysis_configuration::GetReadClassificationsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_read_classifications(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetReadClassificationsRequest* /*request*/, ::minknow_api::analysis_configuration::GetReadClassificationsResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_get_analysis_configuration<WithCallbackMethod_set_analysis_configuration<WithCallbackMethod_reset_analysis_configuration<WithCallbackMethod_set_analysis_enabled_state<WithCallbackMethod_get_channel_states_desc<WithCallbackMethod_get_summary<WithCallbackMethod_set_basecaller_configuration<WithCallbackMethod_preload_basecaller_configuration<WithCallbackMethod_get_basecaller_configuration<WithCallbackMethod_get_pore_type_configuration<WithCallbackMethod_set_pore_type_configuration<WithCallbackMethod_set_writer_configuration<WithCallbackMethod_get_writer_configuration<WithCallbackMethod_get_read_classifications<Service > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_get_analysis_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_analysis_configuration() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_get_analysis_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_analysis_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetAnalysisConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::AnalysisConfiguration* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_set_analysis_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_set_analysis_configuration() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_set_analysis_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_analysis_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::AnalysisConfiguration* /*request*/, ::minknow_api::analysis_configuration::SetAnalysisConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_reset_analysis_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_reset_analysis_configuration() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_reset_analysis_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status reset_analysis_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::ResetAnalysisConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::ResetAnalysisConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_set_analysis_enabled_state : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_set_analysis_enabled_state() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_set_analysis_enabled_state() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_analysis_enabled_state(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::SetAnalysisEnabledStateRequest* /*request*/, ::minknow_api::analysis_configuration::SetAnalysisEnabledStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_channel_states_desc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_channel_states_desc() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_get_channel_states_desc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_channel_states_desc(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetChannelStatesDescRequest* /*request*/, ::minknow_api::analysis_configuration::GetChannelStatesDescResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_summary : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_summary() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_get_summary() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_summary(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetSummaryRequest* /*request*/, ::minknow_api::analysis_configuration::GetSummaryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_set_basecaller_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_set_basecaller_configuration() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_set_basecaller_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_basecaller_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_preload_basecaller_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_preload_basecaller_configuration() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_preload_basecaller_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status preload_basecaller_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_basecaller_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_basecaller_configuration() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_get_basecaller_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_basecaller_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetBasecallerConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::BasecallerConfiguration* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_pore_type_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_pore_type_configuration() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_get_pore_type_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_pore_type_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetPoreTypeConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::PoreTypeConfiguration* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_set_pore_type_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_set_pore_type_configuration() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_set_pore_type_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_pore_type_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::PoreTypeConfiguration* /*request*/, ::minknow_api::analysis_configuration::SetPoreTypeConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_set_writer_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_set_writer_configuration() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_set_writer_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_writer_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::WriterConfiguration* /*request*/, ::minknow_api::analysis_configuration::SetWriterConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_writer_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_writer_configuration() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_get_writer_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_writer_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetWriterConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::WriterConfiguration* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_read_classifications : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_read_classifications() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_get_read_classifications() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_read_classifications(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetReadClassificationsRequest* /*request*/, ::minknow_api::analysis_configuration::GetReadClassificationsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_analysis_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_analysis_configuration() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_get_analysis_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_analysis_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetAnalysisConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::AnalysisConfiguration* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_analysis_configuration(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_set_analysis_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_set_analysis_configuration() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_set_analysis_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_analysis_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::AnalysisConfiguration* /*request*/, ::minknow_api::analysis_configuration::SetAnalysisConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_analysis_configuration(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_reset_analysis_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_reset_analysis_configuration() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_reset_analysis_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status reset_analysis_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::ResetAnalysisConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::ResetAnalysisConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestreset_analysis_configuration(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_set_analysis_enabled_state : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_set_analysis_enabled_state() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_set_analysis_enabled_state() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_analysis_enabled_state(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::SetAnalysisEnabledStateRequest* /*request*/, ::minknow_api::analysis_configuration::SetAnalysisEnabledStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_analysis_enabled_state(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_channel_states_desc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_channel_states_desc() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_get_channel_states_desc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_channel_states_desc(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetChannelStatesDescRequest* /*request*/, ::minknow_api::analysis_configuration::GetChannelStatesDescResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_channel_states_desc(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_summary : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_summary() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_get_summary() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_summary(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetSummaryRequest* /*request*/, ::minknow_api::analysis_configuration::GetSummaryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_summary(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_set_basecaller_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_set_basecaller_configuration() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_set_basecaller_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_basecaller_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_basecaller_configuration(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_preload_basecaller_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_preload_basecaller_configuration() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_preload_basecaller_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status preload_basecaller_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestpreload_basecaller_configuration(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_basecaller_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_basecaller_configuration() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_get_basecaller_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_basecaller_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetBasecallerConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::BasecallerConfiguration* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_basecaller_configuration(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_pore_type_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_pore_type_configuration() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_get_pore_type_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_pore_type_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetPoreTypeConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::PoreTypeConfiguration* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_pore_type_configuration(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_set_pore_type_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_set_pore_type_configuration() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_set_pore_type_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_pore_type_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::PoreTypeConfiguration* /*request*/, ::minknow_api::analysis_configuration::SetPoreTypeConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_pore_type_configuration(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_set_writer_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_set_writer_configuration() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_set_writer_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_writer_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::WriterConfiguration* /*request*/, ::minknow_api::analysis_configuration::SetWriterConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_writer_configuration(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_writer_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_writer_configuration() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_get_writer_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_writer_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetWriterConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::WriterConfiguration* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_writer_configuration(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_read_classifications : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_read_classifications() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_get_read_classifications() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_read_classifications(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetReadClassificationsRequest* /*request*/, ::minknow_api::analysis_configuration::GetReadClassificationsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_read_classifications(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_analysis_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_analysis_configuration() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_analysis_configuration(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_analysis_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_analysis_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetAnalysisConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::AnalysisConfiguration* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_analysis_configuration(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_set_analysis_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_set_analysis_configuration() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->set_analysis_configuration(context, request, response); }));
    }
    ~WithRawCallbackMethod_set_analysis_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_analysis_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::AnalysisConfiguration* /*request*/, ::minknow_api::analysis_configuration::SetAnalysisConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_analysis_configuration(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_reset_analysis_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_reset_analysis_configuration() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->reset_analysis_configuration(context, request, response); }));
    }
    ~WithRawCallbackMethod_reset_analysis_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status reset_analysis_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::ResetAnalysisConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::ResetAnalysisConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* reset_analysis_configuration(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_set_analysis_enabled_state : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_set_analysis_enabled_state() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->set_analysis_enabled_state(context, request, response); }));
    }
    ~WithRawCallbackMethod_set_analysis_enabled_state() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_analysis_enabled_state(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::SetAnalysisEnabledStateRequest* /*request*/, ::minknow_api::analysis_configuration::SetAnalysisEnabledStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_analysis_enabled_state(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_channel_states_desc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_channel_states_desc() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_channel_states_desc(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_channel_states_desc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_channel_states_desc(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetChannelStatesDescRequest* /*request*/, ::minknow_api::analysis_configuration::GetChannelStatesDescResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_channel_states_desc(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_summary : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_summary() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_summary(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_summary() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_summary(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetSummaryRequest* /*request*/, ::minknow_api::analysis_configuration::GetSummaryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_summary(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_set_basecaller_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_set_basecaller_configuration() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->set_basecaller_configuration(context, request, response); }));
    }
    ~WithRawCallbackMethod_set_basecaller_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_basecaller_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_basecaller_configuration(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_preload_basecaller_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_preload_basecaller_configuration() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->preload_basecaller_configuration(context, request, response); }));
    }
    ~WithRawCallbackMethod_preload_basecaller_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status preload_basecaller_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* preload_basecaller_configuration(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_basecaller_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_basecaller_configuration() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_basecaller_configuration(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_basecaller_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_basecaller_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetBasecallerConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::BasecallerConfiguration* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_basecaller_configuration(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_pore_type_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_pore_type_configuration() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_pore_type_configuration(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_pore_type_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_pore_type_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetPoreTypeConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::PoreTypeConfiguration* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_pore_type_configuration(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_set_pore_type_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_set_pore_type_configuration() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->set_pore_type_configuration(context, request, response); }));
    }
    ~WithRawCallbackMethod_set_pore_type_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_pore_type_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::PoreTypeConfiguration* /*request*/, ::minknow_api::analysis_configuration::SetPoreTypeConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_pore_type_configuration(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_set_writer_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_set_writer_configuration() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->set_writer_configuration(context, request, response); }));
    }
    ~WithRawCallbackMethod_set_writer_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_writer_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::WriterConfiguration* /*request*/, ::minknow_api::analysis_configuration::SetWriterConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_writer_configuration(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_writer_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_writer_configuration() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_writer_configuration(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_writer_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_writer_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetWriterConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::WriterConfiguration* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_writer_configuration(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_read_classifications : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_read_classifications() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_read_classifications(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_read_classifications() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_read_classifications(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetReadClassificationsRequest* /*request*/, ::minknow_api::analysis_configuration::GetReadClassificationsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_read_classifications(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_analysis_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_analysis_configuration() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::analysis_configuration::GetAnalysisConfigurationRequest, ::minknow_api::analysis_configuration::AnalysisConfiguration>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::analysis_configuration::GetAnalysisConfigurationRequest, ::minknow_api::analysis_configuration::AnalysisConfiguration>* streamer) {
                       return this->Streamedget_analysis_configuration(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_analysis_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_analysis_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetAnalysisConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::AnalysisConfiguration* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_analysis_configuration(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::analysis_configuration::GetAnalysisConfigurationRequest,::minknow_api::analysis_configuration::AnalysisConfiguration>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_set_analysis_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_set_analysis_configuration() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::analysis_configuration::AnalysisConfiguration, ::minknow_api::analysis_configuration::SetAnalysisConfigurationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::analysis_configuration::AnalysisConfiguration, ::minknow_api::analysis_configuration::SetAnalysisConfigurationResponse>* streamer) {
                       return this->Streamedset_analysis_configuration(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_set_analysis_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status set_analysis_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::AnalysisConfiguration* /*request*/, ::minknow_api::analysis_configuration::SetAnalysisConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedset_analysis_configuration(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::analysis_configuration::AnalysisConfiguration,::minknow_api::analysis_configuration::SetAnalysisConfigurationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_reset_analysis_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_reset_analysis_configuration() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::analysis_configuration::ResetAnalysisConfigurationRequest, ::minknow_api::analysis_configuration::ResetAnalysisConfigurationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::analysis_configuration::ResetAnalysisConfigurationRequest, ::minknow_api::analysis_configuration::ResetAnalysisConfigurationResponse>* streamer) {
                       return this->Streamedreset_analysis_configuration(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_reset_analysis_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status reset_analysis_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::ResetAnalysisConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::ResetAnalysisConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedreset_analysis_configuration(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::analysis_configuration::ResetAnalysisConfigurationRequest,::minknow_api::analysis_configuration::ResetAnalysisConfigurationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_set_analysis_enabled_state : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_set_analysis_enabled_state() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::analysis_configuration::SetAnalysisEnabledStateRequest, ::minknow_api::analysis_configuration::SetAnalysisEnabledStateResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::analysis_configuration::SetAnalysisEnabledStateRequest, ::minknow_api::analysis_configuration::SetAnalysisEnabledStateResponse>* streamer) {
                       return this->Streamedset_analysis_enabled_state(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_set_analysis_enabled_state() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status set_analysis_enabled_state(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::SetAnalysisEnabledStateRequest* /*request*/, ::minknow_api::analysis_configuration::SetAnalysisEnabledStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedset_analysis_enabled_state(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::analysis_configuration::SetAnalysisEnabledStateRequest,::minknow_api::analysis_configuration::SetAnalysisEnabledStateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_channel_states_desc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_channel_states_desc() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::analysis_configuration::GetChannelStatesDescRequest, ::minknow_api::analysis_configuration::GetChannelStatesDescResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::analysis_configuration::GetChannelStatesDescRequest, ::minknow_api::analysis_configuration::GetChannelStatesDescResponse>* streamer) {
                       return this->Streamedget_channel_states_desc(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_channel_states_desc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_channel_states_desc(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetChannelStatesDescRequest* /*request*/, ::minknow_api::analysis_configuration::GetChannelStatesDescResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_channel_states_desc(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::analysis_configuration::GetChannelStatesDescRequest,::minknow_api::analysis_configuration::GetChannelStatesDescResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_summary : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_summary() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::analysis_configuration::GetSummaryRequest, ::minknow_api::analysis_configuration::GetSummaryResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::analysis_configuration::GetSummaryRequest, ::minknow_api::analysis_configuration::GetSummaryResponse>* streamer) {
                       return this->Streamedget_summary(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_summary() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_summary(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetSummaryRequest* /*request*/, ::minknow_api::analysis_configuration::GetSummaryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_summary(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::analysis_configuration::GetSummaryRequest,::minknow_api::analysis_configuration::GetSummaryResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_set_basecaller_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_set_basecaller_configuration() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest, ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest, ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse>* streamer) {
                       return this->Streamedset_basecaller_configuration(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_set_basecaller_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status set_basecaller_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedset_basecaller_configuration(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest,::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_preload_basecaller_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_preload_basecaller_configuration() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest, ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest, ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse>* streamer) {
                       return this->Streamedpreload_basecaller_configuration(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_preload_basecaller_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status preload_basecaller_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedpreload_basecaller_configuration(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::analysis_configuration::SetBasecallerConfigurationRequest,::minknow_api::analysis_configuration::SetBasecallerConfigurationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_basecaller_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_basecaller_configuration() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::analysis_configuration::GetBasecallerConfigurationRequest, ::minknow_api::analysis_configuration::BasecallerConfiguration>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::analysis_configuration::GetBasecallerConfigurationRequest, ::minknow_api::analysis_configuration::BasecallerConfiguration>* streamer) {
                       return this->Streamedget_basecaller_configuration(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_basecaller_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_basecaller_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetBasecallerConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::BasecallerConfiguration* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_basecaller_configuration(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::analysis_configuration::GetBasecallerConfigurationRequest,::minknow_api::analysis_configuration::BasecallerConfiguration>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_pore_type_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_pore_type_configuration() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::analysis_configuration::GetPoreTypeConfigurationRequest, ::minknow_api::analysis_configuration::PoreTypeConfiguration>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::analysis_configuration::GetPoreTypeConfigurationRequest, ::minknow_api::analysis_configuration::PoreTypeConfiguration>* streamer) {
                       return this->Streamedget_pore_type_configuration(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_pore_type_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_pore_type_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetPoreTypeConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::PoreTypeConfiguration* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_pore_type_configuration(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::analysis_configuration::GetPoreTypeConfigurationRequest,::minknow_api::analysis_configuration::PoreTypeConfiguration>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_set_pore_type_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_set_pore_type_configuration() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::analysis_configuration::PoreTypeConfiguration, ::minknow_api::analysis_configuration::SetPoreTypeConfigurationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::analysis_configuration::PoreTypeConfiguration, ::minknow_api::analysis_configuration::SetPoreTypeConfigurationResponse>* streamer) {
                       return this->Streamedset_pore_type_configuration(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_set_pore_type_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status set_pore_type_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::PoreTypeConfiguration* /*request*/, ::minknow_api::analysis_configuration::SetPoreTypeConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedset_pore_type_configuration(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::analysis_configuration::PoreTypeConfiguration,::minknow_api::analysis_configuration::SetPoreTypeConfigurationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_set_writer_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_set_writer_configuration() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::analysis_configuration::WriterConfiguration, ::minknow_api::analysis_configuration::SetWriterConfigurationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::analysis_configuration::WriterConfiguration, ::minknow_api::analysis_configuration::SetWriterConfigurationResponse>* streamer) {
                       return this->Streamedset_writer_configuration(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_set_writer_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status set_writer_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::WriterConfiguration* /*request*/, ::minknow_api::analysis_configuration::SetWriterConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedset_writer_configuration(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::analysis_configuration::WriterConfiguration,::minknow_api::analysis_configuration::SetWriterConfigurationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_writer_configuration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_writer_configuration() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::analysis_configuration::GetWriterConfigurationRequest, ::minknow_api::analysis_configuration::WriterConfiguration>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::analysis_configuration::GetWriterConfigurationRequest, ::minknow_api::analysis_configuration::WriterConfiguration>* streamer) {
                       return this->Streamedget_writer_configuration(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_writer_configuration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_writer_configuration(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetWriterConfigurationRequest* /*request*/, ::minknow_api::analysis_configuration::WriterConfiguration* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_writer_configuration(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::analysis_configuration::GetWriterConfigurationRequest,::minknow_api::analysis_configuration::WriterConfiguration>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_read_classifications : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_read_classifications() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::analysis_configuration::GetReadClassificationsRequest, ::minknow_api::analysis_configuration::GetReadClassificationsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::analysis_configuration::GetReadClassificationsRequest, ::minknow_api::analysis_configuration::GetReadClassificationsResponse>* streamer) {
                       return this->Streamedget_read_classifications(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_read_classifications() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_read_classifications(::grpc::ServerContext* /*context*/, const ::minknow_api::analysis_configuration::GetReadClassificationsRequest* /*request*/, ::minknow_api::analysis_configuration::GetReadClassificationsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_read_classifications(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::analysis_configuration::GetReadClassificationsRequest,::minknow_api::analysis_configuration::GetReadClassificationsResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_get_analysis_configuration<WithStreamedUnaryMethod_set_analysis_configuration<WithStreamedUnaryMethod_reset_analysis_configuration<WithStreamedUnaryMethod_set_analysis_enabled_state<WithStreamedUnaryMethod_get_channel_states_desc<WithStreamedUnaryMethod_get_summary<WithStreamedUnaryMethod_set_basecaller_configuration<WithStreamedUnaryMethod_preload_basecaller_configuration<WithStreamedUnaryMethod_get_basecaller_configuration<WithStreamedUnaryMethod_get_pore_type_configuration<WithStreamedUnaryMethod_set_pore_type_configuration<WithStreamedUnaryMethod_set_writer_configuration<WithStreamedUnaryMethod_get_writer_configuration<WithStreamedUnaryMethod_get_read_classifications<Service > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_get_analysis_configuration<WithStreamedUnaryMethod_set_analysis_configuration<WithStreamedUnaryMethod_reset_analysis_configuration<WithStreamedUnaryMethod_set_analysis_enabled_state<WithStreamedUnaryMethod_get_channel_states_desc<WithStreamedUnaryMethod_get_summary<WithStreamedUnaryMethod_set_basecaller_configuration<WithStreamedUnaryMethod_preload_basecaller_configuration<WithStreamedUnaryMethod_get_basecaller_configuration<WithStreamedUnaryMethod_get_pore_type_configuration<WithStreamedUnaryMethod_set_pore_type_configuration<WithStreamedUnaryMethod_set_writer_configuration<WithStreamedUnaryMethod_get_writer_configuration<WithStreamedUnaryMethod_get_read_classifications<Service > > > > > > > > > > > > > > StreamedService;
};

}  // namespace analysis_configuration
}  // namespace minknow_api


#endif  // GRPC_minknow_5fapi_2fanalysis_5fconfiguration_2eproto__INCLUDED
