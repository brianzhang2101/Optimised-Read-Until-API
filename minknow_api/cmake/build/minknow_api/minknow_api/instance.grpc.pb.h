// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: minknow_api/instance.proto
#ifndef GRPC_minknow_5fapi_2finstance_2eproto__INCLUDED
#define GRPC_minknow_5fapi_2finstance_2eproto__INCLUDED

#include "minknow_api/instance.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace minknow_api {
namespace instance {

class InstanceService final {
 public:
  static constexpr char const* service_full_name() {
    return "minknow_api.instance.InstanceService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Current version information includes:
    // - Minknow version
    // - Protocols version
    // - Distribution version
    virtual ::grpc::Status get_version_info(::grpc::ClientContext* context, const ::minknow_api::instance::GetVersionInfoRequest& request, ::minknow_api::instance::GetVersionInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::GetVersionInfoResponse>> Asyncget_version_info(::grpc::ClientContext* context, const ::minknow_api::instance::GetVersionInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::GetVersionInfoResponse>>(Asyncget_version_infoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::GetVersionInfoResponse>> PrepareAsyncget_version_info(::grpc::ClientContext* context, const ::minknow_api::instance::GetVersionInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::GetVersionInfoResponse>>(PrepareAsyncget_version_infoRaw(context, request, cq));
    }
    // Returns various directory locations where minknow is outputting data. The paths are absolute paths, 
    // local to the machine where minknow is installed
    //
    // the `output` base directory can be changed internally
    // the `logs` directory will not be changed and can be stored
    // the `reads` directory is determined  by the read writer config
    virtual ::grpc::Status get_output_directories(::grpc::ClientContext* context, const ::minknow_api::instance::GetOutputDirectoriesRequest& request, ::minknow_api::instance::OutputDirectories* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::OutputDirectories>> Asyncget_output_directories(::grpc::ClientContext* context, const ::minknow_api::instance::GetOutputDirectoriesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::OutputDirectories>>(Asyncget_output_directoriesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::OutputDirectories>> PrepareAsyncget_output_directories(::grpc::ClientContext* context, const ::minknow_api::instance::GetOutputDirectoriesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::OutputDirectories>>(PrepareAsyncget_output_directoriesRaw(context, request, cq));
    }
    // See `get_output_directories`, but this will always return the paths that are defined in the config when the instance
    // of minknow has started
    //
    // Since 1.11
    virtual ::grpc::Status get_default_output_directories(::grpc::ClientContext* context, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest& request, ::minknow_api::instance::OutputDirectories* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::OutputDirectories>> Asyncget_default_output_directories(::grpc::ClientContext* context, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::OutputDirectories>>(Asyncget_default_output_directoriesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::OutputDirectories>> PrepareAsyncget_default_output_directories(::grpc::ClientContext* context, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::OutputDirectories>>(PrepareAsyncget_default_output_directoriesRaw(context, request, cq));
    }
    // Set the base directory to where all data will be output. Must be an absolute directory
    //
    // Fails with INVALID_ARGUMENT if `value` is not absolute.
    // Fails with FAILED_PRECONDITION if this is called during acquisition
    //
    // Since 1.11
    virtual ::grpc::Status set_output_directory(::grpc::ClientContext* context, const ::minknow_api::instance::SetOutputDirectoryRequest& request, ::minknow_api::instance::SetOutputDirectoryResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::SetOutputDirectoryResponse>> Asyncset_output_directory(::grpc::ClientContext* context, const ::minknow_api::instance::SetOutputDirectoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::SetOutputDirectoryResponse>>(Asyncset_output_directoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::SetOutputDirectoryResponse>> PrepareAsyncset_output_directory(::grpc::ClientContext* context, const ::minknow_api::instance::SetOutputDirectoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::SetOutputDirectoryResponse>>(PrepareAsyncset_output_directoryRaw(context, request, cq));
    }
    // Set the reads directory where read files (hdf5, fastq, protobuf) will be output
    //
    // Fails with INVALID_ARGUMENT if `value` is not absolute.
    // Fails with FAILED_PRECONDITION if this is called during acquisition
    //
    // Since 1.12
    virtual ::grpc::Status set_reads_directory(::grpc::ClientContext* context, const ::minknow_api::instance::SetReadsDirectoryRequest& request, ::minknow_api::instance::SetReadsDirectoryResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::SetReadsDirectoryResponse>> Asyncset_reads_directory(::grpc::ClientContext* context, const ::minknow_api::instance::SetReadsDirectoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::SetReadsDirectoryResponse>>(Asyncset_reads_directoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::SetReadsDirectoryResponse>> PrepareAsyncset_reads_directory(::grpc::ClientContext* context, const ::minknow_api::instance::SetReadsDirectoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::SetReadsDirectoryResponse>>(PrepareAsyncset_reads_directoryRaw(context, request, cq));
    }
    // Returns information about the amount of disk space available, how much
    // space is needed to stop an experiment cleanly and if MinKNOW thinks
    // that the free disk-space is approaching or past this limit
    //
    // Since 1.11
    virtual ::grpc::Status get_disk_space_info(::grpc::ClientContext* context, const ::minknow_api::instance::GetDiskSpaceInfoRequest& request, ::minknow_api::instance::GetDiskSpaceInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::GetDiskSpaceInfoResponse>> Asyncget_disk_space_info(::grpc::ClientContext* context, const ::minknow_api::instance::GetDiskSpaceInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::GetDiskSpaceInfoResponse>>(Asyncget_disk_space_infoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::GetDiskSpaceInfoResponse>> PrepareAsyncget_disk_space_info(::grpc::ClientContext* context, const ::minknow_api::instance::GetDiskSpaceInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::GetDiskSpaceInfoResponse>>(PrepareAsyncget_disk_space_infoRaw(context, request, cq));
    }
    // Stream information about the amount of disk space available, how quickly
    // it is being used, how much space is needed to stop an experiment cleanly
    // and if MinKNOW thinks that the free disk-space is approaching or past
    // this limit
    //
    // Since 4.0
    std::unique_ptr< ::grpc::ClientReaderInterface< ::minknow_api::instance::GetDiskSpaceInfoResponse>> stream_disk_space_info(::grpc::ClientContext* context, const ::minknow_api::instance::StreamDiskSpaceInfoRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::minknow_api::instance::GetDiskSpaceInfoResponse>>(stream_disk_space_infoRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::instance::GetDiskSpaceInfoResponse>> Asyncstream_disk_space_info(::grpc::ClientContext* context, const ::minknow_api::instance::StreamDiskSpaceInfoRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::instance::GetDiskSpaceInfoResponse>>(Asyncstream_disk_space_infoRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::instance::GetDiskSpaceInfoResponse>> PrepareAsyncstream_disk_space_info(::grpc::ClientContext* context, const ::minknow_api::instance::StreamDiskSpaceInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::instance::GetDiskSpaceInfoResponse>>(PrepareAsyncstream_disk_space_infoRaw(context, request, cq));
    }
    // Find the machine id MinKNOW uses for this machine.
    //
    // This is expected to be a descriptive string for the machine, MinKNOW currently uses the network hostname.
    //
    // note: This is the identifier used when sending telemetry data for this instance.
    //
    // Since 1.11
    virtual ::grpc::Status get_machine_id(::grpc::ClientContext* context, const ::minknow_api::instance::GetMachineIdRequest& request, ::minknow_api::instance::GetMachineIdResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::GetMachineIdResponse>> Asyncget_machine_id(::grpc::ClientContext* context, const ::minknow_api::instance::GetMachineIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::GetMachineIdResponse>>(Asyncget_machine_idRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::GetMachineIdResponse>> PrepareAsyncget_machine_id(::grpc::ClientContext* context, const ::minknow_api::instance::GetMachineIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::GetMachineIdResponse>>(PrepareAsyncget_machine_idRaw(context, request, cq));
    }
    // Find a summary of activity on the instance.
    //
    // The information available from this request is also available from other rpc's - this call is intended
    // as a performance improvement for users who watch a large number of streams (specifically over
    // web socket transport).
    //
    // Use this request to find information about the current device, flow cell, protocol and acquisition state.
    // 
    // Since 3.2
    std::unique_ptr< ::grpc::ClientReaderInterface< ::minknow_api::instance::StreamInstanceActivityResponse>> stream_instance_activity(::grpc::ClientContext* context, const ::minknow_api::instance::StreamInstanceActivityRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::minknow_api::instance::StreamInstanceActivityResponse>>(stream_instance_activityRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::instance::StreamInstanceActivityResponse>> Asyncstream_instance_activity(::grpc::ClientContext* context, const ::minknow_api::instance::StreamInstanceActivityRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::instance::StreamInstanceActivityResponse>>(Asyncstream_instance_activityRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::instance::StreamInstanceActivityResponse>> PrepareAsyncstream_instance_activity(::grpc::ClientContext* context, const ::minknow_api::instance::StreamInstanceActivityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::minknow_api::instance::StreamInstanceActivityResponse>>(PrepareAsyncstream_instance_activityRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // Current version information includes:
      // - Minknow version
      // - Protocols version
      // - Distribution version
      virtual void get_version_info(::grpc::ClientContext* context, const ::minknow_api::instance::GetVersionInfoRequest* request, ::minknow_api::instance::GetVersionInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_version_info(::grpc::ClientContext* context, const ::minknow_api::instance::GetVersionInfoRequest* request, ::minknow_api::instance::GetVersionInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Returns various directory locations where minknow is outputting data. The paths are absolute paths, 
      // local to the machine where minknow is installed
      //
      // the `output` base directory can be changed internally
      // the `logs` directory will not be changed and can be stored
      // the `reads` directory is determined  by the read writer config
      virtual void get_output_directories(::grpc::ClientContext* context, const ::minknow_api::instance::GetOutputDirectoriesRequest* request, ::minknow_api::instance::OutputDirectories* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_output_directories(::grpc::ClientContext* context, const ::minknow_api::instance::GetOutputDirectoriesRequest* request, ::minknow_api::instance::OutputDirectories* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // See `get_output_directories`, but this will always return the paths that are defined in the config when the instance
      // of minknow has started
      //
      // Since 1.11
      virtual void get_default_output_directories(::grpc::ClientContext* context, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest* request, ::minknow_api::instance::OutputDirectories* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_default_output_directories(::grpc::ClientContext* context, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest* request, ::minknow_api::instance::OutputDirectories* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Set the base directory to where all data will be output. Must be an absolute directory
      //
      // Fails with INVALID_ARGUMENT if `value` is not absolute.
      // Fails with FAILED_PRECONDITION if this is called during acquisition
      //
      // Since 1.11
      virtual void set_output_directory(::grpc::ClientContext* context, const ::minknow_api::instance::SetOutputDirectoryRequest* request, ::minknow_api::instance::SetOutputDirectoryResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void set_output_directory(::grpc::ClientContext* context, const ::minknow_api::instance::SetOutputDirectoryRequest* request, ::minknow_api::instance::SetOutputDirectoryResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Set the reads directory where read files (hdf5, fastq, protobuf) will be output
      //
      // Fails with INVALID_ARGUMENT if `value` is not absolute.
      // Fails with FAILED_PRECONDITION if this is called during acquisition
      //
      // Since 1.12
      virtual void set_reads_directory(::grpc::ClientContext* context, const ::minknow_api::instance::SetReadsDirectoryRequest* request, ::minknow_api::instance::SetReadsDirectoryResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void set_reads_directory(::grpc::ClientContext* context, const ::minknow_api::instance::SetReadsDirectoryRequest* request, ::minknow_api::instance::SetReadsDirectoryResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Returns information about the amount of disk space available, how much
      // space is needed to stop an experiment cleanly and if MinKNOW thinks
      // that the free disk-space is approaching or past this limit
      //
      // Since 1.11
      virtual void get_disk_space_info(::grpc::ClientContext* context, const ::minknow_api::instance::GetDiskSpaceInfoRequest* request, ::minknow_api::instance::GetDiskSpaceInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_disk_space_info(::grpc::ClientContext* context, const ::minknow_api::instance::GetDiskSpaceInfoRequest* request, ::minknow_api::instance::GetDiskSpaceInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Stream information about the amount of disk space available, how quickly
      // it is being used, how much space is needed to stop an experiment cleanly
      // and if MinKNOW thinks that the free disk-space is approaching or past
      // this limit
      //
      // Since 4.0
      virtual void stream_disk_space_info(::grpc::ClientContext* context, const ::minknow_api::instance::StreamDiskSpaceInfoRequest* request, ::grpc::ClientReadReactor< ::minknow_api::instance::GetDiskSpaceInfoResponse>* reactor) = 0;
      // Find the machine id MinKNOW uses for this machine.
      //
      // This is expected to be a descriptive string for the machine, MinKNOW currently uses the network hostname.
      //
      // note: This is the identifier used when sending telemetry data for this instance.
      //
      // Since 1.11
      virtual void get_machine_id(::grpc::ClientContext* context, const ::minknow_api::instance::GetMachineIdRequest* request, ::minknow_api::instance::GetMachineIdResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_machine_id(::grpc::ClientContext* context, const ::minknow_api::instance::GetMachineIdRequest* request, ::minknow_api::instance::GetMachineIdResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Find a summary of activity on the instance.
      //
      // The information available from this request is also available from other rpc's - this call is intended
      // as a performance improvement for users who watch a large number of streams (specifically over
      // web socket transport).
      //
      // Use this request to find information about the current device, flow cell, protocol and acquisition state.
      // 
      // Since 3.2
      virtual void stream_instance_activity(::grpc::ClientContext* context, const ::minknow_api::instance::StreamInstanceActivityRequest* request, ::grpc::ClientReadReactor< ::minknow_api::instance::StreamInstanceActivityResponse>* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::GetVersionInfoResponse>* Asyncget_version_infoRaw(::grpc::ClientContext* context, const ::minknow_api::instance::GetVersionInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::GetVersionInfoResponse>* PrepareAsyncget_version_infoRaw(::grpc::ClientContext* context, const ::minknow_api::instance::GetVersionInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::OutputDirectories>* Asyncget_output_directoriesRaw(::grpc::ClientContext* context, const ::minknow_api::instance::GetOutputDirectoriesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::OutputDirectories>* PrepareAsyncget_output_directoriesRaw(::grpc::ClientContext* context, const ::minknow_api::instance::GetOutputDirectoriesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::OutputDirectories>* Asyncget_default_output_directoriesRaw(::grpc::ClientContext* context, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::OutputDirectories>* PrepareAsyncget_default_output_directoriesRaw(::grpc::ClientContext* context, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::SetOutputDirectoryResponse>* Asyncset_output_directoryRaw(::grpc::ClientContext* context, const ::minknow_api::instance::SetOutputDirectoryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::SetOutputDirectoryResponse>* PrepareAsyncset_output_directoryRaw(::grpc::ClientContext* context, const ::minknow_api::instance::SetOutputDirectoryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::SetReadsDirectoryResponse>* Asyncset_reads_directoryRaw(::grpc::ClientContext* context, const ::minknow_api::instance::SetReadsDirectoryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::SetReadsDirectoryResponse>* PrepareAsyncset_reads_directoryRaw(::grpc::ClientContext* context, const ::minknow_api::instance::SetReadsDirectoryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::GetDiskSpaceInfoResponse>* Asyncget_disk_space_infoRaw(::grpc::ClientContext* context, const ::minknow_api::instance::GetDiskSpaceInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::GetDiskSpaceInfoResponse>* PrepareAsyncget_disk_space_infoRaw(::grpc::ClientContext* context, const ::minknow_api::instance::GetDiskSpaceInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::minknow_api::instance::GetDiskSpaceInfoResponse>* stream_disk_space_infoRaw(::grpc::ClientContext* context, const ::minknow_api::instance::StreamDiskSpaceInfoRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::minknow_api::instance::GetDiskSpaceInfoResponse>* Asyncstream_disk_space_infoRaw(::grpc::ClientContext* context, const ::minknow_api::instance::StreamDiskSpaceInfoRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::minknow_api::instance::GetDiskSpaceInfoResponse>* PrepareAsyncstream_disk_space_infoRaw(::grpc::ClientContext* context, const ::minknow_api::instance::StreamDiskSpaceInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::GetMachineIdResponse>* Asyncget_machine_idRaw(::grpc::ClientContext* context, const ::minknow_api::instance::GetMachineIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::minknow_api::instance::GetMachineIdResponse>* PrepareAsyncget_machine_idRaw(::grpc::ClientContext* context, const ::minknow_api::instance::GetMachineIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::minknow_api::instance::StreamInstanceActivityResponse>* stream_instance_activityRaw(::grpc::ClientContext* context, const ::minknow_api::instance::StreamInstanceActivityRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::minknow_api::instance::StreamInstanceActivityResponse>* Asyncstream_instance_activityRaw(::grpc::ClientContext* context, const ::minknow_api::instance::StreamInstanceActivityRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::minknow_api::instance::StreamInstanceActivityResponse>* PrepareAsyncstream_instance_activityRaw(::grpc::ClientContext* context, const ::minknow_api::instance::StreamInstanceActivityRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status get_version_info(::grpc::ClientContext* context, const ::minknow_api::instance::GetVersionInfoRequest& request, ::minknow_api::instance::GetVersionInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::GetVersionInfoResponse>> Asyncget_version_info(::grpc::ClientContext* context, const ::minknow_api::instance::GetVersionInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::GetVersionInfoResponse>>(Asyncget_version_infoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::GetVersionInfoResponse>> PrepareAsyncget_version_info(::grpc::ClientContext* context, const ::minknow_api::instance::GetVersionInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::GetVersionInfoResponse>>(PrepareAsyncget_version_infoRaw(context, request, cq));
    }
    ::grpc::Status get_output_directories(::grpc::ClientContext* context, const ::minknow_api::instance::GetOutputDirectoriesRequest& request, ::minknow_api::instance::OutputDirectories* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::OutputDirectories>> Asyncget_output_directories(::grpc::ClientContext* context, const ::minknow_api::instance::GetOutputDirectoriesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::OutputDirectories>>(Asyncget_output_directoriesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::OutputDirectories>> PrepareAsyncget_output_directories(::grpc::ClientContext* context, const ::minknow_api::instance::GetOutputDirectoriesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::OutputDirectories>>(PrepareAsyncget_output_directoriesRaw(context, request, cq));
    }
    ::grpc::Status get_default_output_directories(::grpc::ClientContext* context, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest& request, ::minknow_api::instance::OutputDirectories* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::OutputDirectories>> Asyncget_default_output_directories(::grpc::ClientContext* context, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::OutputDirectories>>(Asyncget_default_output_directoriesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::OutputDirectories>> PrepareAsyncget_default_output_directories(::grpc::ClientContext* context, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::OutputDirectories>>(PrepareAsyncget_default_output_directoriesRaw(context, request, cq));
    }
    ::grpc::Status set_output_directory(::grpc::ClientContext* context, const ::minknow_api::instance::SetOutputDirectoryRequest& request, ::minknow_api::instance::SetOutputDirectoryResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::SetOutputDirectoryResponse>> Asyncset_output_directory(::grpc::ClientContext* context, const ::minknow_api::instance::SetOutputDirectoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::SetOutputDirectoryResponse>>(Asyncset_output_directoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::SetOutputDirectoryResponse>> PrepareAsyncset_output_directory(::grpc::ClientContext* context, const ::minknow_api::instance::SetOutputDirectoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::SetOutputDirectoryResponse>>(PrepareAsyncset_output_directoryRaw(context, request, cq));
    }
    ::grpc::Status set_reads_directory(::grpc::ClientContext* context, const ::minknow_api::instance::SetReadsDirectoryRequest& request, ::minknow_api::instance::SetReadsDirectoryResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::SetReadsDirectoryResponse>> Asyncset_reads_directory(::grpc::ClientContext* context, const ::minknow_api::instance::SetReadsDirectoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::SetReadsDirectoryResponse>>(Asyncset_reads_directoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::SetReadsDirectoryResponse>> PrepareAsyncset_reads_directory(::grpc::ClientContext* context, const ::minknow_api::instance::SetReadsDirectoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::SetReadsDirectoryResponse>>(PrepareAsyncset_reads_directoryRaw(context, request, cq));
    }
    ::grpc::Status get_disk_space_info(::grpc::ClientContext* context, const ::minknow_api::instance::GetDiskSpaceInfoRequest& request, ::minknow_api::instance::GetDiskSpaceInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::GetDiskSpaceInfoResponse>> Asyncget_disk_space_info(::grpc::ClientContext* context, const ::minknow_api::instance::GetDiskSpaceInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::GetDiskSpaceInfoResponse>>(Asyncget_disk_space_infoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::GetDiskSpaceInfoResponse>> PrepareAsyncget_disk_space_info(::grpc::ClientContext* context, const ::minknow_api::instance::GetDiskSpaceInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::GetDiskSpaceInfoResponse>>(PrepareAsyncget_disk_space_infoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::minknow_api::instance::GetDiskSpaceInfoResponse>> stream_disk_space_info(::grpc::ClientContext* context, const ::minknow_api::instance::StreamDiskSpaceInfoRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::minknow_api::instance::GetDiskSpaceInfoResponse>>(stream_disk_space_infoRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::instance::GetDiskSpaceInfoResponse>> Asyncstream_disk_space_info(::grpc::ClientContext* context, const ::minknow_api::instance::StreamDiskSpaceInfoRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::instance::GetDiskSpaceInfoResponse>>(Asyncstream_disk_space_infoRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::instance::GetDiskSpaceInfoResponse>> PrepareAsyncstream_disk_space_info(::grpc::ClientContext* context, const ::minknow_api::instance::StreamDiskSpaceInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::instance::GetDiskSpaceInfoResponse>>(PrepareAsyncstream_disk_space_infoRaw(context, request, cq));
    }
    ::grpc::Status get_machine_id(::grpc::ClientContext* context, const ::minknow_api::instance::GetMachineIdRequest& request, ::minknow_api::instance::GetMachineIdResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::GetMachineIdResponse>> Asyncget_machine_id(::grpc::ClientContext* context, const ::minknow_api::instance::GetMachineIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::GetMachineIdResponse>>(Asyncget_machine_idRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::GetMachineIdResponse>> PrepareAsyncget_machine_id(::grpc::ClientContext* context, const ::minknow_api::instance::GetMachineIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::GetMachineIdResponse>>(PrepareAsyncget_machine_idRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::minknow_api::instance::StreamInstanceActivityResponse>> stream_instance_activity(::grpc::ClientContext* context, const ::minknow_api::instance::StreamInstanceActivityRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::minknow_api::instance::StreamInstanceActivityResponse>>(stream_instance_activityRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::instance::StreamInstanceActivityResponse>> Asyncstream_instance_activity(::grpc::ClientContext* context, const ::minknow_api::instance::StreamInstanceActivityRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::instance::StreamInstanceActivityResponse>>(Asyncstream_instance_activityRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::instance::StreamInstanceActivityResponse>> PrepareAsyncstream_instance_activity(::grpc::ClientContext* context, const ::minknow_api::instance::StreamInstanceActivityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::minknow_api::instance::StreamInstanceActivityResponse>>(PrepareAsyncstream_instance_activityRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void get_version_info(::grpc::ClientContext* context, const ::minknow_api::instance::GetVersionInfoRequest* request, ::minknow_api::instance::GetVersionInfoResponse* response, std::function<void(::grpc::Status)>) override;
      void get_version_info(::grpc::ClientContext* context, const ::minknow_api::instance::GetVersionInfoRequest* request, ::minknow_api::instance::GetVersionInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_output_directories(::grpc::ClientContext* context, const ::minknow_api::instance::GetOutputDirectoriesRequest* request, ::minknow_api::instance::OutputDirectories* response, std::function<void(::grpc::Status)>) override;
      void get_output_directories(::grpc::ClientContext* context, const ::minknow_api::instance::GetOutputDirectoriesRequest* request, ::minknow_api::instance::OutputDirectories* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_default_output_directories(::grpc::ClientContext* context, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest* request, ::minknow_api::instance::OutputDirectories* response, std::function<void(::grpc::Status)>) override;
      void get_default_output_directories(::grpc::ClientContext* context, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest* request, ::minknow_api::instance::OutputDirectories* response, ::grpc::ClientUnaryReactor* reactor) override;
      void set_output_directory(::grpc::ClientContext* context, const ::minknow_api::instance::SetOutputDirectoryRequest* request, ::minknow_api::instance::SetOutputDirectoryResponse* response, std::function<void(::grpc::Status)>) override;
      void set_output_directory(::grpc::ClientContext* context, const ::minknow_api::instance::SetOutputDirectoryRequest* request, ::minknow_api::instance::SetOutputDirectoryResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void set_reads_directory(::grpc::ClientContext* context, const ::minknow_api::instance::SetReadsDirectoryRequest* request, ::minknow_api::instance::SetReadsDirectoryResponse* response, std::function<void(::grpc::Status)>) override;
      void set_reads_directory(::grpc::ClientContext* context, const ::minknow_api::instance::SetReadsDirectoryRequest* request, ::minknow_api::instance::SetReadsDirectoryResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_disk_space_info(::grpc::ClientContext* context, const ::minknow_api::instance::GetDiskSpaceInfoRequest* request, ::minknow_api::instance::GetDiskSpaceInfoResponse* response, std::function<void(::grpc::Status)>) override;
      void get_disk_space_info(::grpc::ClientContext* context, const ::minknow_api::instance::GetDiskSpaceInfoRequest* request, ::minknow_api::instance::GetDiskSpaceInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void stream_disk_space_info(::grpc::ClientContext* context, const ::minknow_api::instance::StreamDiskSpaceInfoRequest* request, ::grpc::ClientReadReactor< ::minknow_api::instance::GetDiskSpaceInfoResponse>* reactor) override;
      void get_machine_id(::grpc::ClientContext* context, const ::minknow_api::instance::GetMachineIdRequest* request, ::minknow_api::instance::GetMachineIdResponse* response, std::function<void(::grpc::Status)>) override;
      void get_machine_id(::grpc::ClientContext* context, const ::minknow_api::instance::GetMachineIdRequest* request, ::minknow_api::instance::GetMachineIdResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void stream_instance_activity(::grpc::ClientContext* context, const ::minknow_api::instance::StreamInstanceActivityRequest* request, ::grpc::ClientReadReactor< ::minknow_api::instance::StreamInstanceActivityResponse>* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::GetVersionInfoResponse>* Asyncget_version_infoRaw(::grpc::ClientContext* context, const ::minknow_api::instance::GetVersionInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::GetVersionInfoResponse>* PrepareAsyncget_version_infoRaw(::grpc::ClientContext* context, const ::minknow_api::instance::GetVersionInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::OutputDirectories>* Asyncget_output_directoriesRaw(::grpc::ClientContext* context, const ::minknow_api::instance::GetOutputDirectoriesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::OutputDirectories>* PrepareAsyncget_output_directoriesRaw(::grpc::ClientContext* context, const ::minknow_api::instance::GetOutputDirectoriesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::OutputDirectories>* Asyncget_default_output_directoriesRaw(::grpc::ClientContext* context, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::OutputDirectories>* PrepareAsyncget_default_output_directoriesRaw(::grpc::ClientContext* context, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::SetOutputDirectoryResponse>* Asyncset_output_directoryRaw(::grpc::ClientContext* context, const ::minknow_api::instance::SetOutputDirectoryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::SetOutputDirectoryResponse>* PrepareAsyncset_output_directoryRaw(::grpc::ClientContext* context, const ::minknow_api::instance::SetOutputDirectoryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::SetReadsDirectoryResponse>* Asyncset_reads_directoryRaw(::grpc::ClientContext* context, const ::minknow_api::instance::SetReadsDirectoryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::SetReadsDirectoryResponse>* PrepareAsyncset_reads_directoryRaw(::grpc::ClientContext* context, const ::minknow_api::instance::SetReadsDirectoryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::GetDiskSpaceInfoResponse>* Asyncget_disk_space_infoRaw(::grpc::ClientContext* context, const ::minknow_api::instance::GetDiskSpaceInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::GetDiskSpaceInfoResponse>* PrepareAsyncget_disk_space_infoRaw(::grpc::ClientContext* context, const ::minknow_api::instance::GetDiskSpaceInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::minknow_api::instance::GetDiskSpaceInfoResponse>* stream_disk_space_infoRaw(::grpc::ClientContext* context, const ::minknow_api::instance::StreamDiskSpaceInfoRequest& request) override;
    ::grpc::ClientAsyncReader< ::minknow_api::instance::GetDiskSpaceInfoResponse>* Asyncstream_disk_space_infoRaw(::grpc::ClientContext* context, const ::minknow_api::instance::StreamDiskSpaceInfoRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::minknow_api::instance::GetDiskSpaceInfoResponse>* PrepareAsyncstream_disk_space_infoRaw(::grpc::ClientContext* context, const ::minknow_api::instance::StreamDiskSpaceInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::GetMachineIdResponse>* Asyncget_machine_idRaw(::grpc::ClientContext* context, const ::minknow_api::instance::GetMachineIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::minknow_api::instance::GetMachineIdResponse>* PrepareAsyncget_machine_idRaw(::grpc::ClientContext* context, const ::minknow_api::instance::GetMachineIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::minknow_api::instance::StreamInstanceActivityResponse>* stream_instance_activityRaw(::grpc::ClientContext* context, const ::minknow_api::instance::StreamInstanceActivityRequest& request) override;
    ::grpc::ClientAsyncReader< ::minknow_api::instance::StreamInstanceActivityResponse>* Asyncstream_instance_activityRaw(::grpc::ClientContext* context, const ::minknow_api::instance::StreamInstanceActivityRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::minknow_api::instance::StreamInstanceActivityResponse>* PrepareAsyncstream_instance_activityRaw(::grpc::ClientContext* context, const ::minknow_api::instance::StreamInstanceActivityRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_get_version_info_;
    const ::grpc::internal::RpcMethod rpcmethod_get_output_directories_;
    const ::grpc::internal::RpcMethod rpcmethod_get_default_output_directories_;
    const ::grpc::internal::RpcMethod rpcmethod_set_output_directory_;
    const ::grpc::internal::RpcMethod rpcmethod_set_reads_directory_;
    const ::grpc::internal::RpcMethod rpcmethod_get_disk_space_info_;
    const ::grpc::internal::RpcMethod rpcmethod_stream_disk_space_info_;
    const ::grpc::internal::RpcMethod rpcmethod_get_machine_id_;
    const ::grpc::internal::RpcMethod rpcmethod_stream_instance_activity_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Current version information includes:
    // - Minknow version
    // - Protocols version
    // - Distribution version
    virtual ::grpc::Status get_version_info(::grpc::ServerContext* context, const ::minknow_api::instance::GetVersionInfoRequest* request, ::minknow_api::instance::GetVersionInfoResponse* response);
    // Returns various directory locations where minknow is outputting data. The paths are absolute paths, 
    // local to the machine where minknow is installed
    //
    // the `output` base directory can be changed internally
    // the `logs` directory will not be changed and can be stored
    // the `reads` directory is determined  by the read writer config
    virtual ::grpc::Status get_output_directories(::grpc::ServerContext* context, const ::minknow_api::instance::GetOutputDirectoriesRequest* request, ::minknow_api::instance::OutputDirectories* response);
    // See `get_output_directories`, but this will always return the paths that are defined in the config when the instance
    // of minknow has started
    //
    // Since 1.11
    virtual ::grpc::Status get_default_output_directories(::grpc::ServerContext* context, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest* request, ::minknow_api::instance::OutputDirectories* response);
    // Set the base directory to where all data will be output. Must be an absolute directory
    //
    // Fails with INVALID_ARGUMENT if `value` is not absolute.
    // Fails with FAILED_PRECONDITION if this is called during acquisition
    //
    // Since 1.11
    virtual ::grpc::Status set_output_directory(::grpc::ServerContext* context, const ::minknow_api::instance::SetOutputDirectoryRequest* request, ::minknow_api::instance::SetOutputDirectoryResponse* response);
    // Set the reads directory where read files (hdf5, fastq, protobuf) will be output
    //
    // Fails with INVALID_ARGUMENT if `value` is not absolute.
    // Fails with FAILED_PRECONDITION if this is called during acquisition
    //
    // Since 1.12
    virtual ::grpc::Status set_reads_directory(::grpc::ServerContext* context, const ::minknow_api::instance::SetReadsDirectoryRequest* request, ::minknow_api::instance::SetReadsDirectoryResponse* response);
    // Returns information about the amount of disk space available, how much
    // space is needed to stop an experiment cleanly and if MinKNOW thinks
    // that the free disk-space is approaching or past this limit
    //
    // Since 1.11
    virtual ::grpc::Status get_disk_space_info(::grpc::ServerContext* context, const ::minknow_api::instance::GetDiskSpaceInfoRequest* request, ::minknow_api::instance::GetDiskSpaceInfoResponse* response);
    // Stream information about the amount of disk space available, how quickly
    // it is being used, how much space is needed to stop an experiment cleanly
    // and if MinKNOW thinks that the free disk-space is approaching or past
    // this limit
    //
    // Since 4.0
    virtual ::grpc::Status stream_disk_space_info(::grpc::ServerContext* context, const ::minknow_api::instance::StreamDiskSpaceInfoRequest* request, ::grpc::ServerWriter< ::minknow_api::instance::GetDiskSpaceInfoResponse>* writer);
    // Find the machine id MinKNOW uses for this machine.
    //
    // This is expected to be a descriptive string for the machine, MinKNOW currently uses the network hostname.
    //
    // note: This is the identifier used when sending telemetry data for this instance.
    //
    // Since 1.11
    virtual ::grpc::Status get_machine_id(::grpc::ServerContext* context, const ::minknow_api::instance::GetMachineIdRequest* request, ::minknow_api::instance::GetMachineIdResponse* response);
    // Find a summary of activity on the instance.
    //
    // The information available from this request is also available from other rpc's - this call is intended
    // as a performance improvement for users who watch a large number of streams (specifically over
    // web socket transport).
    //
    // Use this request to find information about the current device, flow cell, protocol and acquisition state.
    // 
    // Since 3.2
    virtual ::grpc::Status stream_instance_activity(::grpc::ServerContext* context, const ::minknow_api::instance::StreamInstanceActivityRequest* request, ::grpc::ServerWriter< ::minknow_api::instance::StreamInstanceActivityResponse>* writer);
  };
  template <class BaseClass>
  class WithAsyncMethod_get_version_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_version_info() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_get_version_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_version_info(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::GetVersionInfoRequest* /*request*/, ::minknow_api::instance::GetVersionInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_version_info(::grpc::ServerContext* context, ::minknow_api::instance::GetVersionInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::instance::GetVersionInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_output_directories : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_output_directories() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_get_output_directories() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_output_directories(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::GetOutputDirectoriesRequest* /*request*/, ::minknow_api::instance::OutputDirectories* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_output_directories(::grpc::ServerContext* context, ::minknow_api::instance::GetOutputDirectoriesRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::instance::OutputDirectories>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_default_output_directories : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_default_output_directories() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_get_default_output_directories() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_default_output_directories(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest* /*request*/, ::minknow_api::instance::OutputDirectories* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_default_output_directories(::grpc::ServerContext* context, ::minknow_api::instance::GetDefaultOutputDirectoriesRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::instance::OutputDirectories>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_set_output_directory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_set_output_directory() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_set_output_directory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_output_directory(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::SetOutputDirectoryRequest* /*request*/, ::minknow_api::instance::SetOutputDirectoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_output_directory(::grpc::ServerContext* context, ::minknow_api::instance::SetOutputDirectoryRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::instance::SetOutputDirectoryResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_set_reads_directory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_set_reads_directory() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_set_reads_directory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_reads_directory(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::SetReadsDirectoryRequest* /*request*/, ::minknow_api::instance::SetReadsDirectoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_reads_directory(::grpc::ServerContext* context, ::minknow_api::instance::SetReadsDirectoryRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::instance::SetReadsDirectoryResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_disk_space_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_disk_space_info() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_get_disk_space_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_disk_space_info(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::GetDiskSpaceInfoRequest* /*request*/, ::minknow_api::instance::GetDiskSpaceInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_disk_space_info(::grpc::ServerContext* context, ::minknow_api::instance::GetDiskSpaceInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::instance::GetDiskSpaceInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_stream_disk_space_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_stream_disk_space_info() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_stream_disk_space_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stream_disk_space_info(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::StreamDiskSpaceInfoRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::instance::GetDiskSpaceInfoResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requeststream_disk_space_info(::grpc::ServerContext* context, ::minknow_api::instance::StreamDiskSpaceInfoRequest* request, ::grpc::ServerAsyncWriter< ::minknow_api::instance::GetDiskSpaceInfoResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(6, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_machine_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_machine_id() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_get_machine_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_machine_id(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::GetMachineIdRequest* /*request*/, ::minknow_api::instance::GetMachineIdResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_machine_id(::grpc::ServerContext* context, ::minknow_api::instance::GetMachineIdRequest* request, ::grpc::ServerAsyncResponseWriter< ::minknow_api::instance::GetMachineIdResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_stream_instance_activity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_stream_instance_activity() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_stream_instance_activity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stream_instance_activity(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::StreamInstanceActivityRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::instance::StreamInstanceActivityResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requeststream_instance_activity(::grpc::ServerContext* context, ::minknow_api::instance::StreamInstanceActivityRequest* request, ::grpc::ServerAsyncWriter< ::minknow_api::instance::StreamInstanceActivityResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(8, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_get_version_info<WithAsyncMethod_get_output_directories<WithAsyncMethod_get_default_output_directories<WithAsyncMethod_set_output_directory<WithAsyncMethod_set_reads_directory<WithAsyncMethod_get_disk_space_info<WithAsyncMethod_stream_disk_space_info<WithAsyncMethod_get_machine_id<WithAsyncMethod_stream_instance_activity<Service > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_get_version_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_version_info() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::instance::GetVersionInfoRequest, ::minknow_api::instance::GetVersionInfoResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::instance::GetVersionInfoRequest* request, ::minknow_api::instance::GetVersionInfoResponse* response) { return this->get_version_info(context, request, response); }));}
    void SetMessageAllocatorFor_get_version_info(
        ::grpc::MessageAllocator< ::minknow_api::instance::GetVersionInfoRequest, ::minknow_api::instance::GetVersionInfoResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::instance::GetVersionInfoRequest, ::minknow_api::instance::GetVersionInfoResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_version_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_version_info(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::GetVersionInfoRequest* /*request*/, ::minknow_api::instance::GetVersionInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_version_info(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::instance::GetVersionInfoRequest* /*request*/, ::minknow_api::instance::GetVersionInfoResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_output_directories : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_output_directories() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::instance::GetOutputDirectoriesRequest, ::minknow_api::instance::OutputDirectories>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::instance::GetOutputDirectoriesRequest* request, ::minknow_api::instance::OutputDirectories* response) { return this->get_output_directories(context, request, response); }));}
    void SetMessageAllocatorFor_get_output_directories(
        ::grpc::MessageAllocator< ::minknow_api::instance::GetOutputDirectoriesRequest, ::minknow_api::instance::OutputDirectories>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::instance::GetOutputDirectoriesRequest, ::minknow_api::instance::OutputDirectories>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_output_directories() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_output_directories(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::GetOutputDirectoriesRequest* /*request*/, ::minknow_api::instance::OutputDirectories* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_output_directories(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::instance::GetOutputDirectoriesRequest* /*request*/, ::minknow_api::instance::OutputDirectories* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_default_output_directories : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_default_output_directories() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::instance::GetDefaultOutputDirectoriesRequest, ::minknow_api::instance::OutputDirectories>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest* request, ::minknow_api::instance::OutputDirectories* response) { return this->get_default_output_directories(context, request, response); }));}
    void SetMessageAllocatorFor_get_default_output_directories(
        ::grpc::MessageAllocator< ::minknow_api::instance::GetDefaultOutputDirectoriesRequest, ::minknow_api::instance::OutputDirectories>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::instance::GetDefaultOutputDirectoriesRequest, ::minknow_api::instance::OutputDirectories>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_default_output_directories() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_default_output_directories(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest* /*request*/, ::minknow_api::instance::OutputDirectories* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_default_output_directories(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest* /*request*/, ::minknow_api::instance::OutputDirectories* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_set_output_directory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_set_output_directory() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::instance::SetOutputDirectoryRequest, ::minknow_api::instance::SetOutputDirectoryResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::instance::SetOutputDirectoryRequest* request, ::minknow_api::instance::SetOutputDirectoryResponse* response) { return this->set_output_directory(context, request, response); }));}
    void SetMessageAllocatorFor_set_output_directory(
        ::grpc::MessageAllocator< ::minknow_api::instance::SetOutputDirectoryRequest, ::minknow_api::instance::SetOutputDirectoryResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::instance::SetOutputDirectoryRequest, ::minknow_api::instance::SetOutputDirectoryResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_set_output_directory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_output_directory(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::SetOutputDirectoryRequest* /*request*/, ::minknow_api::instance::SetOutputDirectoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_output_directory(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::instance::SetOutputDirectoryRequest* /*request*/, ::minknow_api::instance::SetOutputDirectoryResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_set_reads_directory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_set_reads_directory() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::instance::SetReadsDirectoryRequest, ::minknow_api::instance::SetReadsDirectoryResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::instance::SetReadsDirectoryRequest* request, ::minknow_api::instance::SetReadsDirectoryResponse* response) { return this->set_reads_directory(context, request, response); }));}
    void SetMessageAllocatorFor_set_reads_directory(
        ::grpc::MessageAllocator< ::minknow_api::instance::SetReadsDirectoryRequest, ::minknow_api::instance::SetReadsDirectoryResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::instance::SetReadsDirectoryRequest, ::minknow_api::instance::SetReadsDirectoryResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_set_reads_directory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_reads_directory(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::SetReadsDirectoryRequest* /*request*/, ::minknow_api::instance::SetReadsDirectoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_reads_directory(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::instance::SetReadsDirectoryRequest* /*request*/, ::minknow_api::instance::SetReadsDirectoryResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_disk_space_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_disk_space_info() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::instance::GetDiskSpaceInfoRequest, ::minknow_api::instance::GetDiskSpaceInfoResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::instance::GetDiskSpaceInfoRequest* request, ::minknow_api::instance::GetDiskSpaceInfoResponse* response) { return this->get_disk_space_info(context, request, response); }));}
    void SetMessageAllocatorFor_get_disk_space_info(
        ::grpc::MessageAllocator< ::minknow_api::instance::GetDiskSpaceInfoRequest, ::minknow_api::instance::GetDiskSpaceInfoResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::instance::GetDiskSpaceInfoRequest, ::minknow_api::instance::GetDiskSpaceInfoResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_disk_space_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_disk_space_info(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::GetDiskSpaceInfoRequest* /*request*/, ::minknow_api::instance::GetDiskSpaceInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_disk_space_info(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::instance::GetDiskSpaceInfoRequest* /*request*/, ::minknow_api::instance::GetDiskSpaceInfoResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_stream_disk_space_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_stream_disk_space_info() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackServerStreamingHandler< ::minknow_api::instance::StreamDiskSpaceInfoRequest, ::minknow_api::instance::GetDiskSpaceInfoResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::instance::StreamDiskSpaceInfoRequest* request) { return this->stream_disk_space_info(context, request); }));
    }
    ~WithCallbackMethod_stream_disk_space_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stream_disk_space_info(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::StreamDiskSpaceInfoRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::instance::GetDiskSpaceInfoResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::minknow_api::instance::GetDiskSpaceInfoResponse>* stream_disk_space_info(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::instance::StreamDiskSpaceInfoRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_machine_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_machine_id() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::minknow_api::instance::GetMachineIdRequest, ::minknow_api::instance::GetMachineIdResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::instance::GetMachineIdRequest* request, ::minknow_api::instance::GetMachineIdResponse* response) { return this->get_machine_id(context, request, response); }));}
    void SetMessageAllocatorFor_get_machine_id(
        ::grpc::MessageAllocator< ::minknow_api::instance::GetMachineIdRequest, ::minknow_api::instance::GetMachineIdResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::minknow_api::instance::GetMachineIdRequest, ::minknow_api::instance::GetMachineIdResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_machine_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_machine_id(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::GetMachineIdRequest* /*request*/, ::minknow_api::instance::GetMachineIdResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_machine_id(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::instance::GetMachineIdRequest* /*request*/, ::minknow_api::instance::GetMachineIdResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_stream_instance_activity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_stream_instance_activity() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackServerStreamingHandler< ::minknow_api::instance::StreamInstanceActivityRequest, ::minknow_api::instance::StreamInstanceActivityResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::minknow_api::instance::StreamInstanceActivityRequest* request) { return this->stream_instance_activity(context, request); }));
    }
    ~WithCallbackMethod_stream_instance_activity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stream_instance_activity(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::StreamInstanceActivityRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::instance::StreamInstanceActivityResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::minknow_api::instance::StreamInstanceActivityResponse>* stream_instance_activity(
      ::grpc::CallbackServerContext* /*context*/, const ::minknow_api::instance::StreamInstanceActivityRequest* /*request*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_get_version_info<WithCallbackMethod_get_output_directories<WithCallbackMethod_get_default_output_directories<WithCallbackMethod_set_output_directory<WithCallbackMethod_set_reads_directory<WithCallbackMethod_get_disk_space_info<WithCallbackMethod_stream_disk_space_info<WithCallbackMethod_get_machine_id<WithCallbackMethod_stream_instance_activity<Service > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_get_version_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_version_info() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_get_version_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_version_info(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::GetVersionInfoRequest* /*request*/, ::minknow_api::instance::GetVersionInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_output_directories : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_output_directories() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_get_output_directories() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_output_directories(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::GetOutputDirectoriesRequest* /*request*/, ::minknow_api::instance::OutputDirectories* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_default_output_directories : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_default_output_directories() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_get_default_output_directories() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_default_output_directories(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest* /*request*/, ::minknow_api::instance::OutputDirectories* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_set_output_directory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_set_output_directory() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_set_output_directory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_output_directory(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::SetOutputDirectoryRequest* /*request*/, ::minknow_api::instance::SetOutputDirectoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_set_reads_directory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_set_reads_directory() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_set_reads_directory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_reads_directory(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::SetReadsDirectoryRequest* /*request*/, ::minknow_api::instance::SetReadsDirectoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_disk_space_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_disk_space_info() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_get_disk_space_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_disk_space_info(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::GetDiskSpaceInfoRequest* /*request*/, ::minknow_api::instance::GetDiskSpaceInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_stream_disk_space_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_stream_disk_space_info() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_stream_disk_space_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stream_disk_space_info(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::StreamDiskSpaceInfoRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::instance::GetDiskSpaceInfoResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_machine_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_machine_id() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_get_machine_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_machine_id(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::GetMachineIdRequest* /*request*/, ::minknow_api::instance::GetMachineIdResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_stream_instance_activity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_stream_instance_activity() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_stream_instance_activity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stream_instance_activity(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::StreamInstanceActivityRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::instance::StreamInstanceActivityResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_version_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_version_info() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_get_version_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_version_info(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::GetVersionInfoRequest* /*request*/, ::minknow_api::instance::GetVersionInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_version_info(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_output_directories : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_output_directories() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_get_output_directories() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_output_directories(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::GetOutputDirectoriesRequest* /*request*/, ::minknow_api::instance::OutputDirectories* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_output_directories(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_default_output_directories : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_default_output_directories() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_get_default_output_directories() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_default_output_directories(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest* /*request*/, ::minknow_api::instance::OutputDirectories* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_default_output_directories(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_set_output_directory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_set_output_directory() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_set_output_directory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_output_directory(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::SetOutputDirectoryRequest* /*request*/, ::minknow_api::instance::SetOutputDirectoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_output_directory(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_set_reads_directory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_set_reads_directory() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_set_reads_directory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_reads_directory(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::SetReadsDirectoryRequest* /*request*/, ::minknow_api::instance::SetReadsDirectoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_reads_directory(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_disk_space_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_disk_space_info() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_get_disk_space_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_disk_space_info(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::GetDiskSpaceInfoRequest* /*request*/, ::minknow_api::instance::GetDiskSpaceInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_disk_space_info(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_stream_disk_space_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_stream_disk_space_info() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_stream_disk_space_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stream_disk_space_info(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::StreamDiskSpaceInfoRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::instance::GetDiskSpaceInfoResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requeststream_disk_space_info(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(6, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_machine_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_machine_id() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_get_machine_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_machine_id(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::GetMachineIdRequest* /*request*/, ::minknow_api::instance::GetMachineIdResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_machine_id(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_stream_instance_activity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_stream_instance_activity() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_stream_instance_activity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stream_instance_activity(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::StreamInstanceActivityRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::instance::StreamInstanceActivityResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requeststream_instance_activity(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(8, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_version_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_version_info() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_version_info(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_version_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_version_info(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::GetVersionInfoRequest* /*request*/, ::minknow_api::instance::GetVersionInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_version_info(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_output_directories : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_output_directories() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_output_directories(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_output_directories() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_output_directories(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::GetOutputDirectoriesRequest* /*request*/, ::minknow_api::instance::OutputDirectories* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_output_directories(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_default_output_directories : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_default_output_directories() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_default_output_directories(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_default_output_directories() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_default_output_directories(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest* /*request*/, ::minknow_api::instance::OutputDirectories* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_default_output_directories(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_set_output_directory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_set_output_directory() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->set_output_directory(context, request, response); }));
    }
    ~WithRawCallbackMethod_set_output_directory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_output_directory(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::SetOutputDirectoryRequest* /*request*/, ::minknow_api::instance::SetOutputDirectoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_output_directory(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_set_reads_directory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_set_reads_directory() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->set_reads_directory(context, request, response); }));
    }
    ~WithRawCallbackMethod_set_reads_directory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_reads_directory(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::SetReadsDirectoryRequest* /*request*/, ::minknow_api::instance::SetReadsDirectoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_reads_directory(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_disk_space_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_disk_space_info() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_disk_space_info(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_disk_space_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_disk_space_info(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::GetDiskSpaceInfoRequest* /*request*/, ::minknow_api::instance::GetDiskSpaceInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_disk_space_info(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_stream_disk_space_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_stream_disk_space_info() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->stream_disk_space_info(context, request); }));
    }
    ~WithRawCallbackMethod_stream_disk_space_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stream_disk_space_info(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::StreamDiskSpaceInfoRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::instance::GetDiskSpaceInfoResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* stream_disk_space_info(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_machine_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_machine_id() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_machine_id(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_machine_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_machine_id(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::GetMachineIdRequest* /*request*/, ::minknow_api::instance::GetMachineIdResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_machine_id(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_stream_instance_activity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_stream_instance_activity() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->stream_instance_activity(context, request); }));
    }
    ~WithRawCallbackMethod_stream_instance_activity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stream_instance_activity(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::StreamInstanceActivityRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::instance::StreamInstanceActivityResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* stream_instance_activity(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_version_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_version_info() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::instance::GetVersionInfoRequest, ::minknow_api::instance::GetVersionInfoResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::instance::GetVersionInfoRequest, ::minknow_api::instance::GetVersionInfoResponse>* streamer) {
                       return this->Streamedget_version_info(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_version_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_version_info(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::GetVersionInfoRequest* /*request*/, ::minknow_api::instance::GetVersionInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_version_info(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::instance::GetVersionInfoRequest,::minknow_api::instance::GetVersionInfoResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_output_directories : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_output_directories() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::instance::GetOutputDirectoriesRequest, ::minknow_api::instance::OutputDirectories>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::instance::GetOutputDirectoriesRequest, ::minknow_api::instance::OutputDirectories>* streamer) {
                       return this->Streamedget_output_directories(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_output_directories() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_output_directories(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::GetOutputDirectoriesRequest* /*request*/, ::minknow_api::instance::OutputDirectories* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_output_directories(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::instance::GetOutputDirectoriesRequest,::minknow_api::instance::OutputDirectories>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_default_output_directories : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_default_output_directories() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::instance::GetDefaultOutputDirectoriesRequest, ::minknow_api::instance::OutputDirectories>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::instance::GetDefaultOutputDirectoriesRequest, ::minknow_api::instance::OutputDirectories>* streamer) {
                       return this->Streamedget_default_output_directories(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_default_output_directories() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_default_output_directories(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::GetDefaultOutputDirectoriesRequest* /*request*/, ::minknow_api::instance::OutputDirectories* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_default_output_directories(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::instance::GetDefaultOutputDirectoriesRequest,::minknow_api::instance::OutputDirectories>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_set_output_directory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_set_output_directory() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::instance::SetOutputDirectoryRequest, ::minknow_api::instance::SetOutputDirectoryResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::instance::SetOutputDirectoryRequest, ::minknow_api::instance::SetOutputDirectoryResponse>* streamer) {
                       return this->Streamedset_output_directory(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_set_output_directory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status set_output_directory(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::SetOutputDirectoryRequest* /*request*/, ::minknow_api::instance::SetOutputDirectoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedset_output_directory(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::instance::SetOutputDirectoryRequest,::minknow_api::instance::SetOutputDirectoryResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_set_reads_directory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_set_reads_directory() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::instance::SetReadsDirectoryRequest, ::minknow_api::instance::SetReadsDirectoryResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::instance::SetReadsDirectoryRequest, ::minknow_api::instance::SetReadsDirectoryResponse>* streamer) {
                       return this->Streamedset_reads_directory(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_set_reads_directory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status set_reads_directory(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::SetReadsDirectoryRequest* /*request*/, ::minknow_api::instance::SetReadsDirectoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedset_reads_directory(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::instance::SetReadsDirectoryRequest,::minknow_api::instance::SetReadsDirectoryResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_disk_space_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_disk_space_info() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::instance::GetDiskSpaceInfoRequest, ::minknow_api::instance::GetDiskSpaceInfoResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::instance::GetDiskSpaceInfoRequest, ::minknow_api::instance::GetDiskSpaceInfoResponse>* streamer) {
                       return this->Streamedget_disk_space_info(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_disk_space_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_disk_space_info(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::GetDiskSpaceInfoRequest* /*request*/, ::minknow_api::instance::GetDiskSpaceInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_disk_space_info(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::instance::GetDiskSpaceInfoRequest,::minknow_api::instance::GetDiskSpaceInfoResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_machine_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_machine_id() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::minknow_api::instance::GetMachineIdRequest, ::minknow_api::instance::GetMachineIdResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::minknow_api::instance::GetMachineIdRequest, ::minknow_api::instance::GetMachineIdResponse>* streamer) {
                       return this->Streamedget_machine_id(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_machine_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_machine_id(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::GetMachineIdRequest* /*request*/, ::minknow_api::instance::GetMachineIdResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_machine_id(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::minknow_api::instance::GetMachineIdRequest,::minknow_api::instance::GetMachineIdResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_get_version_info<WithStreamedUnaryMethod_get_output_directories<WithStreamedUnaryMethod_get_default_output_directories<WithStreamedUnaryMethod_set_output_directory<WithStreamedUnaryMethod_set_reads_directory<WithStreamedUnaryMethod_get_disk_space_info<WithStreamedUnaryMethod_get_machine_id<Service > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_stream_disk_space_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_stream_disk_space_info() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::minknow_api::instance::StreamDiskSpaceInfoRequest, ::minknow_api::instance::GetDiskSpaceInfoResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::minknow_api::instance::StreamDiskSpaceInfoRequest, ::minknow_api::instance::GetDiskSpaceInfoResponse>* streamer) {
                       return this->Streamedstream_disk_space_info(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_stream_disk_space_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status stream_disk_space_info(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::StreamDiskSpaceInfoRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::instance::GetDiskSpaceInfoResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status Streamedstream_disk_space_info(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::minknow_api::instance::StreamDiskSpaceInfoRequest,::minknow_api::instance::GetDiskSpaceInfoResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_stream_instance_activity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_stream_instance_activity() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::minknow_api::instance::StreamInstanceActivityRequest, ::minknow_api::instance::StreamInstanceActivityResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::minknow_api::instance::StreamInstanceActivityRequest, ::minknow_api::instance::StreamInstanceActivityResponse>* streamer) {
                       return this->Streamedstream_instance_activity(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_stream_instance_activity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status stream_instance_activity(::grpc::ServerContext* /*context*/, const ::minknow_api::instance::StreamInstanceActivityRequest* /*request*/, ::grpc::ServerWriter< ::minknow_api::instance::StreamInstanceActivityResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status Streamedstream_instance_activity(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::minknow_api::instance::StreamInstanceActivityRequest,::minknow_api::instance::StreamInstanceActivityResponse>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_stream_disk_space_info<WithSplitStreamingMethod_stream_instance_activity<Service > > SplitStreamedService;
  typedef WithStreamedUnaryMethod_get_version_info<WithStreamedUnaryMethod_get_output_directories<WithStreamedUnaryMethod_get_default_output_directories<WithStreamedUnaryMethod_set_output_directory<WithStreamedUnaryMethod_set_reads_directory<WithStreamedUnaryMethod_get_disk_space_info<WithSplitStreamingMethod_stream_disk_space_info<WithStreamedUnaryMethod_get_machine_id<WithSplitStreamingMethod_stream_instance_activity<Service > > > > > > > > > StreamedService;
};

}  // namespace instance
}  // namespace minknow_api


#endif  // GRPC_minknow_5fapi_2finstance_2eproto__INCLUDED
